/* automatically generated by rust-bindgen */

pub const VULKAN_H_: ::std::os::raw::c_uint = 1;
pub const VK_VERSION_1_0: ::std::os::raw::c_uint = 1;
pub const _STDINT_H: ::std::os::raw::c_uint = 1;
pub const _FEATURES_H: ::std::os::raw::c_uint = 1;
pub const _DEFAULT_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC11: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC99: ::std::os::raw::c_uint = 1;
pub const __USE_ISOC95: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX_IMPLICITLY: ::std::os::raw::c_uint = 1;
pub const _POSIX_SOURCE: ::std::os::raw::c_uint = 1;
pub const _POSIX_C_SOURCE: ::std::os::raw::c_uint = 200809;
pub const __USE_POSIX: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX2: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199309: ::std::os::raw::c_uint = 1;
pub const __USE_POSIX199506: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K: ::std::os::raw::c_uint = 1;
pub const __USE_XOPEN2K8: ::std::os::raw::c_uint = 1;
pub const _ATFILE_SOURCE: ::std::os::raw::c_uint = 1;
pub const __USE_MISC: ::std::os::raw::c_uint = 1;
pub const __USE_ATFILE: ::std::os::raw::c_uint = 1;
pub const __USE_FORTIFY_LEVEL: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: ::std::os::raw::c_uint = 0;
pub const _STDC_PREDEF_H: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559__: ::std::os::raw::c_uint = 1;
pub const __STDC_IEC_559_COMPLEX__: ::std::os::raw::c_uint = 1;
pub const __STDC_ISO_10646__: ::std::os::raw::c_uint = 201706;
pub const __STDC_NO_THREADS__: ::std::os::raw::c_uint = 1;
pub const __GNU_LIBRARY__: ::std::os::raw::c_uint = 6;
pub const __GLIBC__: ::std::os::raw::c_uint = 2;
pub const __GLIBC_MINOR__: ::std::os::raw::c_uint = 26;
pub const _SYS_CDEFS_H: ::std::os::raw::c_uint = 1;
pub const __glibc_c99_flexarr_available: ::std::os::raw::c_uint = 1;
pub const __WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __WORDSIZE_TIME64_COMPAT32: ::std::os::raw::c_uint = 1;
pub const __SYSCALL_WORDSIZE: ::std::os::raw::c_uint = 64;
pub const __HAVE_GENERIC_SELECTION: ::std::os::raw::c_uint = 1;
pub const __GLIBC_USE_LIB_EXT2: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: ::std::os::raw::c_uint = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: ::std::os::raw::c_uint = 0;
pub const _BITS_TYPES_H: ::std::os::raw::c_uint = 1;
pub const _BITS_TYPESIZES_H: ::std::os::raw::c_uint = 1;
pub const __OFF_T_MATCHES_OFF64_T: ::std::os::raw::c_uint = 1;
pub const __INO_T_MATCHES_INO64_T: ::std::os::raw::c_uint = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: ::std::os::raw::c_uint = 1;
pub const __FD_SETSIZE: ::std::os::raw::c_uint = 1024;
pub const _BITS_WCHAR_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_INTN_H: ::std::os::raw::c_uint = 1;
pub const _BITS_STDINT_UINTN_H: ::std::os::raw::c_uint = 1;
pub const INT8_MIN: ::std::os::raw::c_int = -128;
pub const INT16_MIN: ::std::os::raw::c_int = -32768;
pub const INT32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT8_MAX: ::std::os::raw::c_uint = 127;
pub const INT16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_LEAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_LEAST16_MIN: ::std::os::raw::c_int = -32768;
pub const INT_LEAST32_MIN: ::std::os::raw::c_int = -2147483648;
pub const INT_LEAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_LEAST16_MAX: ::std::os::raw::c_uint = 32767;
pub const INT_LEAST32_MAX: ::std::os::raw::c_uint = 2147483647;
pub const UINT_LEAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_LEAST16_MAX: ::std::os::raw::c_uint = 65535;
pub const UINT_LEAST32_MAX: ::std::os::raw::c_uint = 4294967295;
pub const INT_FAST8_MIN: ::std::os::raw::c_int = -128;
pub const INT_FAST16_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST32_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INT_FAST8_MAX: ::std::os::raw::c_uint = 127;
pub const INT_FAST16_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const INT_FAST32_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINT_FAST8_MAX: ::std::os::raw::c_uint = 255;
pub const UINT_FAST16_MAX: ::std::os::raw::c_int = -1;
pub const UINT_FAST32_MAX: ::std::os::raw::c_int = -1;
pub const INTPTR_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const INTPTR_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const UINTPTR_MAX: ::std::os::raw::c_int = -1;
pub const PTRDIFF_MIN: ::std::os::raw::c_longlong = -9223372036854775808;
pub const PTRDIFF_MAX: ::std::os::raw::c_ulonglong = 9223372036854775807;
pub const SIG_ATOMIC_MIN: ::std::os::raw::c_int = -2147483648;
pub const SIG_ATOMIC_MAX: ::std::os::raw::c_uint = 2147483647;
pub const SIZE_MAX: ::std::os::raw::c_int = -1;
pub const WINT_MIN: ::std::os::raw::c_uint = 0;
pub const WINT_MAX: ::std::os::raw::c_uint = 4294967295;
pub const VK_HEADER_VERSION: ::std::os::raw::c_uint = 59;
pub const VK_NULL_HANDLE: ::std::os::raw::c_uint = 0;
pub const VK_LOD_CLAMP_NONE: f64 = 1000.;
pub const VK_REMAINING_MIP_LEVELS: ::std::os::raw::c_int = -1;
pub const VK_REMAINING_ARRAY_LAYERS: ::std::os::raw::c_int = -1;
pub const VK_WHOLE_SIZE: ::std::os::raw::c_int = -1;
pub const VK_ATTACHMENT_UNUSED: ::std::os::raw::c_int = -1;
pub const VK_TRUE: ::std::os::raw::c_uint = 1;
pub const VK_FALSE: ::std::os::raw::c_uint = 0;
pub const VK_QUEUE_FAMILY_IGNORED: ::std::os::raw::c_int = -1;
pub const VK_SUBPASS_EXTERNAL: ::std::os::raw::c_int = -1;
pub const VK_MAX_PHYSICAL_DEVICE_NAME_SIZE: ::std::os::raw::c_uint = 256;
pub const VK_UUID_SIZE: ::std::os::raw::c_uint = 16;
pub const VK_MAX_MEMORY_TYPES: ::std::os::raw::c_uint = 32;
pub const VK_MAX_MEMORY_HEAPS: ::std::os::raw::c_uint = 16;
pub const VK_MAX_EXTENSION_NAME_SIZE: ::std::os::raw::c_uint = 256;
pub const VK_MAX_DESCRIPTION_SIZE: ::std::os::raw::c_uint = 256;
pub const VK_KHR_surface: ::std::os::raw::c_uint = 1;
pub const VK_KHR_SURFACE_SPEC_VERSION: ::std::os::raw::c_uint = 25;
pub const VK_KHR_SURFACE_EXTENSION_NAME: &'static [u8; 15usize] =
    b"VK_KHR_surface\x00";
pub const VK_KHR_swapchain: ::std::os::raw::c_uint = 1;
pub const VK_KHR_SWAPCHAIN_SPEC_VERSION: ::std::os::raw::c_uint = 68;
pub const VK_KHR_SWAPCHAIN_EXTENSION_NAME: &'static [u8; 17usize] =
    b"VK_KHR_swapchain\x00";
pub const VK_KHR_display: ::std::os::raw::c_uint = 1;
pub const VK_KHR_DISPLAY_SPEC_VERSION: ::std::os::raw::c_uint = 21;
pub const VK_KHR_DISPLAY_EXTENSION_NAME: &'static [u8; 15usize] =
    b"VK_KHR_display\x00";
pub const VK_KHR_display_swapchain: ::std::os::raw::c_uint = 1;
pub const VK_KHR_DISPLAY_SWAPCHAIN_SPEC_VERSION: ::std::os::raw::c_uint = 9;
pub const VK_KHR_DISPLAY_SWAPCHAIN_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_display_swapchain\x00";
pub const VK_KHR_sampler_mirror_clamp_to_edge: ::std::os::raw::c_uint = 1;
pub const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_SAMPLER_MIRROR_CLAMP_TO_EDGE_EXTENSION_NAME:
          &'static [u8; 36usize] =
    b"VK_KHR_sampler_mirror_clamp_to_edge\x00";
pub const VK_KHR_get_physical_device_properties2: ::std::os::raw::c_uint = 1;
pub const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_GET_PHYSICAL_DEVICE_PROPERTIES_2_EXTENSION_NAME:
          &'static [u8; 39usize] =
    b"VK_KHR_get_physical_device_properties2\x00";
pub const VK_KHR_shader_draw_parameters: ::std::os::raw::c_uint = 1;
pub const VK_KHR_SHADER_DRAW_PARAMETERS_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_KHR_SHADER_DRAW_PARAMETERS_EXTENSION_NAME: &'static [u8; 30usize]
          =
    b"VK_KHR_shader_draw_parameters\x00";
pub const VK_KHR_maintenance1: ::std::os::raw::c_uint = 1;
pub const VK_KHR_MAINTENANCE1_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_MAINTENANCE1_EXTENSION_NAME: &'static [u8; 20usize] =
    b"VK_KHR_maintenance1\x00";
pub const VK_KHR_external_memory_capabilities: ::std::os::raw::c_uint = 1;
pub const VK_LUID_SIZE_KHR: ::std::os::raw::c_uint = 8;
pub const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME:
          &'static [u8; 36usize] =
    b"VK_KHR_external_memory_capabilities\x00";
pub const VK_KHR_external_memory: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_MEMORY_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_MEMORY_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_KHR_external_memory\x00";
pub const VK_QUEUE_FAMILY_EXTERNAL_KHR: ::std::os::raw::c_int = -2;
pub const VK_KHR_external_memory_fd: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_MEMORY_FD_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_MEMORY_FD_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_KHR_external_memory_fd\x00";
pub const VK_KHR_external_semaphore_capabilities: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_CAPABILITIES_EXTENSION_NAME:
          &'static [u8; 39usize] =
    b"VK_KHR_external_semaphore_capabilities\x00";
pub const VK_KHR_external_semaphore: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_KHR_external_semaphore\x00";
pub const VK_KHR_external_semaphore_fd: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_FD_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_KHR_EXTERNAL_SEMAPHORE_FD_EXTENSION_NAME: &'static [u8; 29usize]
          =
    b"VK_KHR_external_semaphore_fd\x00";
pub const VK_KHR_push_descriptor: ::std::os::raw::c_uint = 1;
pub const VK_KHR_PUSH_DESCRIPTOR_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_PUSH_DESCRIPTOR_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_KHR_push_descriptor\x00";
pub const VK_KHR_16bit_storage: ::std::os::raw::c_uint = 1;
pub const VK_KHR_16BIT_STORAGE_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_16BIT_STORAGE_EXTENSION_NAME: &'static [u8; 21usize] =
    b"VK_KHR_16bit_storage\x00";
pub const VK_KHR_incremental_present: ::std::os::raw::c_uint = 1;
pub const VK_KHR_INCREMENTAL_PRESENT_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_INCREMENTAL_PRESENT_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_KHR_incremental_present\x00";
pub const VK_KHR_descriptor_update_template: ::std::os::raw::c_uint = 1;
pub const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_DESCRIPTOR_UPDATE_TEMPLATE_EXTENSION_NAME:
          &'static [u8; 34usize] =
    b"VK_KHR_descriptor_update_template\x00";
pub const VK_KHR_shared_presentable_image: ::std::os::raw::c_uint = 1;
pub const VK_KHR_SHARED_PRESENTABLE_IMAGE_SPEC_VERSION: ::std::os::raw::c_uint
          =
    1;
pub const VK_KHR_SHARED_PRESENTABLE_IMAGE_EXTENSION_NAME:
          &'static [u8; 32usize] =
    b"VK_KHR_shared_presentable_image\x00";
pub const VK_KHR_external_fence_capabilities: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_EXTERNAL_FENCE_CAPABILITIES_EXTENSION_NAME:
          &'static [u8; 35usize] =
    b"VK_KHR_external_fence_capabilities\x00";
pub const VK_KHR_external_fence: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_FENCE_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_FENCE_EXTENSION_NAME: &'static [u8; 22usize] =
    b"VK_KHR_external_fence\x00";
pub const VK_KHR_external_fence_fd: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_FENCE_FD_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_EXTERNAL_FENCE_FD_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_external_fence_fd\x00";
pub const VK_KHR_get_surface_capabilities2: ::std::os::raw::c_uint = 1;
pub const VK_KHR_GET_SURFACE_CAPABILITIES_2_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_GET_SURFACE_CAPABILITIES_2_EXTENSION_NAME:
          &'static [u8; 33usize] =
    b"VK_KHR_get_surface_capabilities2\x00";
pub const VK_KHR_variable_pointers: ::std::os::raw::c_uint = 1;
pub const VK_KHR_VARIABLE_POINTERS_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHR_VARIABLE_POINTERS_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_KHR_variable_pointers\x00";
pub const VK_KHR_dedicated_allocation: ::std::os::raw::c_uint = 1;
pub const VK_KHR_DEDICATED_ALLOCATION_SPEC_VERSION: ::std::os::raw::c_uint =
    3;
pub const VK_KHR_DEDICATED_ALLOCATION_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_KHR_dedicated_allocation\x00";
pub const VK_KHR_storage_buffer_storage_class: ::std::os::raw::c_uint = 1;
pub const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_STORAGE_BUFFER_STORAGE_CLASS_EXTENSION_NAME:
          &'static [u8; 36usize] =
    b"VK_KHR_storage_buffer_storage_class\x00";
pub const VK_KHR_relaxed_block_layout: ::std::os::raw::c_uint = 1;
pub const VK_KHR_RELAXED_BLOCK_LAYOUT_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_KHR_RELAXED_BLOCK_LAYOUT_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_KHR_relaxed_block_layout\x00";
pub const VK_KHR_get_memory_requirements2: ::std::os::raw::c_uint = 1;
pub const VK_KHR_GET_MEMORY_REQUIREMENTS_2_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_KHR_GET_MEMORY_REQUIREMENTS_2_EXTENSION_NAME:
          &'static [u8; 32usize] =
    b"VK_KHR_get_memory_requirements2\x00";
pub const VK_EXT_debug_report: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DEBUG_REPORT_SPEC_VERSION: ::std::os::raw::c_uint = 8;
pub const VK_EXT_DEBUG_REPORT_EXTENSION_NAME: &'static [u8; 20usize] =
    b"VK_EXT_debug_report\x00";
pub const VK_NV_glsl_shader: ::std::os::raw::c_uint = 1;
pub const VK_NV_GLSL_SHADER_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_NV_GLSL_SHADER_EXTENSION_NAME: &'static [u8; 18usize] =
    b"VK_NV_glsl_shader\x00";
pub const VK_EXT_depth_range_unrestricted: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DEPTH_RANGE_UNRESTRICTED_SPEC_VERSION: ::std::os::raw::c_uint
          =
    1;
pub const VK_EXT_DEPTH_RANGE_UNRESTRICTED_EXTENSION_NAME:
          &'static [u8; 32usize] =
    b"VK_EXT_depth_range_unrestricted\x00";
pub const VK_IMG_filter_cubic: ::std::os::raw::c_uint = 1;
pub const VK_IMG_FILTER_CUBIC_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_IMG_FILTER_CUBIC_EXTENSION_NAME: &'static [u8; 20usize] =
    b"VK_IMG_filter_cubic\x00";
pub const VK_AMD_rasterization_order: ::std::os::raw::c_uint = 1;
pub const VK_AMD_RASTERIZATION_ORDER_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_AMD_RASTERIZATION_ORDER_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_AMD_rasterization_order\x00";
pub const VK_AMD_shader_trinary_minmax: ::std::os::raw::c_uint = 1;
pub const VK_AMD_SHADER_TRINARY_MINMAX_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_AMD_SHADER_TRINARY_MINMAX_EXTENSION_NAME: &'static [u8; 29usize]
          =
    b"VK_AMD_shader_trinary_minmax\x00";
pub const VK_AMD_shader_explicit_vertex_parameter: ::std::os::raw::c_uint = 1;
pub const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_AMD_SHADER_EXPLICIT_VERTEX_PARAMETER_EXTENSION_NAME:
          &'static [u8; 40usize] =
    b"VK_AMD_shader_explicit_vertex_parameter\x00";
pub const VK_EXT_debug_marker: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DEBUG_MARKER_SPEC_VERSION: ::std::os::raw::c_uint = 4;
pub const VK_EXT_DEBUG_MARKER_EXTENSION_NAME: &'static [u8; 20usize] =
    b"VK_EXT_debug_marker\x00";
pub const VK_AMD_gcn_shader: ::std::os::raw::c_uint = 1;
pub const VK_AMD_GCN_SHADER_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_AMD_GCN_SHADER_EXTENSION_NAME: &'static [u8; 18usize] =
    b"VK_AMD_gcn_shader\x00";
pub const VK_NV_dedicated_allocation: ::std::os::raw::c_uint = 1;
pub const VK_NV_DEDICATED_ALLOCATION_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_NV_DEDICATED_ALLOCATION_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_NV_dedicated_allocation\x00";
pub const VK_AMD_draw_indirect_count: ::std::os::raw::c_uint = 1;
pub const VK_AMD_DRAW_INDIRECT_COUNT_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_AMD_DRAW_INDIRECT_COUNT_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_AMD_draw_indirect_count\x00";
pub const VK_AMD_negative_viewport_height: ::std::os::raw::c_uint = 1;
pub const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_SPEC_VERSION: ::std::os::raw::c_uint
          =
    1;
pub const VK_AMD_NEGATIVE_VIEWPORT_HEIGHT_EXTENSION_NAME:
          &'static [u8; 32usize] =
    b"VK_AMD_negative_viewport_height\x00";
pub const VK_AMD_gpu_shader_half_float: ::std::os::raw::c_uint = 1;
pub const VK_AMD_GPU_SHADER_HALF_FLOAT_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_AMD_GPU_SHADER_HALF_FLOAT_EXTENSION_NAME: &'static [u8; 29usize]
          =
    b"VK_AMD_gpu_shader_half_float\x00";
pub const VK_AMD_shader_ballot: ::std::os::raw::c_uint = 1;
pub const VK_AMD_SHADER_BALLOT_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_AMD_SHADER_BALLOT_EXTENSION_NAME: &'static [u8; 21usize] =
    b"VK_AMD_shader_ballot\x00";
pub const VK_AMD_texture_gather_bias_lod: ::std::os::raw::c_uint = 1;
pub const VK_AMD_TEXTURE_GATHER_BIAS_LOD_SPEC_VERSION: ::std::os::raw::c_uint
          =
    1;
pub const VK_AMD_TEXTURE_GATHER_BIAS_LOD_EXTENSION_NAME:
          &'static [u8; 31usize] =
    b"VK_AMD_texture_gather_bias_lod\x00";
pub const VK_KHX_multiview: ::std::os::raw::c_uint = 1;
pub const VK_KHX_MULTIVIEW_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHX_MULTIVIEW_EXTENSION_NAME: &'static [u8; 17usize] =
    b"VK_KHX_multiview\x00";
pub const VK_IMG_format_pvrtc: ::std::os::raw::c_uint = 1;
pub const VK_IMG_FORMAT_PVRTC_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_IMG_FORMAT_PVRTC_EXTENSION_NAME: &'static [u8; 20usize] =
    b"VK_IMG_format_pvrtc\x00";
pub const VK_NV_external_memory_capabilities: ::std::os::raw::c_uint = 1;
pub const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_NV_EXTERNAL_MEMORY_CAPABILITIES_EXTENSION_NAME:
          &'static [u8; 35usize] =
    b"VK_NV_external_memory_capabilities\x00";
pub const VK_NV_external_memory: ::std::os::raw::c_uint = 1;
pub const VK_NV_EXTERNAL_MEMORY_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_NV_EXTERNAL_MEMORY_EXTENSION_NAME: &'static [u8; 22usize] =
    b"VK_NV_external_memory\x00";
pub const VK_KHX_device_group: ::std::os::raw::c_uint = 1;
pub const VK_MAX_DEVICE_GROUP_SIZE_KHX: ::std::os::raw::c_uint = 32;
pub const VK_KHX_DEVICE_GROUP_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_KHX_DEVICE_GROUP_EXTENSION_NAME: &'static [u8; 20usize] =
    b"VK_KHX_device_group\x00";
pub const VK_EXT_validation_flags: ::std::os::raw::c_uint = 1;
pub const VK_EXT_VALIDATION_FLAGS_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_EXT_VALIDATION_FLAGS_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_EXT_validation_flags\x00";
pub const VK_EXT_shader_subgroup_ballot: ::std::os::raw::c_uint = 1;
pub const VK_EXT_SHADER_SUBGROUP_BALLOT_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_EXT_SHADER_SUBGROUP_BALLOT_EXTENSION_NAME: &'static [u8; 30usize]
          =
    b"VK_EXT_shader_subgroup_ballot\x00";
pub const VK_EXT_shader_subgroup_vote: ::std::os::raw::c_uint = 1;
pub const VK_EXT_SHADER_SUBGROUP_VOTE_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_EXT_SHADER_SUBGROUP_VOTE_EXTENSION_NAME: &'static [u8; 28usize] =
    b"VK_EXT_shader_subgroup_vote\x00";
pub const VK_KHX_device_group_creation: ::std::os::raw::c_uint = 1;
pub const VK_KHX_DEVICE_GROUP_CREATION_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_KHX_DEVICE_GROUP_CREATION_EXTENSION_NAME: &'static [u8; 29usize]
          =
    b"VK_KHX_device_group_creation\x00";
pub const VK_NVX_device_generated_commands: ::std::os::raw::c_uint = 1;
pub const VK_NVX_DEVICE_GENERATED_COMMANDS_SPEC_VERSION:
          ::std::os::raw::c_uint =
    3;
pub const VK_NVX_DEVICE_GENERATED_COMMANDS_EXTENSION_NAME:
          &'static [u8; 33usize] =
    b"VK_NVX_device_generated_commands\x00";
pub const VK_NV_clip_space_w_scaling: ::std::os::raw::c_uint = 1;
pub const VK_NV_CLIP_SPACE_W_SCALING_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_NV_CLIP_SPACE_W_SCALING_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_NV_clip_space_w_scaling\x00";
pub const VK_EXT_direct_mode_display: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DIRECT_MODE_DISPLAY_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DIRECT_MODE_DISPLAY_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_EXT_direct_mode_display\x00";
pub const VK_EXT_display_surface_counter: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DISPLAY_SURFACE_COUNTER_SPEC_VERSION: ::std::os::raw::c_uint
          =
    1;
pub const VK_EXT_DISPLAY_SURFACE_COUNTER_EXTENSION_NAME:
          &'static [u8; 31usize] =
    b"VK_EXT_display_surface_counter\x00";
pub const VK_EXT_display_control: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DISPLAY_CONTROL_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DISPLAY_CONTROL_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_EXT_display_control\x00";
pub const VK_GOOGLE_display_timing: ::std::os::raw::c_uint = 1;
pub const VK_GOOGLE_DISPLAY_TIMING_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_GOOGLE_DISPLAY_TIMING_EXTENSION_NAME: &'static [u8; 25usize] =
    b"VK_GOOGLE_display_timing\x00";
pub const VK_NV_sample_mask_override_coverage: ::std::os::raw::c_uint = 1;
pub const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_NV_SAMPLE_MASK_OVERRIDE_COVERAGE_EXTENSION_NAME:
          &'static [u8; 36usize] =
    b"VK_NV_sample_mask_override_coverage\x00";
pub const VK_NV_geometry_shader_passthrough: ::std::os::raw::c_uint = 1;
pub const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_NV_GEOMETRY_SHADER_PASSTHROUGH_EXTENSION_NAME:
          &'static [u8; 34usize] =
    b"VK_NV_geometry_shader_passthrough\x00";
pub const VK_NV_viewport_array2: ::std::os::raw::c_uint = 1;
pub const VK_NV_VIEWPORT_ARRAY2_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_NV_VIEWPORT_ARRAY2_EXTENSION_NAME: &'static [u8; 22usize] =
    b"VK_NV_viewport_array2\x00";
pub const VK_NVX_multiview_per_view_attributes: ::std::os::raw::c_uint = 1;
pub const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_NVX_MULTIVIEW_PER_VIEW_ATTRIBUTES_EXTENSION_NAME:
          &'static [u8; 37usize] =
    b"VK_NVX_multiview_per_view_attributes\x00";
pub const VK_NV_viewport_swizzle: ::std::os::raw::c_uint = 1;
pub const VK_NV_VIEWPORT_SWIZZLE_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_NV_VIEWPORT_SWIZZLE_EXTENSION_NAME: &'static [u8; 23usize] =
    b"VK_NV_viewport_swizzle\x00";
pub const VK_EXT_discard_rectangles: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DISCARD_RECTANGLES_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_EXT_DISCARD_RECTANGLES_EXTENSION_NAME: &'static [u8; 26usize] =
    b"VK_EXT_discard_rectangles\x00";
pub const VK_EXT_swapchain_colorspace: ::std::os::raw::c_uint = 1;
pub const VK_EXT_SWAPCHAIN_COLOR_SPACE_SPEC_VERSION: ::std::os::raw::c_uint =
    3;
pub const VK_EXT_SWAPCHAIN_COLOR_SPACE_EXTENSION_NAME: &'static [u8; 28usize]
          =
    b"VK_EXT_swapchain_colorspace\x00";
pub const VK_EXT_hdr_metadata: ::std::os::raw::c_uint = 1;
pub const VK_EXT_HDR_METADATA_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_EXT_HDR_METADATA_EXTENSION_NAME: &'static [u8; 20usize] =
    b"VK_EXT_hdr_metadata\x00";
pub const VK_EXT_sampler_filter_minmax: ::std::os::raw::c_uint = 1;
pub const VK_EXT_SAMPLER_FILTER_MINMAX_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_EXT_SAMPLER_FILTER_MINMAX_EXTENSION_NAME: &'static [u8; 29usize]
          =
    b"VK_EXT_sampler_filter_minmax\x00";
pub const VK_AMD_gpu_shader_int16: ::std::os::raw::c_uint = 1;
pub const VK_AMD_GPU_SHADER_INT16_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_AMD_GPU_SHADER_INT16_EXTENSION_NAME: &'static [u8; 24usize] =
    b"VK_AMD_gpu_shader_int16\x00";
pub const VK_AMD_mixed_attachment_samples: ::std::os::raw::c_uint = 1;
pub const VK_AMD_MIXED_ATTACHMENT_SAMPLES_SPEC_VERSION: ::std::os::raw::c_uint
          =
    1;
pub const VK_AMD_MIXED_ATTACHMENT_SAMPLES_EXTENSION_NAME:
          &'static [u8; 32usize] =
    b"VK_AMD_mixed_attachment_samples\x00";
pub const VK_EXT_shader_stencil_export: ::std::os::raw::c_uint = 1;
pub const VK_EXT_SHADER_STENCIL_EXPORT_SPEC_VERSION: ::std::os::raw::c_uint =
    1;
pub const VK_EXT_SHADER_STENCIL_EXPORT_EXTENSION_NAME: &'static [u8; 29usize]
          =
    b"VK_EXT_shader_stencil_export\x00";
pub const VK_EXT_blend_operation_advanced: ::std::os::raw::c_uint = 1;
pub const VK_EXT_BLEND_OPERATION_ADVANCED_SPEC_VERSION: ::std::os::raw::c_uint
          =
    2;
pub const VK_EXT_BLEND_OPERATION_ADVANCED_EXTENSION_NAME:
          &'static [u8; 32usize] =
    b"VK_EXT_blend_operation_advanced\x00";
pub const VK_NV_fragment_coverage_to_color: ::std::os::raw::c_uint = 1;
pub const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_NV_FRAGMENT_COVERAGE_TO_COLOR_EXTENSION_NAME:
          &'static [u8; 33usize] =
    b"VK_NV_fragment_coverage_to_color\x00";
pub const VK_NV_framebuffer_mixed_samples: ::std::os::raw::c_uint = 1;
pub const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_SPEC_VERSION: ::std::os::raw::c_uint
          =
    1;
pub const VK_NV_FRAMEBUFFER_MIXED_SAMPLES_EXTENSION_NAME:
          &'static [u8; 32usize] =
    b"VK_NV_framebuffer_mixed_samples\x00";
pub const VK_NV_fill_rectangle: ::std::os::raw::c_uint = 1;
pub const VK_NV_FILL_RECTANGLE_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_NV_FILL_RECTANGLE_EXTENSION_NAME: &'static [u8; 21usize] =
    b"VK_NV_fill_rectangle\x00";
pub const VK_EXT_post_depth_coverage: ::std::os::raw::c_uint = 1;
pub const VK_EXT_POST_DEPTH_COVERAGE_SPEC_VERSION: ::std::os::raw::c_uint = 1;
pub const VK_EXT_POST_DEPTH_COVERAGE_EXTENSION_NAME: &'static [u8; 27usize] =
    b"VK_EXT_post_depth_coverage\x00";
pub const VK_EXT_shader_viewport_index_layer: ::std::os::raw::c_uint = 1;
pub const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_SPEC_VERSION:
          ::std::os::raw::c_uint =
    1;
pub const VK_EXT_SHADER_VIEWPORT_INDEX_LAYER_EXTENSION_NAME:
          &'static [u8; 35usize] =
    b"VK_EXT_shader_viewport_index_layer\x00";
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(::std::mem::size_of::<max_align_t>() , 32usize , concat ! (
               "Size of: " , stringify ! ( max_align_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce1 as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce1 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const max_align_t ) ) .
                __clang_max_align_nonce2 as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( max_align_t ) , "::" ,
                stringify ! ( __clang_max_align_nonce2 ) ));
}
impl Clone for max_align_t {
    fn clone(&self) -> Self { *self }
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(::std::mem::size_of::<__fsid_t>() , 8usize , concat ! (
               "Size of: " , stringify ! ( __fsid_t ) ));
    assert_eq! (::std::mem::align_of::<__fsid_t>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( __fsid_t ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const __fsid_t ) ) . __val as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( __fsid_t ) , "::" ,
                stringify ! ( __val ) ));
}
impl Clone for __fsid_t {
    fn clone(&self) -> Self { *self }
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_long;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type VkFlags = u32;
pub type VkBool32 = u32;
pub type VkDeviceSize = u64;
pub type VkSampleMask = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkInstance_T {
    _unused: [u8; 0],
}
pub type VkInstance = *mut VkInstance_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPhysicalDevice_T {
    _unused: [u8; 0],
}
pub type VkPhysicalDevice = *mut VkPhysicalDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDevice_T {
    _unused: [u8; 0],
}
pub type VkDevice = *mut VkDevice_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueue_T {
    _unused: [u8; 0],
}
pub type VkQueue = *mut VkQueue_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSemaphore_T {
    _unused: [u8; 0],
}
pub type VkSemaphore = *mut VkSemaphore_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandBuffer_T {
    _unused: [u8; 0],
}
pub type VkCommandBuffer = *mut VkCommandBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFence_T {
    _unused: [u8; 0],
}
pub type VkFence = *mut VkFence_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDeviceMemory_T {
    _unused: [u8; 0],
}
pub type VkDeviceMemory = *mut VkDeviceMemory_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBuffer_T {
    _unused: [u8; 0],
}
pub type VkBuffer = *mut VkBuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImage_T {
    _unused: [u8; 0],
}
pub type VkImage = *mut VkImage_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkEvent_T {
    _unused: [u8; 0],
}
pub type VkEvent = *mut VkEvent_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkQueryPool_T {
    _unused: [u8; 0],
}
pub type VkQueryPool = *mut VkQueryPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkBufferView_T {
    _unused: [u8; 0],
}
pub type VkBufferView = *mut VkBufferView_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkImageView_T {
    _unused: [u8; 0],
}
pub type VkImageView = *mut VkImageView_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkShaderModule_T {
    _unused: [u8; 0],
}
pub type VkShaderModule = *mut VkShaderModule_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineCache_T {
    _unused: [u8; 0],
}
pub type VkPipelineCache = *mut VkPipelineCache_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipelineLayout_T {
    _unused: [u8; 0],
}
pub type VkPipelineLayout = *mut VkPipelineLayout_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkRenderPass_T {
    _unused: [u8; 0],
}
pub type VkRenderPass = *mut VkRenderPass_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkPipeline_T {
    _unused: [u8; 0],
}
pub type VkPipeline = *mut VkPipeline_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSetLayout_T {
    _unused: [u8; 0],
}
pub type VkDescriptorSetLayout = *mut VkDescriptorSetLayout_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSampler_T {
    _unused: [u8; 0],
}
pub type VkSampler = *mut VkSampler_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorPool_T {
    _unused: [u8; 0],
}
pub type VkDescriptorPool = *mut VkDescriptorPool_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorSet_T {
    _unused: [u8; 0],
}
pub type VkDescriptorSet = *mut VkDescriptorSet_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkFramebuffer_T {
    _unused: [u8; 0],
}
pub type VkFramebuffer = *mut VkFramebuffer_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkCommandPool_T {
    _unused: [u8; 0],
}
pub type VkCommandPool = *mut VkCommandPool_T;
pub const VkPipelineCacheHeaderVersion_VK_PIPELINE_CACHE_HEADER_VERSION_BEGIN_RANGE:
          VkPipelineCacheHeaderVersion =
    VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
pub const VkPipelineCacheHeaderVersion_VK_PIPELINE_CACHE_HEADER_VERSION_END_RANGE:
          VkPipelineCacheHeaderVersion =
    VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
pub const VkPipelineCacheHeaderVersion_VK_PIPELINE_CACHE_HEADER_VERSION_RANGE_SIZE:
          VkPipelineCacheHeaderVersion =
    VkPipelineCacheHeaderVersion::VK_PIPELINE_CACHE_HEADER_VERSION_ONE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPipelineCacheHeaderVersion {
    VK_PIPELINE_CACHE_HEADER_VERSION_ONE = 1,
    VK_PIPELINE_CACHE_HEADER_VERSION_MAX_ENUM = 2147483647,
}
pub const VkResult_VK_RESULT_BEGIN_RANGE: VkResult =
    VkResult::VK_ERROR_FRAGMENTED_POOL;
pub const VkResult_VK_RESULT_END_RANGE: VkResult = VkResult::VK_INCOMPLETE;
#[repr(i32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkResult {
    VK_SUCCESS = 0,
    VK_NOT_READY = 1,
    VK_TIMEOUT = 2,
    VK_EVENT_SET = 3,
    VK_EVENT_RESET = 4,
    VK_INCOMPLETE = 5,
    VK_ERROR_OUT_OF_HOST_MEMORY = -1,
    VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
    VK_ERROR_INITIALIZATION_FAILED = -3,
    VK_ERROR_DEVICE_LOST = -4,
    VK_ERROR_MEMORY_MAP_FAILED = -5,
    VK_ERROR_LAYER_NOT_PRESENT = -6,
    VK_ERROR_EXTENSION_NOT_PRESENT = -7,
    VK_ERROR_FEATURE_NOT_PRESENT = -8,
    VK_ERROR_INCOMPATIBLE_DRIVER = -9,
    VK_ERROR_TOO_MANY_OBJECTS = -10,
    VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
    VK_ERROR_FRAGMENTED_POOL = -12,
    VK_ERROR_SURFACE_LOST_KHR = -1000000000,
    VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
    VK_SUBOPTIMAL_KHR = 1000001003,
    VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
    VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
    VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
    VK_ERROR_INVALID_SHADER_NV = -1000012000,
    VK_ERROR_OUT_OF_POOL_MEMORY_KHR = -1000069000,
    VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = -1000072003,
    VK_RESULT_RANGE_SIZE = 18,
    VK_RESULT_MAX_ENUM = 2147483647,
}
pub const VkStructureType_VK_STRUCTURE_TYPE_BEGIN_RANGE: VkStructureType =
    VkStructureType::VK_STRUCTURE_TYPE_APPLICATION_INFO;
pub const VkStructureType_VK_STRUCTURE_TYPE_END_RANGE: VkStructureType =
    VkStructureType::VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkStructureType {
    VK_STRUCTURE_TYPE_APPLICATION_INFO = 0,
    VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO = 1,
    VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO = 2,
    VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO = 3,
    VK_STRUCTURE_TYPE_SUBMIT_INFO = 4,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO = 5,
    VK_STRUCTURE_TYPE_MAPPED_MEMORY_RANGE = 6,
    VK_STRUCTURE_TYPE_BIND_SPARSE_INFO = 7,
    VK_STRUCTURE_TYPE_FENCE_CREATE_INFO = 8,
    VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO = 9,
    VK_STRUCTURE_TYPE_EVENT_CREATE_INFO = 10,
    VK_STRUCTURE_TYPE_QUERY_POOL_CREATE_INFO = 11,
    VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO = 12,
    VK_STRUCTURE_TYPE_BUFFER_VIEW_CREATE_INFO = 13,
    VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO = 14,
    VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO = 15,
    VK_STRUCTURE_TYPE_SHADER_MODULE_CREATE_INFO = 16,
    VK_STRUCTURE_TYPE_PIPELINE_CACHE_CREATE_INFO = 17,
    VK_STRUCTURE_TYPE_PIPELINE_SHADER_STAGE_CREATE_INFO = 18,
    VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO = 19,
    VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO = 20,
    VK_STRUCTURE_TYPE_PIPELINE_TESSELLATION_STATE_CREATE_INFO = 21,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO = 22,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO = 23,
    VK_STRUCTURE_TYPE_PIPELINE_MULTISAMPLE_STATE_CREATE_INFO = 24,
    VK_STRUCTURE_TYPE_PIPELINE_DEPTH_STENCIL_STATE_CREATE_INFO = 25,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_STATE_CREATE_INFO = 26,
    VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO = 27,
    VK_STRUCTURE_TYPE_GRAPHICS_PIPELINE_CREATE_INFO = 28,
    VK_STRUCTURE_TYPE_COMPUTE_PIPELINE_CREATE_INFO = 29,
    VK_STRUCTURE_TYPE_PIPELINE_LAYOUT_CREATE_INFO = 30,
    VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO = 31,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_LAYOUT_CREATE_INFO = 32,
    VK_STRUCTURE_TYPE_DESCRIPTOR_POOL_CREATE_INFO = 33,
    VK_STRUCTURE_TYPE_DESCRIPTOR_SET_ALLOCATE_INFO = 34,
    VK_STRUCTURE_TYPE_WRITE_DESCRIPTOR_SET = 35,
    VK_STRUCTURE_TYPE_COPY_DESCRIPTOR_SET = 36,
    VK_STRUCTURE_TYPE_FRAMEBUFFER_CREATE_INFO = 37,
    VK_STRUCTURE_TYPE_RENDER_PASS_CREATE_INFO = 38,
    VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO = 39,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO = 40,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_INHERITANCE_INFO = 41,
    VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO = 42,
    VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO = 43,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_BARRIER = 44,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER = 45,
    VK_STRUCTURE_TYPE_MEMORY_BARRIER = 46,
    VK_STRUCTURE_TYPE_LOADER_INSTANCE_CREATE_INFO = 47,
    VK_STRUCTURE_TYPE_LOADER_DEVICE_CREATE_INFO = 48,
    VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR = 1000001000,
    VK_STRUCTURE_TYPE_PRESENT_INFO_KHR = 1000001001,
    VK_STRUCTURE_TYPE_DISPLAY_MODE_CREATE_INFO_KHR = 1000002000,
    VK_STRUCTURE_TYPE_DISPLAY_SURFACE_CREATE_INFO_KHR = 1000002001,
    VK_STRUCTURE_TYPE_DISPLAY_PRESENT_INFO_KHR = 1000003000,
    VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR = 1000004000,
    VK_STRUCTURE_TYPE_XCB_SURFACE_CREATE_INFO_KHR = 1000005000,
    VK_STRUCTURE_TYPE_WAYLAND_SURFACE_CREATE_INFO_KHR = 1000006000,
    VK_STRUCTURE_TYPE_MIR_SURFACE_CREATE_INFO_KHR = 1000007000,
    VK_STRUCTURE_TYPE_ANDROID_SURFACE_CREATE_INFO_KHR = 1000008000,
    VK_STRUCTURE_TYPE_WIN32_SURFACE_CREATE_INFO_KHR = 1000009000,
    VK_STRUCTURE_TYPE_DEBUG_REPORT_CALLBACK_CREATE_INFO_EXT = 1000011000,
    VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_RASTERIZATION_ORDER_AMD =
        1000018000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_NAME_INFO_EXT = 1000022000,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_OBJECT_TAG_INFO_EXT = 1000022001,
    VK_STRUCTURE_TYPE_DEBUG_MARKER_MARKER_INFO_EXT = 1000022002,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_IMAGE_CREATE_INFO_NV = 1000026000,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_BUFFER_CREATE_INFO_NV = 1000026001,
    VK_STRUCTURE_TYPE_DEDICATED_ALLOCATION_MEMORY_ALLOCATE_INFO_NV =
        1000026002,
    VK_STRUCTURE_TYPE_TEXTURE_LOD_GATHER_FORMAT_PROPERTIES_AMD = 1000041000,
    VK_STRUCTURE_TYPE_RENDER_PASS_MULTIVIEW_CREATE_INFO_KHX = 1000053000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES_KHX = 1000053001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PROPERTIES_KHX = 1000053002,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_NV = 1000056000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_NV = 1000056001,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_NV = 1000057001,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_NV = 1000058000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2_KHR = 1000059000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROPERTIES_2_KHR = 1000059001,
    VK_STRUCTURE_TYPE_FORMAT_PROPERTIES_2_KHR = 1000059002,
    VK_STRUCTURE_TYPE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_FORMAT_INFO_2_KHR = 1000059004,
    VK_STRUCTURE_TYPE_QUEUE_FAMILY_PROPERTIES_2_KHR = 1000059005,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MEMORY_PROPERTIES_2_KHR = 1000059006,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_FORMAT_PROPERTIES_2_KHR = 1000059007,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SPARSE_IMAGE_FORMAT_INFO_2_KHR =
        1000059008,
    VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_FLAGS_INFO_KHX = 1000060000,
    VK_STRUCTURE_TYPE_BIND_BUFFER_MEMORY_INFO_KHX = 1000060001,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_INFO_KHX = 1000060002,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_RENDER_PASS_BEGIN_INFO_KHX = 1000060003,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_COMMAND_BUFFER_BEGIN_INFO_KHX = 1000060004,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SUBMIT_INFO_KHX = 1000060005,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_BIND_SPARSE_INFO_KHX = 1000060006,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_CAPABILITIES_KHX = 1000060007,
    VK_STRUCTURE_TYPE_IMAGE_SWAPCHAIN_CREATE_INFO_KHX = 1000060008,
    VK_STRUCTURE_TYPE_BIND_IMAGE_MEMORY_SWAPCHAIN_INFO_KHX = 1000060009,
    VK_STRUCTURE_TYPE_ACQUIRE_NEXT_IMAGE_INFO_KHX = 1000060010,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_PRESENT_INFO_KHX = 1000060011,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_SWAPCHAIN_CREATE_INFO_KHX = 1000060012,
    VK_STRUCTURE_TYPE_VALIDATION_FLAGS_EXT = 1000061000,
    VK_STRUCTURE_TYPE_VI_SURFACE_CREATE_INFO_NN = 1000062000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GROUP_PROPERTIES_KHX = 1000070000,
    VK_STRUCTURE_TYPE_DEVICE_GROUP_DEVICE_CREATE_INFO_KHX = 1000070001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_IMAGE_FORMAT_INFO_KHR =
        1000071000,
    VK_STRUCTURE_TYPE_EXTERNAL_IMAGE_FORMAT_PROPERTIES_KHR = 1000071001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_BUFFER_INFO_KHR = 1000071002,
    VK_STRUCTURE_TYPE_EXTERNAL_BUFFER_PROPERTIES_KHR = 1000071003,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ID_PROPERTIES_KHR = 1000071004,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_BUFFER_CREATE_INFO_KHR = 1000072000,
    VK_STRUCTURE_TYPE_EXTERNAL_MEMORY_IMAGE_CREATE_INFO_KHR = 1000072001,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_ALLOCATE_INFO_KHR = 1000072002,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073000,
    VK_STRUCTURE_TYPE_EXPORT_MEMORY_WIN32_HANDLE_INFO_KHR = 1000073001,
    VK_STRUCTURE_TYPE_MEMORY_WIN32_HANDLE_PROPERTIES_KHR = 1000073002,
    VK_STRUCTURE_TYPE_MEMORY_GET_WIN32_HANDLE_INFO_KHR = 1000073003,
    VK_STRUCTURE_TYPE_IMPORT_MEMORY_FD_INFO_KHR = 1000074000,
    VK_STRUCTURE_TYPE_MEMORY_FD_PROPERTIES_KHR = 1000074001,
    VK_STRUCTURE_TYPE_MEMORY_GET_FD_INFO_KHR = 1000074002,
    VK_STRUCTURE_TYPE_WIN32_KEYED_MUTEX_ACQUIRE_RELEASE_INFO_KHR = 1000075000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_SEMAPHORE_INFO_KHR =
        1000076000,
    VK_STRUCTURE_TYPE_EXTERNAL_SEMAPHORE_PROPERTIES_KHR = 1000076001,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_CREATE_INFO_KHR = 1000077000,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078000,
    VK_STRUCTURE_TYPE_EXPORT_SEMAPHORE_WIN32_HANDLE_INFO_KHR = 1000078001,
    VK_STRUCTURE_TYPE_D3D12_FENCE_SUBMIT_INFO_KHR = 1000078002,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_WIN32_HANDLE_INFO_KHR = 1000078003,
    VK_STRUCTURE_TYPE_IMPORT_SEMAPHORE_FD_INFO_KHR = 1000079000,
    VK_STRUCTURE_TYPE_SEMAPHORE_GET_FD_INFO_KHR = 1000079001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PUSH_DESCRIPTOR_PROPERTIES_KHR =
        1000080000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES_KHR = 1000083000,
    VK_STRUCTURE_TYPE_PRESENT_REGIONS_KHR = 1000084000,
    VK_STRUCTURE_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_CREATE_INFO_KHR = 1000085000,
    VK_STRUCTURE_TYPE_OBJECT_TABLE_CREATE_INFO_NVX = 1000086000,
    VK_STRUCTURE_TYPE_INDIRECT_COMMANDS_LAYOUT_CREATE_INFO_NVX = 1000086001,
    VK_STRUCTURE_TYPE_CMD_PROCESS_COMMANDS_INFO_NVX = 1000086002,
    VK_STRUCTURE_TYPE_CMD_RESERVE_SPACE_FOR_COMMANDS_INFO_NVX = 1000086003,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_LIMITS_NVX = 1000086004,
    VK_STRUCTURE_TYPE_DEVICE_GENERATED_COMMANDS_FEATURES_NVX = 1000086005,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_W_SCALING_STATE_CREATE_INFO_NV =
        1000087000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_EXT = 1000090000,
    VK_STRUCTURE_TYPE_DISPLAY_POWER_INFO_EXT = 1000091000,
    VK_STRUCTURE_TYPE_DEVICE_EVENT_INFO_EXT = 1000091001,
    VK_STRUCTURE_TYPE_DISPLAY_EVENT_INFO_EXT = 1000091002,
    VK_STRUCTURE_TYPE_SWAPCHAIN_COUNTER_CREATE_INFO_EXT = 1000091003,
    VK_STRUCTURE_TYPE_PRESENT_TIMES_INFO_GOOGLE = 1000092000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_PER_VIEW_ATTRIBUTES_PROPERTIES_NVX
        = 1000097000,
    VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_SWIZZLE_STATE_CREATE_INFO_NV =
        1000098000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DISCARD_RECTANGLE_PROPERTIES_EXT =
        1000099000,
    VK_STRUCTURE_TYPE_PIPELINE_DISCARD_RECTANGLE_STATE_CREATE_INFO_EXT =
        1000099001,
    VK_STRUCTURE_TYPE_HDR_METADATA_EXT = 1000105000,
    VK_STRUCTURE_TYPE_SHARED_PRESENT_SURFACE_CAPABILITIES_KHR = 1000111000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTERNAL_FENCE_INFO_KHR = 1000112000,
    VK_STRUCTURE_TYPE_EXTERNAL_FENCE_PROPERTIES_KHR = 1000112001,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_CREATE_INFO_KHR = 1000113000,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114000,
    VK_STRUCTURE_TYPE_EXPORT_FENCE_WIN32_HANDLE_INFO_KHR = 1000114001,
    VK_STRUCTURE_TYPE_FENCE_GET_WIN32_HANDLE_INFO_KHR = 1000114002,
    VK_STRUCTURE_TYPE_IMPORT_FENCE_FD_INFO_KHR = 1000115000,
    VK_STRUCTURE_TYPE_FENCE_GET_FD_INFO_KHR = 1000115001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SURFACE_INFO_2_KHR = 1000119000,
    VK_STRUCTURE_TYPE_SURFACE_CAPABILITIES_2_KHR = 1000119001,
    VK_STRUCTURE_TYPE_SURFACE_FORMAT_2_KHR = 1000119002,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTER_FEATURES_KHR =
        1000120000,
    VK_STRUCTURE_TYPE_IOS_SURFACE_CREATE_INFO_MVK = 1000122000,
    VK_STRUCTURE_TYPE_MACOS_SURFACE_CREATE_INFO_MVK = 1000123000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_REQUIREMENTS_KHR = 1000127000,
    VK_STRUCTURE_TYPE_MEMORY_DEDICATED_ALLOCATE_INFO_KHR = 1000127001,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_FILTER_MINMAX_PROPERTIES_EXT =
        1000130000,
    VK_STRUCTURE_TYPE_SAMPLER_REDUCTION_MODE_CREATE_INFO_EXT = 1000130001,
    VK_STRUCTURE_TYPE_BUFFER_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146000,
    VK_STRUCTURE_TYPE_IMAGE_MEMORY_REQUIREMENTS_INFO_2_KHR = 1000146001,
    VK_STRUCTURE_TYPE_IMAGE_SPARSE_MEMORY_REQUIREMENTS_INFO_2_KHR =
        1000146002,
    VK_STRUCTURE_TYPE_MEMORY_REQUIREMENTS_2_KHR = 1000146003,
    VK_STRUCTURE_TYPE_SPARSE_IMAGE_MEMORY_REQUIREMENTS_2_KHR = 1000146004,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT =
        1000148000,
    VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_PROPERTIES_EXT
        = 1000148001,
    VK_STRUCTURE_TYPE_PIPELINE_COLOR_BLEND_ADVANCED_STATE_CREATE_INFO_EXT =
        1000148002,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_TO_COLOR_STATE_CREATE_INFO_NV =
        1000149000,
    VK_STRUCTURE_TYPE_PIPELINE_COVERAGE_MODULATION_STATE_CREATE_INFO_NV =
        1000152000,
    VK_STRUCTURE_TYPE_RANGE_SIZE = 49,
    VK_STRUCTURE_TYPE_MAX_ENUM = 2147483647,
}
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_BEGIN_RANGE:
          VkSystemAllocationScope =
    VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_COMMAND;
pub const VkSystemAllocationScope_VK_SYSTEM_ALLOCATION_SCOPE_END_RANGE:
          VkSystemAllocationScope =
    VkSystemAllocationScope::VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSystemAllocationScope {
    VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
    VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
    VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
    VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
    VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
    VK_SYSTEM_ALLOCATION_SCOPE_RANGE_SIZE = 5,
    VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 2147483647,
}
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_BEGIN_RANGE:
          VkInternalAllocationType =
    VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
pub const VkInternalAllocationType_VK_INTERNAL_ALLOCATION_TYPE_END_RANGE:
          VkInternalAllocationType =
    VkInternalAllocationType::VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkInternalAllocationType {
    VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
    VK_INTERNAL_ALLOCATION_TYPE_RANGE_SIZE = 1,
    VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 2147483647,
}
pub const VkFormat_VK_FORMAT_BEGIN_RANGE: VkFormat =
    VkFormat::VK_FORMAT_UNDEFINED;
pub const VkFormat_VK_FORMAT_END_RANGE: VkFormat =
    VkFormat::VK_FORMAT_ASTC_12x12_SRGB_BLOCK;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkFormat {
    VK_FORMAT_UNDEFINED = 0,
    VK_FORMAT_R4G4_UNORM_PACK8 = 1,
    VK_FORMAT_R4G4B4A4_UNORM_PACK16 = 2,
    VK_FORMAT_B4G4R4A4_UNORM_PACK16 = 3,
    VK_FORMAT_R5G6B5_UNORM_PACK16 = 4,
    VK_FORMAT_B5G6R5_UNORM_PACK16 = 5,
    VK_FORMAT_R5G5B5A1_UNORM_PACK16 = 6,
    VK_FORMAT_B5G5R5A1_UNORM_PACK16 = 7,
    VK_FORMAT_A1R5G5B5_UNORM_PACK16 = 8,
    VK_FORMAT_R8_UNORM = 9,
    VK_FORMAT_R8_SNORM = 10,
    VK_FORMAT_R8_USCALED = 11,
    VK_FORMAT_R8_SSCALED = 12,
    VK_FORMAT_R8_UINT = 13,
    VK_FORMAT_R8_SINT = 14,
    VK_FORMAT_R8_SRGB = 15,
    VK_FORMAT_R8G8_UNORM = 16,
    VK_FORMAT_R8G8_SNORM = 17,
    VK_FORMAT_R8G8_USCALED = 18,
    VK_FORMAT_R8G8_SSCALED = 19,
    VK_FORMAT_R8G8_UINT = 20,
    VK_FORMAT_R8G8_SINT = 21,
    VK_FORMAT_R8G8_SRGB = 22,
    VK_FORMAT_R8G8B8_UNORM = 23,
    VK_FORMAT_R8G8B8_SNORM = 24,
    VK_FORMAT_R8G8B8_USCALED = 25,
    VK_FORMAT_R8G8B8_SSCALED = 26,
    VK_FORMAT_R8G8B8_UINT = 27,
    VK_FORMAT_R8G8B8_SINT = 28,
    VK_FORMAT_R8G8B8_SRGB = 29,
    VK_FORMAT_B8G8R8_UNORM = 30,
    VK_FORMAT_B8G8R8_SNORM = 31,
    VK_FORMAT_B8G8R8_USCALED = 32,
    VK_FORMAT_B8G8R8_SSCALED = 33,
    VK_FORMAT_B8G8R8_UINT = 34,
    VK_FORMAT_B8G8R8_SINT = 35,
    VK_FORMAT_B8G8R8_SRGB = 36,
    VK_FORMAT_R8G8B8A8_UNORM = 37,
    VK_FORMAT_R8G8B8A8_SNORM = 38,
    VK_FORMAT_R8G8B8A8_USCALED = 39,
    VK_FORMAT_R8G8B8A8_SSCALED = 40,
    VK_FORMAT_R8G8B8A8_UINT = 41,
    VK_FORMAT_R8G8B8A8_SINT = 42,
    VK_FORMAT_R8G8B8A8_SRGB = 43,
    VK_FORMAT_B8G8R8A8_UNORM = 44,
    VK_FORMAT_B8G8R8A8_SNORM = 45,
    VK_FORMAT_B8G8R8A8_USCALED = 46,
    VK_FORMAT_B8G8R8A8_SSCALED = 47,
    VK_FORMAT_B8G8R8A8_UINT = 48,
    VK_FORMAT_B8G8R8A8_SINT = 49,
    VK_FORMAT_B8G8R8A8_SRGB = 50,
    VK_FORMAT_A8B8G8R8_UNORM_PACK32 = 51,
    VK_FORMAT_A8B8G8R8_SNORM_PACK32 = 52,
    VK_FORMAT_A8B8G8R8_USCALED_PACK32 = 53,
    VK_FORMAT_A8B8G8R8_SSCALED_PACK32 = 54,
    VK_FORMAT_A8B8G8R8_UINT_PACK32 = 55,
    VK_FORMAT_A8B8G8R8_SINT_PACK32 = 56,
    VK_FORMAT_A8B8G8R8_SRGB_PACK32 = 57,
    VK_FORMAT_A2R10G10B10_UNORM_PACK32 = 58,
    VK_FORMAT_A2R10G10B10_SNORM_PACK32 = 59,
    VK_FORMAT_A2R10G10B10_USCALED_PACK32 = 60,
    VK_FORMAT_A2R10G10B10_SSCALED_PACK32 = 61,
    VK_FORMAT_A2R10G10B10_UINT_PACK32 = 62,
    VK_FORMAT_A2R10G10B10_SINT_PACK32 = 63,
    VK_FORMAT_A2B10G10R10_UNORM_PACK32 = 64,
    VK_FORMAT_A2B10G10R10_SNORM_PACK32 = 65,
    VK_FORMAT_A2B10G10R10_USCALED_PACK32 = 66,
    VK_FORMAT_A2B10G10R10_SSCALED_PACK32 = 67,
    VK_FORMAT_A2B10G10R10_UINT_PACK32 = 68,
    VK_FORMAT_A2B10G10R10_SINT_PACK32 = 69,
    VK_FORMAT_R16_UNORM = 70,
    VK_FORMAT_R16_SNORM = 71,
    VK_FORMAT_R16_USCALED = 72,
    VK_FORMAT_R16_SSCALED = 73,
    VK_FORMAT_R16_UINT = 74,
    VK_FORMAT_R16_SINT = 75,
    VK_FORMAT_R16_SFLOAT = 76,
    VK_FORMAT_R16G16_UNORM = 77,
    VK_FORMAT_R16G16_SNORM = 78,
    VK_FORMAT_R16G16_USCALED = 79,
    VK_FORMAT_R16G16_SSCALED = 80,
    VK_FORMAT_R16G16_UINT = 81,
    VK_FORMAT_R16G16_SINT = 82,
    VK_FORMAT_R16G16_SFLOAT = 83,
    VK_FORMAT_R16G16B16_UNORM = 84,
    VK_FORMAT_R16G16B16_SNORM = 85,
    VK_FORMAT_R16G16B16_USCALED = 86,
    VK_FORMAT_R16G16B16_SSCALED = 87,
    VK_FORMAT_R16G16B16_UINT = 88,
    VK_FORMAT_R16G16B16_SINT = 89,
    VK_FORMAT_R16G16B16_SFLOAT = 90,
    VK_FORMAT_R16G16B16A16_UNORM = 91,
    VK_FORMAT_R16G16B16A16_SNORM = 92,
    VK_FORMAT_R16G16B16A16_USCALED = 93,
    VK_FORMAT_R16G16B16A16_SSCALED = 94,
    VK_FORMAT_R16G16B16A16_UINT = 95,
    VK_FORMAT_R16G16B16A16_SINT = 96,
    VK_FORMAT_R16G16B16A16_SFLOAT = 97,
    VK_FORMAT_R32_UINT = 98,
    VK_FORMAT_R32_SINT = 99,
    VK_FORMAT_R32_SFLOAT = 100,
    VK_FORMAT_R32G32_UINT = 101,
    VK_FORMAT_R32G32_SINT = 102,
    VK_FORMAT_R32G32_SFLOAT = 103,
    VK_FORMAT_R32G32B32_UINT = 104,
    VK_FORMAT_R32G32B32_SINT = 105,
    VK_FORMAT_R32G32B32_SFLOAT = 106,
    VK_FORMAT_R32G32B32A32_UINT = 107,
    VK_FORMAT_R32G32B32A32_SINT = 108,
    VK_FORMAT_R32G32B32A32_SFLOAT = 109,
    VK_FORMAT_R64_UINT = 110,
    VK_FORMAT_R64_SINT = 111,
    VK_FORMAT_R64_SFLOAT = 112,
    VK_FORMAT_R64G64_UINT = 113,
    VK_FORMAT_R64G64_SINT = 114,
    VK_FORMAT_R64G64_SFLOAT = 115,
    VK_FORMAT_R64G64B64_UINT = 116,
    VK_FORMAT_R64G64B64_SINT = 117,
    VK_FORMAT_R64G64B64_SFLOAT = 118,
    VK_FORMAT_R64G64B64A64_UINT = 119,
    VK_FORMAT_R64G64B64A64_SINT = 120,
    VK_FORMAT_R64G64B64A64_SFLOAT = 121,
    VK_FORMAT_B10G11R11_UFLOAT_PACK32 = 122,
    VK_FORMAT_E5B9G9R9_UFLOAT_PACK32 = 123,
    VK_FORMAT_D16_UNORM = 124,
    VK_FORMAT_X8_D24_UNORM_PACK32 = 125,
    VK_FORMAT_D32_SFLOAT = 126,
    VK_FORMAT_S8_UINT = 127,
    VK_FORMAT_D16_UNORM_S8_UINT = 128,
    VK_FORMAT_D24_UNORM_S8_UINT = 129,
    VK_FORMAT_D32_SFLOAT_S8_UINT = 130,
    VK_FORMAT_BC1_RGB_UNORM_BLOCK = 131,
    VK_FORMAT_BC1_RGB_SRGB_BLOCK = 132,
    VK_FORMAT_BC1_RGBA_UNORM_BLOCK = 133,
    VK_FORMAT_BC1_RGBA_SRGB_BLOCK = 134,
    VK_FORMAT_BC2_UNORM_BLOCK = 135,
    VK_FORMAT_BC2_SRGB_BLOCK = 136,
    VK_FORMAT_BC3_UNORM_BLOCK = 137,
    VK_FORMAT_BC3_SRGB_BLOCK = 138,
    VK_FORMAT_BC4_UNORM_BLOCK = 139,
    VK_FORMAT_BC4_SNORM_BLOCK = 140,
    VK_FORMAT_BC5_UNORM_BLOCK = 141,
    VK_FORMAT_BC5_SNORM_BLOCK = 142,
    VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
    VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
    VK_FORMAT_BC7_UNORM_BLOCK = 145,
    VK_FORMAT_BC7_SRGB_BLOCK = 146,
    VK_FORMAT_ETC2_R8G8B8_UNORM_BLOCK = 147,
    VK_FORMAT_ETC2_R8G8B8_SRGB_BLOCK = 148,
    VK_FORMAT_ETC2_R8G8B8A1_UNORM_BLOCK = 149,
    VK_FORMAT_ETC2_R8G8B8A1_SRGB_BLOCK = 150,
    VK_FORMAT_ETC2_R8G8B8A8_UNORM_BLOCK = 151,
    VK_FORMAT_ETC2_R8G8B8A8_SRGB_BLOCK = 152,
    VK_FORMAT_EAC_R11_UNORM_BLOCK = 153,
    VK_FORMAT_EAC_R11_SNORM_BLOCK = 154,
    VK_FORMAT_EAC_R11G11_UNORM_BLOCK = 155,
    VK_FORMAT_EAC_R11G11_SNORM_BLOCK = 156,
    VK_FORMAT_ASTC_4x4_UNORM_BLOCK = 157,
    VK_FORMAT_ASTC_4x4_SRGB_BLOCK = 158,
    VK_FORMAT_ASTC_5x4_UNORM_BLOCK = 159,
    VK_FORMAT_ASTC_5x4_SRGB_BLOCK = 160,
    VK_FORMAT_ASTC_5x5_UNORM_BLOCK = 161,
    VK_FORMAT_ASTC_5x5_SRGB_BLOCK = 162,
    VK_FORMAT_ASTC_6x5_UNORM_BLOCK = 163,
    VK_FORMAT_ASTC_6x5_SRGB_BLOCK = 164,
    VK_FORMAT_ASTC_6x6_UNORM_BLOCK = 165,
    VK_FORMAT_ASTC_6x6_SRGB_BLOCK = 166,
    VK_FORMAT_ASTC_8x5_UNORM_BLOCK = 167,
    VK_FORMAT_ASTC_8x5_SRGB_BLOCK = 168,
    VK_FORMAT_ASTC_8x6_UNORM_BLOCK = 169,
    VK_FORMAT_ASTC_8x6_SRGB_BLOCK = 170,
    VK_FORMAT_ASTC_8x8_UNORM_BLOCK = 171,
    VK_FORMAT_ASTC_8x8_SRGB_BLOCK = 172,
    VK_FORMAT_ASTC_10x5_UNORM_BLOCK = 173,
    VK_FORMAT_ASTC_10x5_SRGB_BLOCK = 174,
    VK_FORMAT_ASTC_10x6_UNORM_BLOCK = 175,
    VK_FORMAT_ASTC_10x6_SRGB_BLOCK = 176,
    VK_FORMAT_ASTC_10x8_UNORM_BLOCK = 177,
    VK_FORMAT_ASTC_10x8_SRGB_BLOCK = 178,
    VK_FORMAT_ASTC_10x10_UNORM_BLOCK = 179,
    VK_FORMAT_ASTC_10x10_SRGB_BLOCK = 180,
    VK_FORMAT_ASTC_12x10_UNORM_BLOCK = 181,
    VK_FORMAT_ASTC_12x10_SRGB_BLOCK = 182,
    VK_FORMAT_ASTC_12x12_UNORM_BLOCK = 183,
    VK_FORMAT_ASTC_12x12_SRGB_BLOCK = 184,
    VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
    VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
    VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
    VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
    VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
    VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
    VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
    VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
    VK_FORMAT_RANGE_SIZE = 185,
    VK_FORMAT_MAX_ENUM = 2147483647,
}
pub const VkImageType_VK_IMAGE_TYPE_BEGIN_RANGE: VkImageType =
    VkImageType::VK_IMAGE_TYPE_1D;
pub const VkImageType_VK_IMAGE_TYPE_END_RANGE: VkImageType =
    VkImageType::VK_IMAGE_TYPE_3D;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkImageType {
    VK_IMAGE_TYPE_1D = 0,
    VK_IMAGE_TYPE_2D = 1,
    VK_IMAGE_TYPE_3D = 2,
    VK_IMAGE_TYPE_RANGE_SIZE = 3,
    VK_IMAGE_TYPE_MAX_ENUM = 2147483647,
}
pub const VkImageTiling_VK_IMAGE_TILING_BEGIN_RANGE: VkImageTiling =
    VkImageTiling::VK_IMAGE_TILING_OPTIMAL;
pub const VkImageTiling_VK_IMAGE_TILING_END_RANGE: VkImageTiling =
    VkImageTiling::VK_IMAGE_TILING_LINEAR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkImageTiling {
    VK_IMAGE_TILING_OPTIMAL = 0,
    VK_IMAGE_TILING_LINEAR = 1,
    VK_IMAGE_TILING_RANGE_SIZE = 2,
    VK_IMAGE_TILING_MAX_ENUM = 2147483647,
}
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_BEGIN_RANGE:
          VkPhysicalDeviceType =
    VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_OTHER;
pub const VkPhysicalDeviceType_VK_PHYSICAL_DEVICE_TYPE_END_RANGE:
          VkPhysicalDeviceType =
    VkPhysicalDeviceType::VK_PHYSICAL_DEVICE_TYPE_CPU;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPhysicalDeviceType {
    VK_PHYSICAL_DEVICE_TYPE_OTHER = 0,
    VK_PHYSICAL_DEVICE_TYPE_INTEGRATED_GPU = 1,
    VK_PHYSICAL_DEVICE_TYPE_DISCRETE_GPU = 2,
    VK_PHYSICAL_DEVICE_TYPE_VIRTUAL_GPU = 3,
    VK_PHYSICAL_DEVICE_TYPE_CPU = 4,
    VK_PHYSICAL_DEVICE_TYPE_RANGE_SIZE = 5,
    VK_PHYSICAL_DEVICE_TYPE_MAX_ENUM = 2147483647,
}
pub const VkQueryType_VK_QUERY_TYPE_BEGIN_RANGE: VkQueryType =
    VkQueryType::VK_QUERY_TYPE_OCCLUSION;
pub const VkQueryType_VK_QUERY_TYPE_END_RANGE: VkQueryType =
    VkQueryType::VK_QUERY_TYPE_TIMESTAMP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkQueryType {
    VK_QUERY_TYPE_OCCLUSION = 0,
    VK_QUERY_TYPE_PIPELINE_STATISTICS = 1,
    VK_QUERY_TYPE_TIMESTAMP = 2,
    VK_QUERY_TYPE_RANGE_SIZE = 3,
    VK_QUERY_TYPE_MAX_ENUM = 2147483647,
}
pub const VkSharingMode_VK_SHARING_MODE_BEGIN_RANGE: VkSharingMode =
    VkSharingMode::VK_SHARING_MODE_EXCLUSIVE;
pub const VkSharingMode_VK_SHARING_MODE_END_RANGE: VkSharingMode =
    VkSharingMode::VK_SHARING_MODE_CONCURRENT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSharingMode {
    VK_SHARING_MODE_EXCLUSIVE = 0,
    VK_SHARING_MODE_CONCURRENT = 1,
    VK_SHARING_MODE_RANGE_SIZE = 2,
    VK_SHARING_MODE_MAX_ENUM = 2147483647,
}
pub const VkImageLayout_VK_IMAGE_LAYOUT_BEGIN_RANGE: VkImageLayout =
    VkImageLayout::VK_IMAGE_LAYOUT_UNDEFINED;
pub const VkImageLayout_VK_IMAGE_LAYOUT_END_RANGE: VkImageLayout =
    VkImageLayout::VK_IMAGE_LAYOUT_PREINITIALIZED;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkImageLayout {
    VK_IMAGE_LAYOUT_UNDEFINED = 0,
    VK_IMAGE_LAYOUT_GENERAL = 1,
    VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
    VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
    VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
    VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
    VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
    VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
    VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
    VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
    VK_IMAGE_LAYOUT_RANGE_SIZE = 9,
    VK_IMAGE_LAYOUT_MAX_ENUM = 2147483647,
}
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_BEGIN_RANGE: VkImageViewType =
    VkImageViewType::VK_IMAGE_VIEW_TYPE_1D;
pub const VkImageViewType_VK_IMAGE_VIEW_TYPE_END_RANGE: VkImageViewType =
    VkImageViewType::VK_IMAGE_VIEW_TYPE_CUBE_ARRAY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkImageViewType {
    VK_IMAGE_VIEW_TYPE_1D = 0,
    VK_IMAGE_VIEW_TYPE_2D = 1,
    VK_IMAGE_VIEW_TYPE_3D = 2,
    VK_IMAGE_VIEW_TYPE_CUBE = 3,
    VK_IMAGE_VIEW_TYPE_1D_ARRAY = 4,
    VK_IMAGE_VIEW_TYPE_2D_ARRAY = 5,
    VK_IMAGE_VIEW_TYPE_CUBE_ARRAY = 6,
    VK_IMAGE_VIEW_TYPE_RANGE_SIZE = 7,
    VK_IMAGE_VIEW_TYPE_MAX_ENUM = 2147483647,
}
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_BEGIN_RANGE:
          VkComponentSwizzle =
    VkComponentSwizzle::VK_COMPONENT_SWIZZLE_IDENTITY;
pub const VkComponentSwizzle_VK_COMPONENT_SWIZZLE_END_RANGE:
          VkComponentSwizzle =
    VkComponentSwizzle::VK_COMPONENT_SWIZZLE_A;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkComponentSwizzle {
    VK_COMPONENT_SWIZZLE_IDENTITY = 0,
    VK_COMPONENT_SWIZZLE_ZERO = 1,
    VK_COMPONENT_SWIZZLE_ONE = 2,
    VK_COMPONENT_SWIZZLE_R = 3,
    VK_COMPONENT_SWIZZLE_G = 4,
    VK_COMPONENT_SWIZZLE_B = 5,
    VK_COMPONENT_SWIZZLE_A = 6,
    VK_COMPONENT_SWIZZLE_RANGE_SIZE = 7,
    VK_COMPONENT_SWIZZLE_MAX_ENUM = 2147483647,
}
pub const VkVertexInputRate_VK_VERTEX_INPUT_RATE_BEGIN_RANGE:
          VkVertexInputRate =
    VkVertexInputRate::VK_VERTEX_INPUT_RATE_VERTEX;
pub const VkVertexInputRate_VK_VERTEX_INPUT_RATE_END_RANGE: VkVertexInputRate
          =
    VkVertexInputRate::VK_VERTEX_INPUT_RATE_INSTANCE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkVertexInputRate {
    VK_VERTEX_INPUT_RATE_VERTEX = 0,
    VK_VERTEX_INPUT_RATE_INSTANCE = 1,
    VK_VERTEX_INPUT_RATE_RANGE_SIZE = 2,
    VK_VERTEX_INPUT_RATE_MAX_ENUM = 2147483647,
}
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_BEGIN_RANGE:
          VkPrimitiveTopology =
    VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_POINT_LIST;
pub const VkPrimitiveTopology_VK_PRIMITIVE_TOPOLOGY_END_RANGE:
          VkPrimitiveTopology =
    VkPrimitiveTopology::VK_PRIMITIVE_TOPOLOGY_PATCH_LIST;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPrimitiveTopology {
    VK_PRIMITIVE_TOPOLOGY_POINT_LIST = 0,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST = 1,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP = 2,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST = 3,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP = 4,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_FAN = 5,
    VK_PRIMITIVE_TOPOLOGY_LINE_LIST_WITH_ADJACENCY = 6,
    VK_PRIMITIVE_TOPOLOGY_LINE_STRIP_WITH_ADJACENCY = 7,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST_WITH_ADJACENCY = 8,
    VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP_WITH_ADJACENCY = 9,
    VK_PRIMITIVE_TOPOLOGY_PATCH_LIST = 10,
    VK_PRIMITIVE_TOPOLOGY_RANGE_SIZE = 11,
    VK_PRIMITIVE_TOPOLOGY_MAX_ENUM = 2147483647,
}
pub const VkPolygonMode_VK_POLYGON_MODE_BEGIN_RANGE: VkPolygonMode =
    VkPolygonMode::VK_POLYGON_MODE_FILL;
pub const VkPolygonMode_VK_POLYGON_MODE_END_RANGE: VkPolygonMode =
    VkPolygonMode::VK_POLYGON_MODE_POINT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPolygonMode {
    VK_POLYGON_MODE_FILL = 0,
    VK_POLYGON_MODE_LINE = 1,
    VK_POLYGON_MODE_POINT = 2,
    VK_POLYGON_MODE_FILL_RECTANGLE_NV = 1000153000,
    VK_POLYGON_MODE_RANGE_SIZE = 3,
    VK_POLYGON_MODE_MAX_ENUM = 2147483647,
}
pub const VkFrontFace_VK_FRONT_FACE_BEGIN_RANGE: VkFrontFace =
    VkFrontFace::VK_FRONT_FACE_COUNTER_CLOCKWISE;
pub const VkFrontFace_VK_FRONT_FACE_END_RANGE: VkFrontFace =
    VkFrontFace::VK_FRONT_FACE_CLOCKWISE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkFrontFace {
    VK_FRONT_FACE_COUNTER_CLOCKWISE = 0,
    VK_FRONT_FACE_CLOCKWISE = 1,
    VK_FRONT_FACE_RANGE_SIZE = 2,
    VK_FRONT_FACE_MAX_ENUM = 2147483647,
}
pub const VkCompareOp_VK_COMPARE_OP_BEGIN_RANGE: VkCompareOp =
    VkCompareOp::VK_COMPARE_OP_NEVER;
pub const VkCompareOp_VK_COMPARE_OP_END_RANGE: VkCompareOp =
    VkCompareOp::VK_COMPARE_OP_ALWAYS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCompareOp {
    VK_COMPARE_OP_NEVER = 0,
    VK_COMPARE_OP_LESS = 1,
    VK_COMPARE_OP_EQUAL = 2,
    VK_COMPARE_OP_LESS_OR_EQUAL = 3,
    VK_COMPARE_OP_GREATER = 4,
    VK_COMPARE_OP_NOT_EQUAL = 5,
    VK_COMPARE_OP_GREATER_OR_EQUAL = 6,
    VK_COMPARE_OP_ALWAYS = 7,
    VK_COMPARE_OP_RANGE_SIZE = 8,
    VK_COMPARE_OP_MAX_ENUM = 2147483647,
}
pub const VkStencilOp_VK_STENCIL_OP_BEGIN_RANGE: VkStencilOp =
    VkStencilOp::VK_STENCIL_OP_KEEP;
pub const VkStencilOp_VK_STENCIL_OP_END_RANGE: VkStencilOp =
    VkStencilOp::VK_STENCIL_OP_DECREMENT_AND_WRAP;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkStencilOp {
    VK_STENCIL_OP_KEEP = 0,
    VK_STENCIL_OP_ZERO = 1,
    VK_STENCIL_OP_REPLACE = 2,
    VK_STENCIL_OP_INCREMENT_AND_CLAMP = 3,
    VK_STENCIL_OP_DECREMENT_AND_CLAMP = 4,
    VK_STENCIL_OP_INVERT = 5,
    VK_STENCIL_OP_INCREMENT_AND_WRAP = 6,
    VK_STENCIL_OP_DECREMENT_AND_WRAP = 7,
    VK_STENCIL_OP_RANGE_SIZE = 8,
    VK_STENCIL_OP_MAX_ENUM = 2147483647,
}
pub const VkLogicOp_VK_LOGIC_OP_BEGIN_RANGE: VkLogicOp =
    VkLogicOp::VK_LOGIC_OP_CLEAR;
pub const VkLogicOp_VK_LOGIC_OP_END_RANGE: VkLogicOp =
    VkLogicOp::VK_LOGIC_OP_SET;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkLogicOp {
    VK_LOGIC_OP_CLEAR = 0,
    VK_LOGIC_OP_AND = 1,
    VK_LOGIC_OP_AND_REVERSE = 2,
    VK_LOGIC_OP_COPY = 3,
    VK_LOGIC_OP_AND_INVERTED = 4,
    VK_LOGIC_OP_NO_OP = 5,
    VK_LOGIC_OP_XOR = 6,
    VK_LOGIC_OP_OR = 7,
    VK_LOGIC_OP_NOR = 8,
    VK_LOGIC_OP_EQUIVALENT = 9,
    VK_LOGIC_OP_INVERT = 10,
    VK_LOGIC_OP_OR_REVERSE = 11,
    VK_LOGIC_OP_COPY_INVERTED = 12,
    VK_LOGIC_OP_OR_INVERTED = 13,
    VK_LOGIC_OP_NAND = 14,
    VK_LOGIC_OP_SET = 15,
    VK_LOGIC_OP_RANGE_SIZE = 16,
    VK_LOGIC_OP_MAX_ENUM = 2147483647,
}
pub const VkBlendFactor_VK_BLEND_FACTOR_BEGIN_RANGE: VkBlendFactor =
    VkBlendFactor::VK_BLEND_FACTOR_ZERO;
pub const VkBlendFactor_VK_BLEND_FACTOR_END_RANGE: VkBlendFactor =
    VkBlendFactor::VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkBlendFactor {
    VK_BLEND_FACTOR_ZERO = 0,
    VK_BLEND_FACTOR_ONE = 1,
    VK_BLEND_FACTOR_SRC_COLOR = 2,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_COLOR = 3,
    VK_BLEND_FACTOR_DST_COLOR = 4,
    VK_BLEND_FACTOR_ONE_MINUS_DST_COLOR = 5,
    VK_BLEND_FACTOR_SRC_ALPHA = 6,
    VK_BLEND_FACTOR_ONE_MINUS_SRC_ALPHA = 7,
    VK_BLEND_FACTOR_DST_ALPHA = 8,
    VK_BLEND_FACTOR_ONE_MINUS_DST_ALPHA = 9,
    VK_BLEND_FACTOR_CONSTANT_COLOR = 10,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_COLOR = 11,
    VK_BLEND_FACTOR_CONSTANT_ALPHA = 12,
    VK_BLEND_FACTOR_ONE_MINUS_CONSTANT_ALPHA = 13,
    VK_BLEND_FACTOR_SRC_ALPHA_SATURATE = 14,
    VK_BLEND_FACTOR_SRC1_COLOR = 15,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_COLOR = 16,
    VK_BLEND_FACTOR_SRC1_ALPHA = 17,
    VK_BLEND_FACTOR_ONE_MINUS_SRC1_ALPHA = 18,
    VK_BLEND_FACTOR_RANGE_SIZE = 19,
    VK_BLEND_FACTOR_MAX_ENUM = 2147483647,
}
pub const VkBlendOp_VK_BLEND_OP_BEGIN_RANGE: VkBlendOp =
    VkBlendOp::VK_BLEND_OP_ADD;
pub const VkBlendOp_VK_BLEND_OP_END_RANGE: VkBlendOp =
    VkBlendOp::VK_BLEND_OP_MAX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkBlendOp {
    VK_BLEND_OP_ADD = 0,
    VK_BLEND_OP_SUBTRACT = 1,
    VK_BLEND_OP_REVERSE_SUBTRACT = 2,
    VK_BLEND_OP_MIN = 3,
    VK_BLEND_OP_MAX = 4,
    VK_BLEND_OP_ZERO_EXT = 1000148000,
    VK_BLEND_OP_SRC_EXT = 1000148001,
    VK_BLEND_OP_DST_EXT = 1000148002,
    VK_BLEND_OP_SRC_OVER_EXT = 1000148003,
    VK_BLEND_OP_DST_OVER_EXT = 1000148004,
    VK_BLEND_OP_SRC_IN_EXT = 1000148005,
    VK_BLEND_OP_DST_IN_EXT = 1000148006,
    VK_BLEND_OP_SRC_OUT_EXT = 1000148007,
    VK_BLEND_OP_DST_OUT_EXT = 1000148008,
    VK_BLEND_OP_SRC_ATOP_EXT = 1000148009,
    VK_BLEND_OP_DST_ATOP_EXT = 1000148010,
    VK_BLEND_OP_XOR_EXT = 1000148011,
    VK_BLEND_OP_MULTIPLY_EXT = 1000148012,
    VK_BLEND_OP_SCREEN_EXT = 1000148013,
    VK_BLEND_OP_OVERLAY_EXT = 1000148014,
    VK_BLEND_OP_DARKEN_EXT = 1000148015,
    VK_BLEND_OP_LIGHTEN_EXT = 1000148016,
    VK_BLEND_OP_COLORDODGE_EXT = 1000148017,
    VK_BLEND_OP_COLORBURN_EXT = 1000148018,
    VK_BLEND_OP_HARDLIGHT_EXT = 1000148019,
    VK_BLEND_OP_SOFTLIGHT_EXT = 1000148020,
    VK_BLEND_OP_DIFFERENCE_EXT = 1000148021,
    VK_BLEND_OP_EXCLUSION_EXT = 1000148022,
    VK_BLEND_OP_INVERT_EXT = 1000148023,
    VK_BLEND_OP_INVERT_RGB_EXT = 1000148024,
    VK_BLEND_OP_LINEARDODGE_EXT = 1000148025,
    VK_BLEND_OP_LINEARBURN_EXT = 1000148026,
    VK_BLEND_OP_VIVIDLIGHT_EXT = 1000148027,
    VK_BLEND_OP_LINEARLIGHT_EXT = 1000148028,
    VK_BLEND_OP_PINLIGHT_EXT = 1000148029,
    VK_BLEND_OP_HARDMIX_EXT = 1000148030,
    VK_BLEND_OP_HSL_HUE_EXT = 1000148031,
    VK_BLEND_OP_HSL_SATURATION_EXT = 1000148032,
    VK_BLEND_OP_HSL_COLOR_EXT = 1000148033,
    VK_BLEND_OP_HSL_LUMINOSITY_EXT = 1000148034,
    VK_BLEND_OP_PLUS_EXT = 1000148035,
    VK_BLEND_OP_PLUS_CLAMPED_EXT = 1000148036,
    VK_BLEND_OP_PLUS_CLAMPED_ALPHA_EXT = 1000148037,
    VK_BLEND_OP_PLUS_DARKER_EXT = 1000148038,
    VK_BLEND_OP_MINUS_EXT = 1000148039,
    VK_BLEND_OP_MINUS_CLAMPED_EXT = 1000148040,
    VK_BLEND_OP_CONTRAST_EXT = 1000148041,
    VK_BLEND_OP_INVERT_OVG_EXT = 1000148042,
    VK_BLEND_OP_RED_EXT = 1000148043,
    VK_BLEND_OP_GREEN_EXT = 1000148044,
    VK_BLEND_OP_BLUE_EXT = 1000148045,
    VK_BLEND_OP_RANGE_SIZE = 5,
    VK_BLEND_OP_MAX_ENUM = 2147483647,
}
pub const VkDynamicState_VK_DYNAMIC_STATE_BEGIN_RANGE: VkDynamicState =
    VkDynamicState::VK_DYNAMIC_STATE_VIEWPORT;
pub const VkDynamicState_VK_DYNAMIC_STATE_END_RANGE: VkDynamicState =
    VkDynamicState::VK_DYNAMIC_STATE_STENCIL_REFERENCE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDynamicState {
    VK_DYNAMIC_STATE_VIEWPORT = 0,
    VK_DYNAMIC_STATE_SCISSOR = 1,
    VK_DYNAMIC_STATE_LINE_WIDTH = 2,
    VK_DYNAMIC_STATE_DEPTH_BIAS = 3,
    VK_DYNAMIC_STATE_BLEND_CONSTANTS = 4,
    VK_DYNAMIC_STATE_DEPTH_BOUNDS = 5,
    VK_DYNAMIC_STATE_STENCIL_COMPARE_MASK = 6,
    VK_DYNAMIC_STATE_STENCIL_WRITE_MASK = 7,
    VK_DYNAMIC_STATE_STENCIL_REFERENCE = 8,
    VK_DYNAMIC_STATE_VIEWPORT_W_SCALING_NV = 1000087000,
    VK_DYNAMIC_STATE_DISCARD_RECTANGLE_EXT = 1000099000,
    VK_DYNAMIC_STATE_RANGE_SIZE = 9,
    VK_DYNAMIC_STATE_MAX_ENUM = 2147483647,
}
pub const VkFilter_VK_FILTER_BEGIN_RANGE: VkFilter =
    VkFilter::VK_FILTER_NEAREST;
pub const VkFilter_VK_FILTER_END_RANGE: VkFilter = VkFilter::VK_FILTER_LINEAR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkFilter {
    VK_FILTER_NEAREST = 0,
    VK_FILTER_LINEAR = 1,
    VK_FILTER_CUBIC_IMG = 1000015000,
    VK_FILTER_RANGE_SIZE = 2,
    VK_FILTER_MAX_ENUM = 2147483647,
}
pub const VkSamplerMipmapMode_VK_SAMPLER_MIPMAP_MODE_BEGIN_RANGE:
          VkSamplerMipmapMode =
    VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_NEAREST;
pub const VkSamplerMipmapMode_VK_SAMPLER_MIPMAP_MODE_END_RANGE:
          VkSamplerMipmapMode =
    VkSamplerMipmapMode::VK_SAMPLER_MIPMAP_MODE_LINEAR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSamplerMipmapMode {
    VK_SAMPLER_MIPMAP_MODE_NEAREST = 0,
    VK_SAMPLER_MIPMAP_MODE_LINEAR = 1,
    VK_SAMPLER_MIPMAP_MODE_RANGE_SIZE = 2,
    VK_SAMPLER_MIPMAP_MODE_MAX_ENUM = 2147483647,
}
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_BEGIN_RANGE:
          VkSamplerAddressMode =
    VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_REPEAT;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_END_RANGE:
          VkSamplerAddressMode =
    VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER;
pub const VkSamplerAddressMode_VK_SAMPLER_ADDRESS_MODE_RANGE_SIZE:
          VkSamplerAddressMode =
    VkSamplerAddressMode::VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSamplerAddressMode {
    VK_SAMPLER_ADDRESS_MODE_REPEAT = 0,
    VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT = 1,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE = 2,
    VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_BORDER = 3,
    VK_SAMPLER_ADDRESS_MODE_MIRROR_CLAMP_TO_EDGE = 4,
    VK_SAMPLER_ADDRESS_MODE_MAX_ENUM = 2147483647,
}
pub const VkBorderColor_VK_BORDER_COLOR_BEGIN_RANGE: VkBorderColor =
    VkBorderColor::VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK;
pub const VkBorderColor_VK_BORDER_COLOR_END_RANGE: VkBorderColor =
    VkBorderColor::VK_BORDER_COLOR_INT_OPAQUE_WHITE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkBorderColor {
    VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK = 0,
    VK_BORDER_COLOR_INT_TRANSPARENT_BLACK = 1,
    VK_BORDER_COLOR_FLOAT_OPAQUE_BLACK = 2,
    VK_BORDER_COLOR_INT_OPAQUE_BLACK = 3,
    VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE = 4,
    VK_BORDER_COLOR_INT_OPAQUE_WHITE = 5,
    VK_BORDER_COLOR_RANGE_SIZE = 6,
    VK_BORDER_COLOR_MAX_ENUM = 2147483647,
}
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_BEGIN_RANGE: VkDescriptorType =
    VkDescriptorType::VK_DESCRIPTOR_TYPE_SAMPLER;
pub const VkDescriptorType_VK_DESCRIPTOR_TYPE_END_RANGE: VkDescriptorType =
    VkDescriptorType::VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDescriptorType {
    VK_DESCRIPTOR_TYPE_SAMPLER = 0,
    VK_DESCRIPTOR_TYPE_COMBINED_IMAGE_SAMPLER = 1,
    VK_DESCRIPTOR_TYPE_SAMPLED_IMAGE = 2,
    VK_DESCRIPTOR_TYPE_STORAGE_IMAGE = 3,
    VK_DESCRIPTOR_TYPE_UNIFORM_TEXEL_BUFFER = 4,
    VK_DESCRIPTOR_TYPE_STORAGE_TEXEL_BUFFER = 5,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER = 6,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER = 7,
    VK_DESCRIPTOR_TYPE_UNIFORM_BUFFER_DYNAMIC = 8,
    VK_DESCRIPTOR_TYPE_STORAGE_BUFFER_DYNAMIC = 9,
    VK_DESCRIPTOR_TYPE_INPUT_ATTACHMENT = 10,
    VK_DESCRIPTOR_TYPE_RANGE_SIZE = 11,
    VK_DESCRIPTOR_TYPE_MAX_ENUM = 2147483647,
}
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_BEGIN_RANGE:
          VkAttachmentLoadOp =
    VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_LOAD;
pub const VkAttachmentLoadOp_VK_ATTACHMENT_LOAD_OP_END_RANGE:
          VkAttachmentLoadOp =
    VkAttachmentLoadOp::VK_ATTACHMENT_LOAD_OP_DONT_CARE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkAttachmentLoadOp {
    VK_ATTACHMENT_LOAD_OP_LOAD = 0,
    VK_ATTACHMENT_LOAD_OP_CLEAR = 1,
    VK_ATTACHMENT_LOAD_OP_DONT_CARE = 2,
    VK_ATTACHMENT_LOAD_OP_RANGE_SIZE = 3,
    VK_ATTACHMENT_LOAD_OP_MAX_ENUM = 2147483647,
}
pub const VkAttachmentStoreOp_VK_ATTACHMENT_STORE_OP_BEGIN_RANGE:
          VkAttachmentStoreOp =
    VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_STORE;
pub const VkAttachmentStoreOp_VK_ATTACHMENT_STORE_OP_END_RANGE:
          VkAttachmentStoreOp =
    VkAttachmentStoreOp::VK_ATTACHMENT_STORE_OP_DONT_CARE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkAttachmentStoreOp {
    VK_ATTACHMENT_STORE_OP_STORE = 0,
    VK_ATTACHMENT_STORE_OP_DONT_CARE = 1,
    VK_ATTACHMENT_STORE_OP_RANGE_SIZE = 2,
    VK_ATTACHMENT_STORE_OP_MAX_ENUM = 2147483647,
}
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_BEGIN_RANGE:
          VkPipelineBindPoint =
    VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_GRAPHICS;
pub const VkPipelineBindPoint_VK_PIPELINE_BIND_POINT_END_RANGE:
          VkPipelineBindPoint =
    VkPipelineBindPoint::VK_PIPELINE_BIND_POINT_COMPUTE;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPipelineBindPoint {
    VK_PIPELINE_BIND_POINT_GRAPHICS = 0,
    VK_PIPELINE_BIND_POINT_COMPUTE = 1,
    VK_PIPELINE_BIND_POINT_RANGE_SIZE = 2,
    VK_PIPELINE_BIND_POINT_MAX_ENUM = 2147483647,
}
pub const VkCommandBufferLevel_VK_COMMAND_BUFFER_LEVEL_BEGIN_RANGE:
          VkCommandBufferLevel =
    VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_PRIMARY;
pub const VkCommandBufferLevel_VK_COMMAND_BUFFER_LEVEL_END_RANGE:
          VkCommandBufferLevel =
    VkCommandBufferLevel::VK_COMMAND_BUFFER_LEVEL_SECONDARY;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCommandBufferLevel {
    VK_COMMAND_BUFFER_LEVEL_PRIMARY = 0,
    VK_COMMAND_BUFFER_LEVEL_SECONDARY = 1,
    VK_COMMAND_BUFFER_LEVEL_RANGE_SIZE = 2,
    VK_COMMAND_BUFFER_LEVEL_MAX_ENUM = 2147483647,
}
pub const VkIndexType_VK_INDEX_TYPE_BEGIN_RANGE: VkIndexType =
    VkIndexType::VK_INDEX_TYPE_UINT16;
pub const VkIndexType_VK_INDEX_TYPE_END_RANGE: VkIndexType =
    VkIndexType::VK_INDEX_TYPE_UINT32;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkIndexType {
    VK_INDEX_TYPE_UINT16 = 0,
    VK_INDEX_TYPE_UINT32 = 1,
    VK_INDEX_TYPE_RANGE_SIZE = 2,
    VK_INDEX_TYPE_MAX_ENUM = 2147483647,
}
pub const VkSubpassContents_VK_SUBPASS_CONTENTS_BEGIN_RANGE: VkSubpassContents
          =
    VkSubpassContents::VK_SUBPASS_CONTENTS_INLINE;
pub const VkSubpassContents_VK_SUBPASS_CONTENTS_END_RANGE: VkSubpassContents =
    VkSubpassContents::VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSubpassContents {
    VK_SUBPASS_CONTENTS_INLINE = 0,
    VK_SUBPASS_CONTENTS_SECONDARY_COMMAND_BUFFERS = 1,
    VK_SUBPASS_CONTENTS_RANGE_SIZE = 2,
    VK_SUBPASS_CONTENTS_MAX_ENUM = 2147483647,
}
pub const VkObjectType_VK_OBJECT_TYPE_BEGIN_RANGE: VkObjectType =
    VkObjectType::VK_OBJECT_TYPE_UNKNOWN;
pub const VkObjectType_VK_OBJECT_TYPE_END_RANGE: VkObjectType =
    VkObjectType::VK_OBJECT_TYPE_COMMAND_POOL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkObjectType {
    VK_OBJECT_TYPE_UNKNOWN = 0,
    VK_OBJECT_TYPE_INSTANCE = 1,
    VK_OBJECT_TYPE_PHYSICAL_DEVICE = 2,
    VK_OBJECT_TYPE_DEVICE = 3,
    VK_OBJECT_TYPE_QUEUE = 4,
    VK_OBJECT_TYPE_SEMAPHORE = 5,
    VK_OBJECT_TYPE_COMMAND_BUFFER = 6,
    VK_OBJECT_TYPE_FENCE = 7,
    VK_OBJECT_TYPE_DEVICE_MEMORY = 8,
    VK_OBJECT_TYPE_BUFFER = 9,
    VK_OBJECT_TYPE_IMAGE = 10,
    VK_OBJECT_TYPE_EVENT = 11,
    VK_OBJECT_TYPE_QUERY_POOL = 12,
    VK_OBJECT_TYPE_BUFFER_VIEW = 13,
    VK_OBJECT_TYPE_IMAGE_VIEW = 14,
    VK_OBJECT_TYPE_SHADER_MODULE = 15,
    VK_OBJECT_TYPE_PIPELINE_CACHE = 16,
    VK_OBJECT_TYPE_PIPELINE_LAYOUT = 17,
    VK_OBJECT_TYPE_RENDER_PASS = 18,
    VK_OBJECT_TYPE_PIPELINE = 19,
    VK_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT = 20,
    VK_OBJECT_TYPE_SAMPLER = 21,
    VK_OBJECT_TYPE_DESCRIPTOR_POOL = 22,
    VK_OBJECT_TYPE_DESCRIPTOR_SET = 23,
    VK_OBJECT_TYPE_FRAMEBUFFER = 24,
    VK_OBJECT_TYPE_COMMAND_POOL = 25,
    VK_OBJECT_TYPE_SURFACE_KHR = 1000000000,
    VK_OBJECT_TYPE_SWAPCHAIN_KHR = 1000001000,
    VK_OBJECT_TYPE_DISPLAY_KHR = 1000002000,
    VK_OBJECT_TYPE_DISPLAY_MODE_KHR = 1000002001,
    VK_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT = 1000011000,
    VK_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR = 1000085000,
    VK_OBJECT_TYPE_OBJECT_TABLE_NVX = 1000086000,
    VK_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX = 1000086001,
    VK_OBJECT_TYPE_RANGE_SIZE = 26,
    VK_OBJECT_TYPE_MAX_ENUM = 2147483647,
}
pub type VkInstanceCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkFormatFeatureFlagBits {
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT = 1,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_BIT = 2,
    VK_FORMAT_FEATURE_STORAGE_IMAGE_ATOMIC_BIT = 4,
    VK_FORMAT_FEATURE_UNIFORM_TEXEL_BUFFER_BIT = 8,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_BIT = 16,
    VK_FORMAT_FEATURE_STORAGE_TEXEL_BUFFER_ATOMIC_BIT = 32,
    VK_FORMAT_FEATURE_VERTEX_BUFFER_BIT = 64,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BIT = 128,
    VK_FORMAT_FEATURE_COLOR_ATTACHMENT_BLEND_BIT = 256,
    VK_FORMAT_FEATURE_DEPTH_STENCIL_ATTACHMENT_BIT = 512,
    VK_FORMAT_FEATURE_BLIT_SRC_BIT = 1024,
    VK_FORMAT_FEATURE_BLIT_DST_BIT = 2048,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_LINEAR_BIT = 4096,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_CUBIC_BIT_IMG = 8192,
    VK_FORMAT_FEATURE_TRANSFER_SRC_BIT_KHR = 16384,
    VK_FORMAT_FEATURE_TRANSFER_DST_BIT_KHR = 32768,
    VK_FORMAT_FEATURE_SAMPLED_IMAGE_FILTER_MINMAX_BIT_EXT = 65536,
    VK_FORMAT_FEATURE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkFormatFeatureFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkImageUsageFlagBits {
    VK_IMAGE_USAGE_TRANSFER_SRC_BIT = 1,
    VK_IMAGE_USAGE_TRANSFER_DST_BIT = 2,
    VK_IMAGE_USAGE_SAMPLED_BIT = 4,
    VK_IMAGE_USAGE_STORAGE_BIT = 8,
    VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT = 16,
    VK_IMAGE_USAGE_DEPTH_STENCIL_ATTACHMENT_BIT = 32,
    VK_IMAGE_USAGE_TRANSIENT_ATTACHMENT_BIT = 64,
    VK_IMAGE_USAGE_INPUT_ATTACHMENT_BIT = 128,
    VK_IMAGE_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkImageUsageFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkImageCreateFlagBits {
    VK_IMAGE_CREATE_SPARSE_BINDING_BIT = 1,
    VK_IMAGE_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_IMAGE_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_IMAGE_CREATE_MUTABLE_FORMAT_BIT = 8,
    VK_IMAGE_CREATE_CUBE_COMPATIBLE_BIT = 16,
    VK_IMAGE_CREATE_BIND_SFR_BIT_KHX = 64,
    VK_IMAGE_CREATE_2D_ARRAY_COMPATIBLE_BIT_KHR = 32,
    VK_IMAGE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkImageCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSampleCountFlagBits {
    VK_SAMPLE_COUNT_1_BIT = 1,
    VK_SAMPLE_COUNT_2_BIT = 2,
    VK_SAMPLE_COUNT_4_BIT = 4,
    VK_SAMPLE_COUNT_8_BIT = 8,
    VK_SAMPLE_COUNT_16_BIT = 16,
    VK_SAMPLE_COUNT_32_BIT = 32,
    VK_SAMPLE_COUNT_64_BIT = 64,
    VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkSampleCountFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkQueueFlagBits {
    VK_QUEUE_GRAPHICS_BIT = 1,
    VK_QUEUE_COMPUTE_BIT = 2,
    VK_QUEUE_TRANSFER_BIT = 4,
    VK_QUEUE_SPARSE_BINDING_BIT = 8,
    VK_QUEUE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkQueueFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkMemoryPropertyFlagBits {
    VK_MEMORY_PROPERTY_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT = 2,
    VK_MEMORY_PROPERTY_HOST_COHERENT_BIT = 4,
    VK_MEMORY_PROPERTY_HOST_CACHED_BIT = 8,
    VK_MEMORY_PROPERTY_LAZILY_ALLOCATED_BIT = 16,
    VK_MEMORY_PROPERTY_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkMemoryPropertyFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkMemoryHeapFlagBits {
    VK_MEMORY_HEAP_DEVICE_LOCAL_BIT = 1,
    VK_MEMORY_HEAP_MULTI_INSTANCE_BIT_KHX = 2,
    VK_MEMORY_HEAP_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkMemoryHeapFlags = VkFlags;
pub type VkDeviceCreateFlags = VkFlags;
pub type VkDeviceQueueCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPipelineStageFlagBits {
    VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT = 1,
    VK_PIPELINE_STAGE_DRAW_INDIRECT_BIT = 2,
    VK_PIPELINE_STAGE_VERTEX_INPUT_BIT = 4,
    VK_PIPELINE_STAGE_VERTEX_SHADER_BIT = 8,
    VK_PIPELINE_STAGE_TESSELLATION_CONTROL_SHADER_BIT = 16,
    VK_PIPELINE_STAGE_TESSELLATION_EVALUATION_SHADER_BIT = 32,
    VK_PIPELINE_STAGE_GEOMETRY_SHADER_BIT = 64,
    VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT = 128,
    VK_PIPELINE_STAGE_EARLY_FRAGMENT_TESTS_BIT = 256,
    VK_PIPELINE_STAGE_LATE_FRAGMENT_TESTS_BIT = 512,
    VK_PIPELINE_STAGE_COLOR_ATTACHMENT_OUTPUT_BIT = 1024,
    VK_PIPELINE_STAGE_COMPUTE_SHADER_BIT = 2048,
    VK_PIPELINE_STAGE_TRANSFER_BIT = 4096,
    VK_PIPELINE_STAGE_BOTTOM_OF_PIPE_BIT = 8192,
    VK_PIPELINE_STAGE_HOST_BIT = 16384,
    VK_PIPELINE_STAGE_ALL_GRAPHICS_BIT = 32768,
    VK_PIPELINE_STAGE_ALL_COMMANDS_BIT = 65536,
    VK_PIPELINE_STAGE_COMMAND_PROCESS_BIT_NVX = 131072,
    VK_PIPELINE_STAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkPipelineStageFlags = VkFlags;
pub type VkMemoryMapFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkImageAspectFlagBits {
    VK_IMAGE_ASPECT_COLOR_BIT = 1,
    VK_IMAGE_ASPECT_DEPTH_BIT = 2,
    VK_IMAGE_ASPECT_STENCIL_BIT = 4,
    VK_IMAGE_ASPECT_METADATA_BIT = 8,
    VK_IMAGE_ASPECT_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkImageAspectFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSparseImageFormatFlagBits {
    VK_SPARSE_IMAGE_FORMAT_SINGLE_MIPTAIL_BIT = 1,
    VK_SPARSE_IMAGE_FORMAT_ALIGNED_MIP_SIZE_BIT = 2,
    VK_SPARSE_IMAGE_FORMAT_NONSTANDARD_BLOCK_SIZE_BIT = 4,
    VK_SPARSE_IMAGE_FORMAT_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkSparseImageFormatFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSparseMemoryBindFlagBits {
    VK_SPARSE_MEMORY_BIND_METADATA_BIT = 1,
    VK_SPARSE_MEMORY_BIND_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkSparseMemoryBindFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkFenceCreateFlagBits {
    VK_FENCE_CREATE_SIGNALED_BIT = 1,
    VK_FENCE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkFenceCreateFlags = VkFlags;
pub type VkSemaphoreCreateFlags = VkFlags;
pub type VkEventCreateFlags = VkFlags;
pub type VkQueryPoolCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkQueryPipelineStatisticFlagBits {
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_VERTICES_BIT = 1,
    VK_QUERY_PIPELINE_STATISTIC_INPUT_ASSEMBLY_PRIMITIVES_BIT = 2,
    VK_QUERY_PIPELINE_STATISTIC_VERTEX_SHADER_INVOCATIONS_BIT = 4,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_INVOCATIONS_BIT = 8,
    VK_QUERY_PIPELINE_STATISTIC_GEOMETRY_SHADER_PRIMITIVES_BIT = 16,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_INVOCATIONS_BIT = 32,
    VK_QUERY_PIPELINE_STATISTIC_CLIPPING_PRIMITIVES_BIT = 64,
    VK_QUERY_PIPELINE_STATISTIC_FRAGMENT_SHADER_INVOCATIONS_BIT = 128,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_CONTROL_SHADER_PATCHES_BIT = 256,
    VK_QUERY_PIPELINE_STATISTIC_TESSELLATION_EVALUATION_SHADER_INVOCATIONS_BIT
        = 512,
    VK_QUERY_PIPELINE_STATISTIC_COMPUTE_SHADER_INVOCATIONS_BIT = 1024,
    VK_QUERY_PIPELINE_STATISTIC_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkQueryPipelineStatisticFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkQueryResultFlagBits {
    VK_QUERY_RESULT_64_BIT = 1,
    VK_QUERY_RESULT_WAIT_BIT = 2,
    VK_QUERY_RESULT_WITH_AVAILABILITY_BIT = 4,
    VK_QUERY_RESULT_PARTIAL_BIT = 8,
    VK_QUERY_RESULT_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkQueryResultFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkBufferCreateFlagBits {
    VK_BUFFER_CREATE_SPARSE_BINDING_BIT = 1,
    VK_BUFFER_CREATE_SPARSE_RESIDENCY_BIT = 2,
    VK_BUFFER_CREATE_SPARSE_ALIASED_BIT = 4,
    VK_BUFFER_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkBufferCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkBufferUsageFlagBits {
    VK_BUFFER_USAGE_TRANSFER_SRC_BIT = 1,
    VK_BUFFER_USAGE_TRANSFER_DST_BIT = 2,
    VK_BUFFER_USAGE_UNIFORM_TEXEL_BUFFER_BIT = 4,
    VK_BUFFER_USAGE_STORAGE_TEXEL_BUFFER_BIT = 8,
    VK_BUFFER_USAGE_UNIFORM_BUFFER_BIT = 16,
    VK_BUFFER_USAGE_STORAGE_BUFFER_BIT = 32,
    VK_BUFFER_USAGE_INDEX_BUFFER_BIT = 64,
    VK_BUFFER_USAGE_VERTEX_BUFFER_BIT = 128,
    VK_BUFFER_USAGE_INDIRECT_BUFFER_BIT = 256,
    VK_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkBufferUsageFlags = VkFlags;
pub type VkBufferViewCreateFlags = VkFlags;
pub type VkImageViewCreateFlags = VkFlags;
pub type VkShaderModuleCreateFlags = VkFlags;
pub type VkPipelineCacheCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPipelineCreateFlagBits {
    VK_PIPELINE_CREATE_DISABLE_OPTIMIZATION_BIT = 1,
    VK_PIPELINE_CREATE_ALLOW_DERIVATIVES_BIT = 2,
    VK_PIPELINE_CREATE_DERIVATIVE_BIT = 4,
    VK_PIPELINE_CREATE_VIEW_INDEX_FROM_DEVICE_INDEX_BIT_KHX = 8,
    VK_PIPELINE_CREATE_DISPATCH_BASE_KHX = 16,
    VK_PIPELINE_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkPipelineCreateFlags = VkFlags;
pub type VkPipelineShaderStageCreateFlags = VkFlags;
pub const VkShaderStageFlagBits_VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM:
          VkShaderStageFlagBits =
    VkShaderStageFlagBits::VK_SHADER_STAGE_ALL;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkShaderStageFlagBits {
    VK_SHADER_STAGE_VERTEX_BIT = 1,
    VK_SHADER_STAGE_TESSELLATION_CONTROL_BIT = 2,
    VK_SHADER_STAGE_TESSELLATION_EVALUATION_BIT = 4,
    VK_SHADER_STAGE_GEOMETRY_BIT = 8,
    VK_SHADER_STAGE_FRAGMENT_BIT = 16,
    VK_SHADER_STAGE_COMPUTE_BIT = 32,
    VK_SHADER_STAGE_ALL_GRAPHICS = 31,
    VK_SHADER_STAGE_ALL = 2147483647,
}
pub type VkPipelineVertexInputStateCreateFlags = VkFlags;
pub type VkPipelineInputAssemblyStateCreateFlags = VkFlags;
pub type VkPipelineTessellationStateCreateFlags = VkFlags;
pub type VkPipelineViewportStateCreateFlags = VkFlags;
pub type VkPipelineRasterizationStateCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCullModeFlagBits {
    VK_CULL_MODE_NONE = 0,
    VK_CULL_MODE_FRONT_BIT = 1,
    VK_CULL_MODE_BACK_BIT = 2,
    VK_CULL_MODE_FRONT_AND_BACK = 3,
    VK_CULL_MODE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkCullModeFlags = VkFlags;
pub type VkPipelineMultisampleStateCreateFlags = VkFlags;
pub type VkPipelineDepthStencilStateCreateFlags = VkFlags;
pub type VkPipelineColorBlendStateCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkColorComponentFlagBits {
    VK_COLOR_COMPONENT_R_BIT = 1,
    VK_COLOR_COMPONENT_G_BIT = 2,
    VK_COLOR_COMPONENT_B_BIT = 4,
    VK_COLOR_COMPONENT_A_BIT = 8,
    VK_COLOR_COMPONENT_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkColorComponentFlags = VkFlags;
pub type VkPipelineDynamicStateCreateFlags = VkFlags;
pub type VkPipelineLayoutCreateFlags = VkFlags;
pub type VkShaderStageFlags = VkFlags;
pub type VkSamplerCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDescriptorSetLayoutCreateFlagBits {
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_PUSH_DESCRIPTOR_BIT_KHR = 1,
    VK_DESCRIPTOR_SET_LAYOUT_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkDescriptorSetLayoutCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDescriptorPoolCreateFlagBits {
    VK_DESCRIPTOR_POOL_CREATE_FREE_DESCRIPTOR_SET_BIT = 1,
    VK_DESCRIPTOR_POOL_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkDescriptorPoolCreateFlags = VkFlags;
pub type VkDescriptorPoolResetFlags = VkFlags;
pub type VkFramebufferCreateFlags = VkFlags;
pub type VkRenderPassCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkAttachmentDescriptionFlagBits {
    VK_ATTACHMENT_DESCRIPTION_MAY_ALIAS_BIT = 1,
    VK_ATTACHMENT_DESCRIPTION_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkAttachmentDescriptionFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSubpassDescriptionFlagBits {
    VK_SUBPASS_DESCRIPTION_PER_VIEW_ATTRIBUTES_BIT_NVX = 1,
    VK_SUBPASS_DESCRIPTION_PER_VIEW_POSITION_X_ONLY_BIT_NVX = 2,
    VK_SUBPASS_DESCRIPTION_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkSubpassDescriptionFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkAccessFlagBits {
    VK_ACCESS_INDIRECT_COMMAND_READ_BIT = 1,
    VK_ACCESS_INDEX_READ_BIT = 2,
    VK_ACCESS_VERTEX_ATTRIBUTE_READ_BIT = 4,
    VK_ACCESS_UNIFORM_READ_BIT = 8,
    VK_ACCESS_INPUT_ATTACHMENT_READ_BIT = 16,
    VK_ACCESS_SHADER_READ_BIT = 32,
    VK_ACCESS_SHADER_WRITE_BIT = 64,
    VK_ACCESS_COLOR_ATTACHMENT_READ_BIT = 128,
    VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT = 256,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_READ_BIT = 512,
    VK_ACCESS_DEPTH_STENCIL_ATTACHMENT_WRITE_BIT = 1024,
    VK_ACCESS_TRANSFER_READ_BIT = 2048,
    VK_ACCESS_TRANSFER_WRITE_BIT = 4096,
    VK_ACCESS_HOST_READ_BIT = 8192,
    VK_ACCESS_HOST_WRITE_BIT = 16384,
    VK_ACCESS_MEMORY_READ_BIT = 32768,
    VK_ACCESS_MEMORY_WRITE_BIT = 65536,
    VK_ACCESS_COMMAND_PROCESS_READ_BIT_NVX = 131072,
    VK_ACCESS_COMMAND_PROCESS_WRITE_BIT_NVX = 262144,
    VK_ACCESS_COLOR_ATTACHMENT_READ_NONCOHERENT_BIT_EXT = 524288,
    VK_ACCESS_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkAccessFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDependencyFlagBits {
    VK_DEPENDENCY_BY_REGION_BIT = 1,
    VK_DEPENDENCY_VIEW_LOCAL_BIT_KHX = 2,
    VK_DEPENDENCY_DEVICE_GROUP_BIT_KHX = 4,
    VK_DEPENDENCY_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkDependencyFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCommandPoolCreateFlagBits {
    VK_COMMAND_POOL_CREATE_TRANSIENT_BIT = 1,
    VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT = 2,
    VK_COMMAND_POOL_CREATE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkCommandPoolCreateFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCommandPoolResetFlagBits {
    VK_COMMAND_POOL_RESET_RELEASE_RESOURCES_BIT = 1,
    VK_COMMAND_POOL_RESET_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkCommandPoolResetFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCommandBufferUsageFlagBits {
    VK_COMMAND_BUFFER_USAGE_ONE_TIME_SUBMIT_BIT = 1,
    VK_COMMAND_BUFFER_USAGE_RENDER_PASS_CONTINUE_BIT = 2,
    VK_COMMAND_BUFFER_USAGE_SIMULTANEOUS_USE_BIT = 4,
    VK_COMMAND_BUFFER_USAGE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkCommandBufferUsageFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkQueryControlFlagBits {
    VK_QUERY_CONTROL_PRECISE_BIT = 1,
    VK_QUERY_CONTROL_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkQueryControlFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCommandBufferResetFlagBits {
    VK_COMMAND_BUFFER_RESET_RELEASE_RESOURCES_BIT = 1,
    VK_COMMAND_BUFFER_RESET_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkCommandBufferResetFlags = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkStencilFaceFlagBits {
    VK_STENCIL_FACE_FRONT_BIT = 1,
    VK_STENCIL_FACE_BACK_BIT = 2,
    VK_STENCIL_FRONT_AND_BACK = 3,
    VK_STENCIL_FACE_FLAG_BITS_MAX_ENUM = 2147483647,
}
pub type VkStencilFaceFlags = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkApplicationInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pApplicationName: *const ::std::os::raw::c_char,
    pub applicationVersion: u32,
    pub pEngineName: *const ::std::os::raw::c_char,
    pub engineVersion: u32,
    pub apiVersion: u32,
}
#[test]
fn bindgen_test_layout_VkApplicationInfo() {
    assert_eq!(::std::mem::size_of::<VkApplicationInfo>() , 48usize , concat !
               ( "Size of: " , stringify ! ( VkApplicationInfo ) ));
    assert_eq! (::std::mem::align_of::<VkApplicationInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkApplicationInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkApplicationInfo ) ) . sType as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkApplicationInfo ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkApplicationInfo ) ) . pNext as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkApplicationInfo ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkApplicationInfo ) ) . pApplicationName
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkApplicationInfo ) ,
                "::" , stringify ! ( pApplicationName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkApplicationInfo ) ) .
                applicationVersion as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkApplicationInfo ) ,
                "::" , stringify ! ( applicationVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkApplicationInfo ) ) . pEngineName as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkApplicationInfo ) ,
                "::" , stringify ! ( pEngineName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkApplicationInfo ) ) . engineVersion as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkApplicationInfo ) ,
                "::" , stringify ! ( engineVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkApplicationInfo ) ) . apiVersion as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( VkApplicationInfo ) ,
                "::" , stringify ! ( apiVersion ) ));
}
impl Clone for VkApplicationInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkInstanceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkInstanceCreateFlags,
    pub pApplicationInfo: *const VkApplicationInfo,
    pub enabledLayerCount: u32,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: u32,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkInstanceCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkInstanceCreateInfo>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( VkInstanceCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkInstanceCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkInstanceCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkInstanceCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkInstanceCreateInfo )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkInstanceCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkInstanceCreateInfo )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkInstanceCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkInstanceCreateInfo )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkInstanceCreateInfo ) ) .
                pApplicationInfo as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkInstanceCreateInfo )
                , "::" , stringify ! ( pApplicationInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkInstanceCreateInfo ) ) .
                enabledLayerCount as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkInstanceCreateInfo )
                , "::" , stringify ! ( enabledLayerCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkInstanceCreateInfo ) ) .
                ppEnabledLayerNames as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkInstanceCreateInfo )
                , "::" , stringify ! ( ppEnabledLayerNames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkInstanceCreateInfo ) ) .
                enabledExtensionCount as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkInstanceCreateInfo )
                , "::" , stringify ! ( enabledExtensionCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkInstanceCreateInfo ) ) .
                ppEnabledExtensionNames as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkInstanceCreateInfo )
                , "::" , stringify ! ( ppEnabledExtensionNames ) ));
}
impl Clone for VkInstanceCreateInfo {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkAllocationFunction =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               size: usize, alignment: usize,
                                               allocationScope:
                                                   VkSystemAllocationScope)
                              -> *mut ::std::os::raw::c_void>;
pub type PFN_vkReallocationFunction =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               pOriginal:
                                                   *mut ::std::os::raw::c_void,
                                               size: usize, alignment: usize,
                                               allocationScope:
                                                   VkSystemAllocationScope)
                              -> *mut ::std::os::raw::c_void>;
pub type PFN_vkFreeFunction =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               pMemory:
                                                   *mut ::std::os::raw::c_void)>;
pub type PFN_vkInternalAllocationNotification =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               size: usize,
                                               allocationType:
                                                   VkInternalAllocationType,
                                               allocationScope:
                                                   VkSystemAllocationScope)>;
pub type PFN_vkInternalFreeNotification =
    ::std::option::Option<unsafe extern "C" fn(pUserData:
                                                   *mut ::std::os::raw::c_void,
                                               size: usize,
                                               allocationType:
                                                   VkInternalAllocationType,
                                               allocationScope:
                                                   VkSystemAllocationScope)>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkAllocationCallbacks {
    pub pUserData: *mut ::std::os::raw::c_void,
    pub pfnAllocation: PFN_vkAllocationFunction,
    pub pfnReallocation: PFN_vkReallocationFunction,
    pub pfnFree: PFN_vkFreeFunction,
    pub pfnInternalAllocation: PFN_vkInternalAllocationNotification,
    pub pfnInternalFree: PFN_vkInternalFreeNotification,
}
#[test]
fn bindgen_test_layout_VkAllocationCallbacks() {
    assert_eq!(::std::mem::size_of::<VkAllocationCallbacks>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( VkAllocationCallbacks )
               ));
    assert_eq! (::std::mem::align_of::<VkAllocationCallbacks>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkAllocationCallbacks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAllocationCallbacks ) ) . pUserData as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAllocationCallbacks )
                , "::" , stringify ! ( pUserData ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAllocationCallbacks ) ) . pfnAllocation
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAllocationCallbacks )
                , "::" , stringify ! ( pfnAllocation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAllocationCallbacks ) ) .
                pfnReallocation as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAllocationCallbacks )
                , "::" , stringify ! ( pfnReallocation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAllocationCallbacks ) ) . pfnFree as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAllocationCallbacks )
                , "::" , stringify ! ( pfnFree ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAllocationCallbacks ) ) .
                pfnInternalAllocation as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkAllocationCallbacks )
                , "::" , stringify ! ( pfnInternalAllocation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAllocationCallbacks ) ) .
                pfnInternalFree as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAllocationCallbacks )
                , "::" , stringify ! ( pfnInternalFree ) ));
}
impl Clone for VkAllocationCallbacks {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceFeatures {
    pub robustBufferAccess: VkBool32,
    pub fullDrawIndexUint32: VkBool32,
    pub imageCubeArray: VkBool32,
    pub independentBlend: VkBool32,
    pub geometryShader: VkBool32,
    pub tessellationShader: VkBool32,
    pub sampleRateShading: VkBool32,
    pub dualSrcBlend: VkBool32,
    pub logicOp: VkBool32,
    pub multiDrawIndirect: VkBool32,
    pub drawIndirectFirstInstance: VkBool32,
    pub depthClamp: VkBool32,
    pub depthBiasClamp: VkBool32,
    pub fillModeNonSolid: VkBool32,
    pub depthBounds: VkBool32,
    pub wideLines: VkBool32,
    pub largePoints: VkBool32,
    pub alphaToOne: VkBool32,
    pub multiViewport: VkBool32,
    pub samplerAnisotropy: VkBool32,
    pub textureCompressionETC2: VkBool32,
    pub textureCompressionASTC_LDR: VkBool32,
    pub textureCompressionBC: VkBool32,
    pub occlusionQueryPrecise: VkBool32,
    pub pipelineStatisticsQuery: VkBool32,
    pub vertexPipelineStoresAndAtomics: VkBool32,
    pub fragmentStoresAndAtomics: VkBool32,
    pub shaderTessellationAndGeometryPointSize: VkBool32,
    pub shaderImageGatherExtended: VkBool32,
    pub shaderStorageImageExtendedFormats: VkBool32,
    pub shaderStorageImageMultisample: VkBool32,
    pub shaderStorageImageReadWithoutFormat: VkBool32,
    pub shaderStorageImageWriteWithoutFormat: VkBool32,
    pub shaderUniformBufferArrayDynamicIndexing: VkBool32,
    pub shaderSampledImageArrayDynamicIndexing: VkBool32,
    pub shaderStorageBufferArrayDynamicIndexing: VkBool32,
    pub shaderStorageImageArrayDynamicIndexing: VkBool32,
    pub shaderClipDistance: VkBool32,
    pub shaderCullDistance: VkBool32,
    pub shaderFloat64: VkBool32,
    pub shaderInt64: VkBool32,
    pub shaderInt16: VkBool32,
    pub shaderResourceResidency: VkBool32,
    pub shaderResourceMinLod: VkBool32,
    pub sparseBinding: VkBool32,
    pub sparseResidencyBuffer: VkBool32,
    pub sparseResidencyImage2D: VkBool32,
    pub sparseResidencyImage3D: VkBool32,
    pub sparseResidency2Samples: VkBool32,
    pub sparseResidency4Samples: VkBool32,
    pub sparseResidency8Samples: VkBool32,
    pub sparseResidency16Samples: VkBool32,
    pub sparseResidencyAliased: VkBool32,
    pub variableMultisampleRate: VkBool32,
    pub inheritedQueries: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceFeatures>() , 220usize ,
               concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceFeatures ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceFeatures>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkPhysicalDeviceFeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                robustBufferAccess as * const _ as usize } , 0usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                robustBufferAccess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                fullDrawIndexUint32 as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                fullDrawIndexUint32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                imageCubeArray as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                imageCubeArray ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                independentBlend as * const _ as usize } , 12usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                independentBlend ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                geometryShader as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                geometryShader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                tessellationShader as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                tessellationShader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sampleRateShading as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sampleRateShading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                dualSrcBlend as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( dualSrcBlend
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) . logicOp as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( logicOp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                multiDrawIndirect as * const _ as usize } , 36usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                multiDrawIndirect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                drawIndirectFirstInstance as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                drawIndirectFirstInstance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) . depthClamp
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( depthClamp )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                depthBiasClamp as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                depthBiasClamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                fillModeNonSolid as * const _ as usize } , 52usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                fillModeNonSolid ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                depthBounds as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( depthBounds
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) . wideLines
                as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( wideLines )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                largePoints as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( largePoints
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) . alphaToOne
                as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( alphaToOne )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                multiViewport as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                multiViewport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                samplerAnisotropy as * const _ as usize } , 76usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                samplerAnisotropy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                textureCompressionETC2 as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                textureCompressionETC2 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                textureCompressionASTC_LDR as * const _ as usize } , 84usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                textureCompressionASTC_LDR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                textureCompressionBC as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                textureCompressionBC ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                occlusionQueryPrecise as * const _ as usize } , 92usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                occlusionQueryPrecise ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                pipelineStatisticsQuery as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                pipelineStatisticsQuery ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                vertexPipelineStoresAndAtomics as * const _ as usize } ,
                100usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                vertexPipelineStoresAndAtomics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                fragmentStoresAndAtomics as * const _ as usize } , 104usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                fragmentStoresAndAtomics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderTessellationAndGeometryPointSize as * const _ as usize }
                , 108usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderTessellationAndGeometryPointSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderImageGatherExtended as * const _ as usize } , 112usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderImageGatherExtended ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderStorageImageExtendedFormats as * const _ as usize } ,
                116usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderStorageImageExtendedFormats ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderStorageImageMultisample as * const _ as usize } ,
                120usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderStorageImageMultisample ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderStorageImageReadWithoutFormat as * const _ as usize } ,
                124usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderStorageImageReadWithoutFormat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderStorageImageWriteWithoutFormat as * const _ as usize } ,
                128usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderStorageImageWriteWithoutFormat ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderUniformBufferArrayDynamicIndexing as * const _ as usize
                } , 132usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderUniformBufferArrayDynamicIndexing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderSampledImageArrayDynamicIndexing as * const _ as usize }
                , 136usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderSampledImageArrayDynamicIndexing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderStorageBufferArrayDynamicIndexing as * const _ as usize
                } , 140usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderStorageBufferArrayDynamicIndexing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderStorageImageArrayDynamicIndexing as * const _ as usize }
                , 144usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderStorageImageArrayDynamicIndexing ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderClipDistance as * const _ as usize } , 148usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderClipDistance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderCullDistance as * const _ as usize } , 152usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderCullDistance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderFloat64 as * const _ as usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderFloat64 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderInt64 as * const _ as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( shaderInt64
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderInt16 as * const _ as usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! ( shaderInt16
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderResourceResidency as * const _ as usize } , 168usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderResourceResidency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                shaderResourceMinLod as * const _ as usize } , 172usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                shaderResourceMinLod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseBinding as * const _ as usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseBinding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseResidencyBuffer as * const _ as usize } , 180usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseResidencyBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseResidencyImage2D as * const _ as usize } , 184usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseResidencyImage2D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseResidencyImage3D as * const _ as usize } , 188usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseResidencyImage3D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseResidency2Samples as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseResidency2Samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseResidency4Samples as * const _ as usize } , 196usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseResidency4Samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseResidency8Samples as * const _ as usize } , 200usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseResidency8Samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseResidency16Samples as * const _ as usize } , 204usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseResidency16Samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                sparseResidencyAliased as * const _ as usize } , 208usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                sparseResidencyAliased ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                variableMultisampleRate as * const _ as usize } , 212usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                variableMultisampleRate ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures ) ) .
                inheritedQueries as * const _ as usize } , 216usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures ) , "::" , stringify ! (
                inheritedQueries ) ));
}
impl Clone for VkPhysicalDeviceFeatures {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkFormatProperties {
    pub linearTilingFeatures: VkFormatFeatureFlags,
    pub optimalTilingFeatures: VkFormatFeatureFlags,
    pub bufferFeatures: VkFormatFeatureFlags,
}
#[test]
fn bindgen_test_layout_VkFormatProperties() {
    assert_eq!(::std::mem::size_of::<VkFormatProperties>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( VkFormatProperties ) ));
    assert_eq! (::std::mem::align_of::<VkFormatProperties>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VkFormatProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFormatProperties ) ) .
                linearTilingFeatures as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkFormatProperties ) ,
                "::" , stringify ! ( linearTilingFeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFormatProperties ) ) .
                optimalTilingFeatures as * const _ as usize } , 4usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkFormatProperties ) ,
                "::" , stringify ! ( optimalTilingFeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFormatProperties ) ) . bufferFeatures
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFormatProperties ) ,
                "::" , stringify ! ( bufferFeatures ) ));
}
impl Clone for VkFormatProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExtent3D {
    pub width: u32,
    pub height: u32,
    pub depth: u32,
}
#[test]
fn bindgen_test_layout_VkExtent3D() {
    assert_eq!(::std::mem::size_of::<VkExtent3D>() , 12usize , concat ! (
               "Size of: " , stringify ! ( VkExtent3D ) ));
    assert_eq! (::std::mem::align_of::<VkExtent3D>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkExtent3D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExtent3D ) ) . width as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkExtent3D ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExtent3D ) ) . height as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkExtent3D ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExtent3D ) ) . depth as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkExtent3D ) , "::" ,
                stringify ! ( depth ) ));
}
impl Clone for VkExtent3D {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageFormatProperties {
    pub maxExtent: VkExtent3D,
    pub maxMipLevels: u32,
    pub maxArrayLayers: u32,
    pub sampleCounts: VkSampleCountFlags,
    pub maxResourceSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkImageFormatProperties() {
    assert_eq!(::std::mem::size_of::<VkImageFormatProperties>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( VkImageFormatProperties ) ));
    assert_eq! (::std::mem::align_of::<VkImageFormatProperties>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkImageFormatProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageFormatProperties ) ) . maxExtent
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageFormatProperties
                ) , "::" , stringify ! ( maxExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageFormatProperties ) ) .
                maxMipLevels as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageFormatProperties
                ) , "::" , stringify ! ( maxMipLevels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageFormatProperties ) ) .
                maxArrayLayers as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageFormatProperties
                ) , "::" , stringify ! ( maxArrayLayers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageFormatProperties ) ) .
                sampleCounts as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageFormatProperties
                ) , "::" , stringify ! ( sampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageFormatProperties ) ) .
                maxResourceSize as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageFormatProperties
                ) , "::" , stringify ! ( maxResourceSize ) ));
}
impl Clone for VkImageFormatProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceLimits {
    pub maxImageDimension1D: u32,
    pub maxImageDimension2D: u32,
    pub maxImageDimension3D: u32,
    pub maxImageDimensionCube: u32,
    pub maxImageArrayLayers: u32,
    pub maxTexelBufferElements: u32,
    pub maxUniformBufferRange: u32,
    pub maxStorageBufferRange: u32,
    pub maxPushConstantsSize: u32,
    pub maxMemoryAllocationCount: u32,
    pub maxSamplerAllocationCount: u32,
    pub bufferImageGranularity: VkDeviceSize,
    pub sparseAddressSpaceSize: VkDeviceSize,
    pub maxBoundDescriptorSets: u32,
    pub maxPerStageDescriptorSamplers: u32,
    pub maxPerStageDescriptorUniformBuffers: u32,
    pub maxPerStageDescriptorStorageBuffers: u32,
    pub maxPerStageDescriptorSampledImages: u32,
    pub maxPerStageDescriptorStorageImages: u32,
    pub maxPerStageDescriptorInputAttachments: u32,
    pub maxPerStageResources: u32,
    pub maxDescriptorSetSamplers: u32,
    pub maxDescriptorSetUniformBuffers: u32,
    pub maxDescriptorSetUniformBuffersDynamic: u32,
    pub maxDescriptorSetStorageBuffers: u32,
    pub maxDescriptorSetStorageBuffersDynamic: u32,
    pub maxDescriptorSetSampledImages: u32,
    pub maxDescriptorSetStorageImages: u32,
    pub maxDescriptorSetInputAttachments: u32,
    pub maxVertexInputAttributes: u32,
    pub maxVertexInputBindings: u32,
    pub maxVertexInputAttributeOffset: u32,
    pub maxVertexInputBindingStride: u32,
    pub maxVertexOutputComponents: u32,
    pub maxTessellationGenerationLevel: u32,
    pub maxTessellationPatchSize: u32,
    pub maxTessellationControlPerVertexInputComponents: u32,
    pub maxTessellationControlPerVertexOutputComponents: u32,
    pub maxTessellationControlPerPatchOutputComponents: u32,
    pub maxTessellationControlTotalOutputComponents: u32,
    pub maxTessellationEvaluationInputComponents: u32,
    pub maxTessellationEvaluationOutputComponents: u32,
    pub maxGeometryShaderInvocations: u32,
    pub maxGeometryInputComponents: u32,
    pub maxGeometryOutputComponents: u32,
    pub maxGeometryOutputVertices: u32,
    pub maxGeometryTotalOutputComponents: u32,
    pub maxFragmentInputComponents: u32,
    pub maxFragmentOutputAttachments: u32,
    pub maxFragmentDualSrcAttachments: u32,
    pub maxFragmentCombinedOutputResources: u32,
    pub maxComputeSharedMemorySize: u32,
    pub maxComputeWorkGroupCount: [u32; 3usize],
    pub maxComputeWorkGroupInvocations: u32,
    pub maxComputeWorkGroupSize: [u32; 3usize],
    pub subPixelPrecisionBits: u32,
    pub subTexelPrecisionBits: u32,
    pub mipmapPrecisionBits: u32,
    pub maxDrawIndexedIndexValue: u32,
    pub maxDrawIndirectCount: u32,
    pub maxSamplerLodBias: f32,
    pub maxSamplerAnisotropy: f32,
    pub maxViewports: u32,
    pub maxViewportDimensions: [u32; 2usize],
    pub viewportBoundsRange: [f32; 2usize],
    pub viewportSubPixelBits: u32,
    pub minMemoryMapAlignment: usize,
    pub minTexelBufferOffsetAlignment: VkDeviceSize,
    pub minUniformBufferOffsetAlignment: VkDeviceSize,
    pub minStorageBufferOffsetAlignment: VkDeviceSize,
    pub minTexelOffset: i32,
    pub maxTexelOffset: u32,
    pub minTexelGatherOffset: i32,
    pub maxTexelGatherOffset: u32,
    pub minInterpolationOffset: f32,
    pub maxInterpolationOffset: f32,
    pub subPixelInterpolationOffsetBits: u32,
    pub maxFramebufferWidth: u32,
    pub maxFramebufferHeight: u32,
    pub maxFramebufferLayers: u32,
    pub framebufferColorSampleCounts: VkSampleCountFlags,
    pub framebufferDepthSampleCounts: VkSampleCountFlags,
    pub framebufferStencilSampleCounts: VkSampleCountFlags,
    pub framebufferNoAttachmentsSampleCounts: VkSampleCountFlags,
    pub maxColorAttachments: u32,
    pub sampledImageColorSampleCounts: VkSampleCountFlags,
    pub sampledImageIntegerSampleCounts: VkSampleCountFlags,
    pub sampledImageDepthSampleCounts: VkSampleCountFlags,
    pub sampledImageStencilSampleCounts: VkSampleCountFlags,
    pub storageImageSampleCounts: VkSampleCountFlags,
    pub maxSampleMaskWords: u32,
    pub timestampComputeAndGraphics: VkBool32,
    pub timestampPeriod: f32,
    pub maxClipDistances: u32,
    pub maxCullDistances: u32,
    pub maxCombinedClipAndCullDistances: u32,
    pub discreteQueuePriorities: u32,
    pub pointSizeRange: [f32; 2usize],
    pub lineWidthRange: [f32; 2usize],
    pub pointSizeGranularity: f32,
    pub lineWidthGranularity: f32,
    pub strictLines: VkBool32,
    pub standardSampleLocations: VkBool32,
    pub optimalBufferCopyOffsetAlignment: VkDeviceSize,
    pub optimalBufferCopyRowPitchAlignment: VkDeviceSize,
    pub nonCoherentAtomSize: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceLimits() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceLimits>() , 504usize ,
               concat ! ( "Size of: " , stringify ! ( VkPhysicalDeviceLimits )
               ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceLimits>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkPhysicalDeviceLimits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxImageDimension1D as * const _ as usize } , 0usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxImageDimension1D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxImageDimension2D as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxImageDimension2D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxImageDimension3D as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxImageDimension3D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxImageDimensionCube as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxImageDimensionCube ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxImageArrayLayers as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxImageArrayLayers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTexelBufferElements as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxTexelBufferElements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxUniformBufferRange as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxUniformBufferRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxStorageBufferRange as * const _ as usize } , 28usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxStorageBufferRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxPushConstantsSize as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxPushConstantsSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxMemoryAllocationCount as * const _ as usize } , 36usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxMemoryAllocationCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxSamplerAllocationCount as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxSamplerAllocationCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                bufferImageGranularity as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( bufferImageGranularity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                sparseAddressSpaceSize as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( sparseAddressSpaceSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxBoundDescriptorSets as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxBoundDescriptorSets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxPerStageDescriptorSamplers as * const _ as usize } ,
                68usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxPerStageDescriptorSamplers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxPerStageDescriptorUniformBuffers as * const _ as usize } ,
                72usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxPerStageDescriptorUniformBuffers )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxPerStageDescriptorStorageBuffers as * const _ as usize } ,
                76usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxPerStageDescriptorStorageBuffers )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxPerStageDescriptorSampledImages as * const _ as usize } ,
                80usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxPerStageDescriptorSampledImages )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxPerStageDescriptorStorageImages as * const _ as usize } ,
                84usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxPerStageDescriptorStorageImages )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxPerStageDescriptorInputAttachments as * const _ as usize }
                , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxPerStageDescriptorInputAttachments
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxPerStageResources as * const _ as usize } , 92usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxPerStageResources ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDescriptorSetSamplers as * const _ as usize } , 96usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDescriptorSetSamplers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDescriptorSetUniformBuffers as * const _ as usize } ,
                100usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDescriptorSetUniformBuffers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDescriptorSetUniformBuffersDynamic as * const _ as usize }
                , 104usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDescriptorSetUniformBuffersDynamic
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDescriptorSetStorageBuffers as * const _ as usize } ,
                108usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDescriptorSetStorageBuffers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDescriptorSetStorageBuffersDynamic as * const _ as usize }
                , 112usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDescriptorSetStorageBuffersDynamic
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDescriptorSetSampledImages as * const _ as usize } ,
                116usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDescriptorSetSampledImages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDescriptorSetStorageImages as * const _ as usize } ,
                120usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDescriptorSetStorageImages ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDescriptorSetInputAttachments as * const _ as usize } ,
                124usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDescriptorSetInputAttachments )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxVertexInputAttributes as * const _ as usize } , 128usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxVertexInputAttributes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxVertexInputBindings as * const _ as usize } , 132usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxVertexInputBindings ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxVertexInputAttributeOffset as * const _ as usize } ,
                136usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxVertexInputAttributeOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxVertexInputBindingStride as * const _ as usize } , 140usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxVertexInputBindingStride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxVertexOutputComponents as * const _ as usize } , 144usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxVertexOutputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTessellationGenerationLevel as * const _ as usize } ,
                148usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxTessellationGenerationLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTessellationPatchSize as * const _ as usize } , 152usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxTessellationPatchSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTessellationControlPerVertexInputComponents as * const _ as
                usize } , 156usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! (
                maxTessellationControlPerVertexInputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTessellationControlPerVertexOutputComponents as * const _
                as usize } , 160usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! (
                maxTessellationControlPerVertexOutputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTessellationControlPerPatchOutputComponents as * const _ as
                usize } , 164usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! (
                maxTessellationControlPerPatchOutputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTessellationControlTotalOutputComponents as * const _ as
                usize } , 168usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! (
                maxTessellationControlTotalOutputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTessellationEvaluationInputComponents as * const _ as usize
                } , 172usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! (
                maxTessellationEvaluationInputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTessellationEvaluationOutputComponents as * const _ as
                usize } , 176usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! (
                maxTessellationEvaluationOutputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxGeometryShaderInvocations as * const _ as usize } ,
                180usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxGeometryShaderInvocations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxGeometryInputComponents as * const _ as usize } , 184usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxGeometryInputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxGeometryOutputComponents as * const _ as usize } , 188usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxGeometryOutputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxGeometryOutputVertices as * const _ as usize } , 192usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxGeometryOutputVertices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxGeometryTotalOutputComponents as * const _ as usize } ,
                196usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxGeometryTotalOutputComponents )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxFragmentInputComponents as * const _ as usize } , 200usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxFragmentInputComponents ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxFragmentOutputAttachments as * const _ as usize } ,
                204usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxFragmentOutputAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxFragmentDualSrcAttachments as * const _ as usize } ,
                208usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxFragmentDualSrcAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxFragmentCombinedOutputResources as * const _ as usize } ,
                212usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxFragmentCombinedOutputResources )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxComputeSharedMemorySize as * const _ as usize } , 216usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxComputeSharedMemorySize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxComputeWorkGroupCount as * const _ as usize } , 220usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxComputeWorkGroupCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxComputeWorkGroupInvocations as * const _ as usize } ,
                232usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxComputeWorkGroupInvocations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxComputeWorkGroupSize as * const _ as usize } , 236usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxComputeWorkGroupSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                subPixelPrecisionBits as * const _ as usize } , 248usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( subPixelPrecisionBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                subTexelPrecisionBits as * const _ as usize } , 252usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( subTexelPrecisionBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                mipmapPrecisionBits as * const _ as usize } , 256usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( mipmapPrecisionBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDrawIndexedIndexValue as * const _ as usize } , 260usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDrawIndexedIndexValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxDrawIndirectCount as * const _ as usize } , 264usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxDrawIndirectCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxSamplerLodBias as * const _ as usize } , 268usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxSamplerLodBias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxSamplerAnisotropy as * const _ as usize } , 272usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxSamplerAnisotropy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) . maxViewports
                as * const _ as usize } , 276usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxViewports ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxViewportDimensions as * const _ as usize } , 280usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxViewportDimensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                viewportBoundsRange as * const _ as usize } , 288usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( viewportBoundsRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                viewportSubPixelBits as * const _ as usize } , 296usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( viewportSubPixelBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                minMemoryMapAlignment as * const _ as usize } , 304usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( minMemoryMapAlignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                minTexelBufferOffsetAlignment as * const _ as usize } ,
                312usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( minTexelBufferOffsetAlignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                minUniformBufferOffsetAlignment as * const _ as usize } ,
                320usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( minUniformBufferOffsetAlignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                minStorageBufferOffsetAlignment as * const _ as usize } ,
                328usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( minStorageBufferOffsetAlignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                minTexelOffset as * const _ as usize } , 336usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( minTexelOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTexelOffset as * const _ as usize } , 340usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxTexelOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                minTexelGatherOffset as * const _ as usize } , 344usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( minTexelGatherOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxTexelGatherOffset as * const _ as usize } , 348usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxTexelGatherOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                minInterpolationOffset as * const _ as usize } , 352usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( minInterpolationOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxInterpolationOffset as * const _ as usize } , 356usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxInterpolationOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                subPixelInterpolationOffsetBits as * const _ as usize } ,
                360usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( subPixelInterpolationOffsetBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxFramebufferWidth as * const _ as usize } , 364usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxFramebufferWidth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxFramebufferHeight as * const _ as usize } , 368usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxFramebufferHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxFramebufferLayers as * const _ as usize } , 372usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxFramebufferLayers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                framebufferColorSampleCounts as * const _ as usize } ,
                376usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( framebufferColorSampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                framebufferDepthSampleCounts as * const _ as usize } ,
                380usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( framebufferDepthSampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                framebufferStencilSampleCounts as * const _ as usize } ,
                384usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( framebufferStencilSampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                framebufferNoAttachmentsSampleCounts as * const _ as usize } ,
                388usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( framebufferNoAttachmentsSampleCounts
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxColorAttachments as * const _ as usize } , 392usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxColorAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                sampledImageColorSampleCounts as * const _ as usize } ,
                396usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( sampledImageColorSampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                sampledImageIntegerSampleCounts as * const _ as usize } ,
                400usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( sampledImageIntegerSampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                sampledImageDepthSampleCounts as * const _ as usize } ,
                404usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( sampledImageDepthSampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                sampledImageStencilSampleCounts as * const _ as usize } ,
                408usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( sampledImageStencilSampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                storageImageSampleCounts as * const _ as usize } , 412usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( storageImageSampleCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxSampleMaskWords as * const _ as usize } , 416usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxSampleMaskWords ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                timestampComputeAndGraphics as * const _ as usize } , 420usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( timestampComputeAndGraphics ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                timestampPeriod as * const _ as usize } , 424usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( timestampPeriod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxClipDistances as * const _ as usize } , 428usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxClipDistances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxCullDistances as * const _ as usize } , 432usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxCullDistances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                maxCombinedClipAndCullDistances as * const _ as usize } ,
                436usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( maxCombinedClipAndCullDistances ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                discreteQueuePriorities as * const _ as usize } , 440usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( discreteQueuePriorities ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                pointSizeRange as * const _ as usize } , 444usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( pointSizeRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                lineWidthRange as * const _ as usize } , 452usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( lineWidthRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                pointSizeGranularity as * const _ as usize } , 460usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( pointSizeGranularity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                lineWidthGranularity as * const _ as usize } , 464usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( lineWidthGranularity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) . strictLines
                as * const _ as usize } , 468usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( strictLines ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                standardSampleLocations as * const _ as usize } , 472usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( standardSampleLocations ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                optimalBufferCopyOffsetAlignment as * const _ as usize } ,
                480usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( optimalBufferCopyOffsetAlignment )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                optimalBufferCopyRowPitchAlignment as * const _ as usize } ,
                488usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( optimalBufferCopyRowPitchAlignment )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceLimits ) ) .
                nonCoherentAtomSize as * const _ as usize } , 496usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkPhysicalDeviceLimits
                ) , "::" , stringify ! ( nonCoherentAtomSize ) ));
}
impl Clone for VkPhysicalDeviceLimits {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceSparseProperties {
    pub residencyStandard2DBlockShape: VkBool32,
    pub residencyStandard2DMultisampleBlockShape: VkBool32,
    pub residencyStandard3DBlockShape: VkBool32,
    pub residencyAlignedMipSize: VkBool32,
    pub residencyNonResidentStrict: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSparseProperties() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceSparseProperties>() ,
               20usize , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceSparseProperties )
               ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceSparseProperties>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceSparseProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceSparseProperties ) ) .
                residencyStandard2DBlockShape as * const _ as usize } , 0usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseProperties ) , "::" , stringify ! (
                residencyStandard2DBlockShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceSparseProperties ) ) .
                residencyStandard2DMultisampleBlockShape as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseProperties ) , "::" , stringify ! (
                residencyStandard2DMultisampleBlockShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceSparseProperties ) ) .
                residencyStandard3DBlockShape as * const _ as usize } , 8usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseProperties ) , "::" , stringify ! (
                residencyStandard3DBlockShape ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceSparseProperties ) ) .
                residencyAlignedMipSize as * const _ as usize } , 12usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseProperties ) , "::" , stringify ! (
                residencyAlignedMipSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceSparseProperties ) ) .
                residencyNonResidentStrict as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseProperties ) , "::" , stringify ! (
                residencyNonResidentStrict ) ));
}
impl Clone for VkPhysicalDeviceSparseProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct VkPhysicalDeviceProperties {
    pub apiVersion: u32,
    pub driverVersion: u32,
    pub vendorID: u32,
    pub deviceID: u32,
    pub deviceType: VkPhysicalDeviceType,
    pub deviceName: [::std::os::raw::c_char; 256usize],
    pub pipelineCacheUUID: [u8; 16usize],
    pub limits: VkPhysicalDeviceLimits,
    pub sparseProperties: VkPhysicalDeviceSparseProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProperties() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceProperties>() , 824usize
               , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceProperties ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceProperties>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkPhysicalDeviceProperties )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) .
                apiVersion as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! ( apiVersion
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) .
                driverVersion as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! (
                driverVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) . vendorID
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! ( vendorID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) . deviceID
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! ( deviceID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) .
                deviceType as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! ( deviceType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) .
                deviceName as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! ( deviceName
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) .
                pipelineCacheUUID as * const _ as usize } , 276usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! (
                pipelineCacheUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) . limits
                as * const _ as usize } , 296usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! ( limits )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties ) ) .
                sparseProperties as * const _ as usize } , 800usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties ) , "::" , stringify ! (
                sparseProperties ) ));
}
impl Clone for VkPhysicalDeviceProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkQueueFamilyProperties {
    pub queueFlags: VkQueueFlags,
    pub queueCount: u32,
    pub timestampValidBits: u32,
    pub minImageTransferGranularity: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyProperties() {
    assert_eq!(::std::mem::size_of::<VkQueueFamilyProperties>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( VkQueueFamilyProperties ) ));
    assert_eq! (::std::mem::align_of::<VkQueueFamilyProperties>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkQueueFamilyProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueueFamilyProperties ) ) . queueFlags
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkQueueFamilyProperties
                ) , "::" , stringify ! ( queueFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueueFamilyProperties ) ) . queueCount
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkQueueFamilyProperties
                ) , "::" , stringify ! ( queueCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueueFamilyProperties ) ) .
                timestampValidBits as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkQueueFamilyProperties
                ) , "::" , stringify ! ( timestampValidBits ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueueFamilyProperties ) ) .
                minImageTransferGranularity as * const _ as usize } , 12usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VkQueueFamilyProperties
                ) , "::" , stringify ! ( minImageTransferGranularity ) ));
}
impl Clone for VkQueueFamilyProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryType {
    pub propertyFlags: VkMemoryPropertyFlags,
    pub heapIndex: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryType() {
    assert_eq!(::std::mem::size_of::<VkMemoryType>() , 8usize , concat ! (
               "Size of: " , stringify ! ( VkMemoryType ) ));
    assert_eq! (::std::mem::align_of::<VkMemoryType>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkMemoryType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryType ) ) . propertyFlags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryType ) , "::" ,
                stringify ! ( propertyFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryType ) ) . heapIndex as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryType ) , "::" ,
                stringify ! ( heapIndex ) ));
}
impl Clone for VkMemoryType {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryHeap {
    pub size: VkDeviceSize,
    pub flags: VkMemoryHeapFlags,
}
#[test]
fn bindgen_test_layout_VkMemoryHeap() {
    assert_eq!(::std::mem::size_of::<VkMemoryHeap>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VkMemoryHeap ) ));
    assert_eq! (::std::mem::align_of::<VkMemoryHeap>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VkMemoryHeap ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryHeap ) ) . size as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryHeap ) , "::" ,
                stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryHeap ) ) . flags as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryHeap ) , "::" ,
                stringify ! ( flags ) ));
}
impl Clone for VkMemoryHeap {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceMemoryProperties {
    pub memoryTypeCount: u32,
    pub memoryTypes: [VkMemoryType; 32usize],
    pub memoryHeapCount: u32,
    pub memoryHeaps: [VkMemoryHeap; 16usize],
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryProperties() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceMemoryProperties>() ,
               520usize , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceMemoryProperties )
               ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceMemoryProperties>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceMemoryProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMemoryProperties ) ) .
                memoryTypeCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMemoryProperties ) , "::" , stringify ! (
                memoryTypeCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMemoryProperties ) ) .
                memoryTypes as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMemoryProperties ) , "::" , stringify ! (
                memoryTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMemoryProperties ) ) .
                memoryHeapCount as * const _ as usize } , 260usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMemoryProperties ) , "::" , stringify ! (
                memoryHeapCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMemoryProperties ) ) .
                memoryHeaps as * const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMemoryProperties ) , "::" , stringify ! (
                memoryHeaps ) ));
}
impl Clone for VkPhysicalDeviceMemoryProperties {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkVoidFunction = ::std::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceQueueCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceQueueCreateFlags,
    pub queueFamilyIndex: u32,
    pub queueCount: u32,
    pub pQueuePriorities: *const f32,
}
#[test]
fn bindgen_test_layout_VkDeviceQueueCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkDeviceQueueCreateInfo>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDeviceQueueCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceQueueCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDeviceQueueCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceQueueCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceQueueCreateInfo
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceQueueCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceQueueCreateInfo
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceQueueCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceQueueCreateInfo
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceQueueCreateInfo ) ) .
                queueFamilyIndex as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkDeviceQueueCreateInfo
                ) , "::" , stringify ! ( queueFamilyIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceQueueCreateInfo ) ) . queueCount
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceQueueCreateInfo
                ) , "::" , stringify ! ( queueCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceQueueCreateInfo ) ) .
                pQueuePriorities as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkDeviceQueueCreateInfo
                ) , "::" , stringify ! ( pQueuePriorities ) ));
}
impl Clone for VkDeviceQueueCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDeviceCreateFlags,
    pub queueCreateInfoCount: u32,
    pub pQueueCreateInfos: *const VkDeviceQueueCreateInfo,
    pub enabledLayerCount: u32,
    pub ppEnabledLayerNames: *const *const ::std::os::raw::c_char,
    pub enabledExtensionCount: u32,
    pub ppEnabledExtensionNames: *const *const ::std::os::raw::c_char,
    pub pEnabledFeatures: *const VkPhysicalDeviceFeatures,
}
#[test]
fn bindgen_test_layout_VkDeviceCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkDeviceCreateInfo>() , 72usize , concat
               ! ( "Size of: " , stringify ! ( VkDeviceCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceCreateInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkDeviceCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) . sType as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) . pNext as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) .
                queueCreateInfoCount as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( queueCreateInfoCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) .
                pQueueCreateInfos as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( pQueueCreateInfos ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) .
                enabledLayerCount as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( enabledLayerCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) .
                ppEnabledLayerNames as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( ppEnabledLayerNames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) .
                enabledExtensionCount as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( enabledExtensionCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) .
                ppEnabledExtensionNames as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( ppEnabledExtensionNames ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceCreateInfo ) ) . pEnabledFeatures
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceCreateInfo ) ,
                "::" , stringify ! ( pEnabledFeatures ) ));
}
impl Clone for VkDeviceCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct VkExtensionProperties {
    pub extensionName: [::std::os::raw::c_char; 256usize],
    pub specVersion: u32,
}
#[test]
fn bindgen_test_layout_VkExtensionProperties() {
    assert_eq!(::std::mem::size_of::<VkExtensionProperties>() , 260usize ,
               concat ! ( "Size of: " , stringify ! ( VkExtensionProperties )
               ));
    assert_eq! (::std::mem::align_of::<VkExtensionProperties>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkExtensionProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExtensionProperties ) ) . extensionName
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkExtensionProperties )
                , "::" , stringify ! ( extensionName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExtensionProperties ) ) . specVersion
                as * const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( VkExtensionProperties )
                , "::" , stringify ! ( specVersion ) ));
}
impl Clone for VkExtensionProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct VkLayerProperties {
    pub layerName: [::std::os::raw::c_char; 256usize],
    pub specVersion: u32,
    pub implementationVersion: u32,
    pub description: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_VkLayerProperties() {
    assert_eq!(::std::mem::size_of::<VkLayerProperties>() , 520usize , concat
               ! ( "Size of: " , stringify ! ( VkLayerProperties ) ));
    assert_eq! (::std::mem::align_of::<VkLayerProperties>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VkLayerProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkLayerProperties ) ) . layerName as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkLayerProperties ) ,
                "::" , stringify ! ( layerName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkLayerProperties ) ) . specVersion as *
                const _ as usize } , 256usize , concat ! (
                "Alignment of field: " , stringify ! ( VkLayerProperties ) ,
                "::" , stringify ! ( specVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkLayerProperties ) ) .
                implementationVersion as * const _ as usize } , 260usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkLayerProperties ) ,
                "::" , stringify ! ( implementationVersion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkLayerProperties ) ) . description as *
                const _ as usize } , 264usize , concat ! (
                "Alignment of field: " , stringify ! ( VkLayerProperties ) ,
                "::" , stringify ! ( description ) ));
}
impl Clone for VkLayerProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSubmitInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub pWaitDstStageMask: *const VkPipelineStageFlags,
    pub commandBufferCount: u32,
    pub pCommandBuffers: *const VkCommandBuffer,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphores: *const VkSemaphore,
}
#[test]
fn bindgen_test_layout_VkSubmitInfo() {
    assert_eq!(::std::mem::size_of::<VkSubmitInfo>() , 72usize , concat ! (
               "Size of: " , stringify ! ( VkSubmitInfo ) ));
    assert_eq! (::std::mem::align_of::<VkSubmitInfo>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VkSubmitInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . sType as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . pNext as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . waitSemaphoreCount as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( waitSemaphoreCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . pWaitSemaphores as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( pWaitSemaphores ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . pWaitDstStageMask as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( pWaitDstStageMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . commandBufferCount as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( commandBufferCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . pCommandBuffers as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( pCommandBuffers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . signalSemaphoreCount
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( signalSemaphoreCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubmitInfo ) ) . pSignalSemaphores as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubmitInfo ) , "::" ,
                stringify ! ( pSignalSemaphores ) ));
}
impl Clone for VkSubmitInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub allocationSize: VkDeviceSize,
    pub memoryTypeIndex: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryAllocateInfo() {
    assert_eq!(::std::mem::size_of::<VkMemoryAllocateInfo>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( VkMemoryAllocateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkMemoryAllocateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkMemoryAllocateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryAllocateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryAllocateInfo )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryAllocateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryAllocateInfo )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryAllocateInfo ) ) . allocationSize
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryAllocateInfo )
                , "::" , stringify ! ( allocationSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryAllocateInfo ) ) .
                memoryTypeIndex as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryAllocateInfo )
                , "::" , stringify ! ( memoryTypeIndex ) ));
}
impl Clone for VkMemoryAllocateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMappedMemoryRange {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkMappedMemoryRange() {
    assert_eq!(::std::mem::size_of::<VkMappedMemoryRange>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( VkMappedMemoryRange ) ));
    assert_eq! (::std::mem::align_of::<VkMappedMemoryRange>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkMappedMemoryRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMappedMemoryRange ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMappedMemoryRange ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMappedMemoryRange ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMappedMemoryRange ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMappedMemoryRange ) ) . memory as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMappedMemoryRange ) ,
                "::" , stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMappedMemoryRange ) ) . offset as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMappedMemoryRange ) ,
                "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMappedMemoryRange ) ) . size as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMappedMemoryRange ) ,
                "::" , stringify ! ( size ) ));
}
impl Clone for VkMappedMemoryRange {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryRequirements {
    pub size: VkDeviceSize,
    pub alignment: VkDeviceSize,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryRequirements() {
    assert_eq!(::std::mem::size_of::<VkMemoryRequirements>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( VkMemoryRequirements )
               ));
    assert_eq! (::std::mem::align_of::<VkMemoryRequirements>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkMemoryRequirements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryRequirements ) ) . size as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryRequirements )
                , "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryRequirements ) ) . alignment as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryRequirements )
                , "::" , stringify ! ( alignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryRequirements ) ) . memoryTypeBits
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryRequirements )
                , "::" , stringify ! ( memoryTypeBits ) ));
}
impl Clone for VkMemoryRequirements {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseImageFormatProperties {
    pub aspectMask: VkImageAspectFlags,
    pub imageGranularity: VkExtent3D,
    pub flags: VkSparseImageFormatFlags,
}
#[test]
fn bindgen_test_layout_VkSparseImageFormatProperties() {
    assert_eq!(::std::mem::size_of::<VkSparseImageFormatProperties>() ,
               20usize , concat ! (
               "Size of: " , stringify ! ( VkSparseImageFormatProperties ) ));
    assert_eq! (::std::mem::align_of::<VkSparseImageFormatProperties>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( VkSparseImageFormatProperties
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageFormatProperties ) ) .
                aspectMask as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageFormatProperties ) , "::" , stringify ! (
                aspectMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageFormatProperties ) ) .
                imageGranularity as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageFormatProperties ) , "::" , stringify ! (
                imageGranularity ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageFormatProperties ) ) . flags
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageFormatProperties ) , "::" , stringify ! ( flags )
                ));
}
impl Clone for VkSparseImageFormatProperties {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseImageMemoryRequirements {
    pub formatProperties: VkSparseImageFormatProperties,
    pub imageMipTailFirstLod: u32,
    pub imageMipTailSize: VkDeviceSize,
    pub imageMipTailOffset: VkDeviceSize,
    pub imageMipTailStride: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryRequirements() {
    assert_eq!(::std::mem::size_of::<VkSparseImageMemoryRequirements>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( VkSparseImageMemoryRequirements )
               ));
    assert_eq! (::std::mem::align_of::<VkSparseImageMemoryRequirements>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkSparseImageMemoryRequirements ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryRequirements ) ) .
                formatProperties as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryRequirements ) , "::" , stringify ! (
                formatProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryRequirements ) ) .
                imageMipTailFirstLod as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryRequirements ) , "::" , stringify ! (
                imageMipTailFirstLod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryRequirements ) ) .
                imageMipTailSize as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryRequirements ) , "::" , stringify ! (
                imageMipTailSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryRequirements ) ) .
                imageMipTailOffset as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryRequirements ) , "::" , stringify ! (
                imageMipTailOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryRequirements ) ) .
                imageMipTailStride as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryRequirements ) , "::" , stringify ! (
                imageMipTailStride ) ));
}
impl Clone for VkSparseImageMemoryRequirements {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseMemoryBind {
    pub resourceOffset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
}
#[test]
fn bindgen_test_layout_VkSparseMemoryBind() {
    assert_eq!(::std::mem::size_of::<VkSparseMemoryBind>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( VkSparseMemoryBind ) ));
    assert_eq! (::std::mem::align_of::<VkSparseMemoryBind>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkSparseMemoryBind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseMemoryBind ) ) . resourceOffset
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseMemoryBind ) ,
                "::" , stringify ! ( resourceOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseMemoryBind ) ) . size as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseMemoryBind ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseMemoryBind ) ) . memory as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseMemoryBind ) ,
                "::" , stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseMemoryBind ) ) . memoryOffset as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseMemoryBind ) ,
                "::" , stringify ! ( memoryOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseMemoryBind ) ) . flags as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseMemoryBind ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for VkSparseMemoryBind {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseBufferMemoryBindInfo {
    pub buffer: VkBuffer,
    pub bindCount: u32,
    pub pBinds: *const VkSparseMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseBufferMemoryBindInfo() {
    assert_eq!(::std::mem::size_of::<VkSparseBufferMemoryBindInfo>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( VkSparseBufferMemoryBindInfo ) ));
    assert_eq! (::std::mem::align_of::<VkSparseBufferMemoryBindInfo>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkSparseBufferMemoryBindInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseBufferMemoryBindInfo ) ) . buffer
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseBufferMemoryBindInfo ) , "::" , stringify ! ( buffer )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseBufferMemoryBindInfo ) ) .
                bindCount as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseBufferMemoryBindInfo ) , "::" , stringify ! (
                bindCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseBufferMemoryBindInfo ) ) . pBinds
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseBufferMemoryBindInfo ) , "::" , stringify ! ( pBinds )
                ));
}
impl Clone for VkSparseBufferMemoryBindInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseImageOpaqueMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: u32,
    pub pBinds: *const VkSparseMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseImageOpaqueMemoryBindInfo() {
    assert_eq!(::std::mem::size_of::<VkSparseImageOpaqueMemoryBindInfo>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkSparseImageOpaqueMemoryBindInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkSparseImageOpaqueMemoryBindInfo>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkSparseImageOpaqueMemoryBindInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageOpaqueMemoryBindInfo ) ) .
                image as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageOpaqueMemoryBindInfo ) , "::" , stringify ! (
                image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageOpaqueMemoryBindInfo ) ) .
                bindCount as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageOpaqueMemoryBindInfo ) , "::" , stringify ! (
                bindCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageOpaqueMemoryBindInfo ) ) .
                pBinds as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageOpaqueMemoryBindInfo ) , "::" , stringify ! (
                pBinds ) ));
}
impl Clone for VkSparseImageOpaqueMemoryBindInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageSubresource {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: u32,
    pub arrayLayer: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresource() {
    assert_eq!(::std::mem::size_of::<VkImageSubresource>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( VkImageSubresource ) ));
    assert_eq! (::std::mem::align_of::<VkImageSubresource>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VkImageSubresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresource ) ) . aspectMask as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageSubresource ) ,
                "::" , stringify ! ( aspectMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresource ) ) . mipLevel as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageSubresource ) ,
                "::" , stringify ! ( mipLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresource ) ) . arrayLayer as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageSubresource ) ,
                "::" , stringify ! ( arrayLayer ) ));
}
impl Clone for VkImageSubresource {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkOffset3D {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
#[test]
fn bindgen_test_layout_VkOffset3D() {
    assert_eq!(::std::mem::size_of::<VkOffset3D>() , 12usize , concat ! (
               "Size of: " , stringify ! ( VkOffset3D ) ));
    assert_eq! (::std::mem::align_of::<VkOffset3D>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkOffset3D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkOffset3D ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkOffset3D ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkOffset3D ) ) . y as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkOffset3D ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkOffset3D ) ) . z as * const _ as usize
                } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkOffset3D ) , "::" ,
                stringify ! ( z ) ));
}
impl Clone for VkOffset3D {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseImageMemoryBind {
    pub subresource: VkImageSubresource,
    pub offset: VkOffset3D,
    pub extent: VkExtent3D,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub flags: VkSparseMemoryBindFlags,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryBind() {
    assert_eq!(::std::mem::size_of::<VkSparseImageMemoryBind>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( VkSparseImageMemoryBind ) ));
    assert_eq! (::std::mem::align_of::<VkSparseImageMemoryBind>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSparseImageMemoryBind ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBind ) ) . subresource
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseImageMemoryBind
                ) , "::" , stringify ! ( subresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBind ) ) . offset as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseImageMemoryBind
                ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBind ) ) . extent as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseImageMemoryBind
                ) , "::" , stringify ! ( extent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBind ) ) . memory as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseImageMemoryBind
                ) , "::" , stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBind ) ) .
                memoryOffset as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseImageMemoryBind
                ) , "::" , stringify ! ( memoryOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBind ) ) . flags as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSparseImageMemoryBind
                ) , "::" , stringify ! ( flags ) ));
}
impl Clone for VkSparseImageMemoryBind {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseImageMemoryBindInfo {
    pub image: VkImage,
    pub bindCount: u32,
    pub pBinds: *const VkSparseImageMemoryBind,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryBindInfo() {
    assert_eq!(::std::mem::size_of::<VkSparseImageMemoryBindInfo>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( VkSparseImageMemoryBindInfo ) ));
    assert_eq! (::std::mem::align_of::<VkSparseImageMemoryBindInfo>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkSparseImageMemoryBindInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBindInfo ) ) . image
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryBindInfo ) , "::" , stringify ! ( image )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBindInfo ) ) .
                bindCount as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryBindInfo ) , "::" , stringify ! ( bindCount
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryBindInfo ) ) . pBinds
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryBindInfo ) , "::" , stringify ! ( pBinds )
                ));
}
impl Clone for VkSparseImageMemoryBindInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBindSparseInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub bufferBindCount: u32,
    pub pBufferBinds: *const VkSparseBufferMemoryBindInfo,
    pub imageOpaqueBindCount: u32,
    pub pImageOpaqueBinds: *const VkSparseImageOpaqueMemoryBindInfo,
    pub imageBindCount: u32,
    pub pImageBinds: *const VkSparseImageMemoryBindInfo,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphores: *const VkSemaphore,
}
#[test]
fn bindgen_test_layout_VkBindSparseInfo() {
    assert_eq!(::std::mem::size_of::<VkBindSparseInfo>() , 96usize , concat !
               ( "Size of: " , stringify ! ( VkBindSparseInfo ) ));
    assert_eq! (::std::mem::align_of::<VkBindSparseInfo>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VkBindSparseInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . sType as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . pNext as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . waitSemaphoreCount
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( waitSemaphoreCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . pWaitSemaphores as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( pWaitSemaphores ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . bufferBindCount as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( bufferBindCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . pBufferBinds as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( pBufferBinds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) .
                imageOpaqueBindCount as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( imageOpaqueBindCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . pImageOpaqueBinds
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( pImageOpaqueBinds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . imageBindCount as
                * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( imageBindCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . pImageBinds as *
                const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( pImageBinds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) .
                signalSemaphoreCount as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( signalSemaphoreCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindSparseInfo ) ) . pSignalSemaphores
                as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBindSparseInfo ) ,
                "::" , stringify ! ( pSignalSemaphores ) ));
}
impl Clone for VkBindSparseInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkFenceCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFenceCreateFlags,
}
#[test]
fn bindgen_test_layout_VkFenceCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkFenceCreateInfo>() , 24usize , concat !
               ( "Size of: " , stringify ! ( VkFenceCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkFenceCreateInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkFenceCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFenceCreateInfo ) ) . sType as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFenceCreateInfo ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFenceCreateInfo ) ) . pNext as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFenceCreateInfo ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFenceCreateInfo ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFenceCreateInfo ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for VkFenceCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSemaphoreCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSemaphoreCreateFlags,
}
#[test]
fn bindgen_test_layout_VkSemaphoreCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkSemaphoreCreateInfo>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( VkSemaphoreCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkSemaphoreCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSemaphoreCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSemaphoreCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSemaphoreCreateInfo )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSemaphoreCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSemaphoreCreateInfo )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSemaphoreCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSemaphoreCreateInfo )
                , "::" , stringify ! ( flags ) ));
}
impl Clone for VkSemaphoreCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkEventCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkEventCreateFlags,
}
#[test]
fn bindgen_test_layout_VkEventCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkEventCreateInfo>() , 24usize , concat !
               ( "Size of: " , stringify ! ( VkEventCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkEventCreateInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkEventCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkEventCreateInfo ) ) . sType as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkEventCreateInfo ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkEventCreateInfo ) ) . pNext as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkEventCreateInfo ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkEventCreateInfo ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkEventCreateInfo ) ,
                "::" , stringify ! ( flags ) ));
}
impl Clone for VkEventCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkQueryPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkQueryPoolCreateFlags,
    pub queryType: VkQueryType,
    pub queryCount: u32,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
#[test]
fn bindgen_test_layout_VkQueryPoolCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkQueryPoolCreateInfo>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( VkQueryPoolCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkQueryPoolCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkQueryPoolCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueryPoolCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkQueryPoolCreateInfo )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueryPoolCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkQueryPoolCreateInfo )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueryPoolCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkQueryPoolCreateInfo )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueryPoolCreateInfo ) ) . queryType as
                * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkQueryPoolCreateInfo )
                , "::" , stringify ! ( queryType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueryPoolCreateInfo ) ) . queryCount as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkQueryPoolCreateInfo )
                , "::" , stringify ! ( queryCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueryPoolCreateInfo ) ) .
                pipelineStatistics as * const _ as usize } , 28usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkQueryPoolCreateInfo )
                , "::" , stringify ! ( pipelineStatistics ) ));
}
impl Clone for VkQueryPoolCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub size: VkDeviceSize,
    pub usage: VkBufferUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBufferCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkBufferCreateInfo>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( VkBufferCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkBufferCreateInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkBufferCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCreateInfo ) ) . sType as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCreateInfo ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCreateInfo ) ) . pNext as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCreateInfo ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCreateInfo ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCreateInfo ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCreateInfo ) ) . size as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCreateInfo ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCreateInfo ) ) . usage as * const
                _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCreateInfo ) ,
                "::" , stringify ! ( usage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCreateInfo ) ) . sharingMode as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCreateInfo ) ,
                "::" , stringify ! ( sharingMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCreateInfo ) ) .
                queueFamilyIndexCount as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCreateInfo ) ,
                "::" , stringify ! ( queueFamilyIndexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCreateInfo ) ) .
                pQueueFamilyIndices as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkBufferCreateInfo ) ,
                "::" , stringify ! ( pQueueFamilyIndices ) ));
}
impl Clone for VkBufferCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBufferViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferViewCreateFlags,
    pub buffer: VkBuffer,
    pub format: VkFormat,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferViewCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkBufferViewCreateInfo>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( VkBufferViewCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkBufferViewCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkBufferViewCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferViewCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferViewCreateInfo
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferViewCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferViewCreateInfo
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferViewCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferViewCreateInfo
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferViewCreateInfo ) ) . buffer as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferViewCreateInfo
                ) , "::" , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferViewCreateInfo ) ) . format as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferViewCreateInfo
                ) , "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferViewCreateInfo ) ) . offset as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferViewCreateInfo
                ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferViewCreateInfo ) ) . range as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferViewCreateInfo
                ) , "::" , stringify ! ( range ) ));
}
impl Clone for VkBufferViewCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageCreateFlags,
    pub imageType: VkImageType,
    pub format: VkFormat,
    pub extent: VkExtent3D,
    pub mipLevels: u32,
    pub arrayLayers: u32,
    pub samples: VkSampleCountFlagBits,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub sharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
    pub initialLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkImageCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkImageCreateInfo>() , 88usize , concat !
               ( "Size of: " , stringify ! ( VkImageCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkImageCreateInfo>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkImageCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . sType as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . pNext as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . flags as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . imageType as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( imageType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . format as * const
                _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . extent as * const
                _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( extent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . mipLevels as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( mipLevels ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . arrayLayers as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( arrayLayers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . samples as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . tiling as * const
                _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( tiling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . usage as * const
                _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( usage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . sharingMode as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( sharingMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) .
                queueFamilyIndexCount as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( queueFamilyIndexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) .
                pQueueFamilyIndices as * const _ as usize } , 72usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( pQueueFamilyIndices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCreateInfo ) ) . initialLayout as
                * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCreateInfo ) ,
                "::" , stringify ! ( initialLayout ) ));
}
impl Clone for VkImageCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSubresourceLayout {
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
    pub rowPitch: VkDeviceSize,
    pub arrayPitch: VkDeviceSize,
    pub depthPitch: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkSubresourceLayout() {
    assert_eq!(::std::mem::size_of::<VkSubresourceLayout>() , 40usize , concat
               ! ( "Size of: " , stringify ! ( VkSubresourceLayout ) ));
    assert_eq! (::std::mem::align_of::<VkSubresourceLayout>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSubresourceLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubresourceLayout ) ) . offset as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubresourceLayout ) ,
                "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubresourceLayout ) ) . size as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubresourceLayout ) ,
                "::" , stringify ! ( size ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubresourceLayout ) ) . rowPitch as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubresourceLayout ) ,
                "::" , stringify ! ( rowPitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubresourceLayout ) ) . arrayPitch as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubresourceLayout ) ,
                "::" , stringify ! ( arrayPitch ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubresourceLayout ) ) . depthPitch as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubresourceLayout ) ,
                "::" , stringify ! ( depthPitch ) ));
}
impl Clone for VkSubresourceLayout {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkComponentMapping {
    pub r: VkComponentSwizzle,
    pub g: VkComponentSwizzle,
    pub b: VkComponentSwizzle,
    pub a: VkComponentSwizzle,
}
#[test]
fn bindgen_test_layout_VkComponentMapping() {
    assert_eq!(::std::mem::size_of::<VkComponentMapping>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( VkComponentMapping ) ));
    assert_eq! (::std::mem::align_of::<VkComponentMapping>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VkComponentMapping ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComponentMapping ) ) . r as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkComponentMapping ) ,
                "::" , stringify ! ( r ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComponentMapping ) ) . g as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkComponentMapping ) ,
                "::" , stringify ! ( g ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComponentMapping ) ) . b as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkComponentMapping ) ,
                "::" , stringify ! ( b ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComponentMapping ) ) . a as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkComponentMapping ) ,
                "::" , stringify ! ( a ) ));
}
impl Clone for VkComponentMapping {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageSubresourceRange {
    pub aspectMask: VkImageAspectFlags,
    pub baseMipLevel: u32,
    pub levelCount: u32,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresourceRange() {
    assert_eq!(::std::mem::size_of::<VkImageSubresourceRange>() , 20usize ,
               concat ! (
               "Size of: " , stringify ! ( VkImageSubresourceRange ) ));
    assert_eq! (::std::mem::align_of::<VkImageSubresourceRange>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkImageSubresourceRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceRange ) ) . aspectMask
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageSubresourceRange
                ) , "::" , stringify ! ( aspectMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceRange ) ) .
                baseMipLevel as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageSubresourceRange
                ) , "::" , stringify ! ( baseMipLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceRange ) ) . levelCount
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageSubresourceRange
                ) , "::" , stringify ! ( levelCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceRange ) ) .
                baseArrayLayer as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageSubresourceRange
                ) , "::" , stringify ! ( baseArrayLayer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceRange ) ) . layerCount
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageSubresourceRange
                ) , "::" , stringify ! ( layerCount ) ));
}
impl Clone for VkImageSubresourceRange {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageViewCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkImageViewCreateFlags,
    pub image: VkImage,
    pub viewType: VkImageViewType,
    pub format: VkFormat,
    pub components: VkComponentMapping,
    pub subresourceRange: VkImageSubresourceRange,
}
#[test]
fn bindgen_test_layout_VkImageViewCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkImageViewCreateInfo>() , 80usize ,
               concat ! ( "Size of: " , stringify ! ( VkImageViewCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkImageViewCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkImageViewCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageViewCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageViewCreateInfo )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageViewCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageViewCreateInfo )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageViewCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageViewCreateInfo )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageViewCreateInfo ) ) . image as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageViewCreateInfo )
                , "::" , stringify ! ( image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageViewCreateInfo ) ) . viewType as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageViewCreateInfo )
                , "::" , stringify ! ( viewType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageViewCreateInfo ) ) . format as *
                const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageViewCreateInfo )
                , "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageViewCreateInfo ) ) . components as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageViewCreateInfo )
                , "::" , stringify ! ( components ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageViewCreateInfo ) ) .
                subresourceRange as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkImageViewCreateInfo )
                , "::" , stringify ! ( subresourceRange ) ));
}
impl Clone for VkImageViewCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkShaderModuleCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkShaderModuleCreateFlags,
    pub codeSize: usize,
    pub pCode: *const u32,
}
#[test]
fn bindgen_test_layout_VkShaderModuleCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkShaderModuleCreateInfo>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( VkShaderModuleCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkShaderModuleCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkShaderModuleCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkShaderModuleCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkShaderModuleCreateInfo ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkShaderModuleCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkShaderModuleCreateInfo ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkShaderModuleCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkShaderModuleCreateInfo ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkShaderModuleCreateInfo ) ) . codeSize
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkShaderModuleCreateInfo ) , "::" , stringify ! ( codeSize )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkShaderModuleCreateInfo ) ) . pCode as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkShaderModuleCreateInfo ) , "::" , stringify ! ( pCode ) ));
}
impl Clone for VkShaderModuleCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineCacheCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCacheCreateFlags,
    pub initialDataSize: usize,
    pub pInitialData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkPipelineCacheCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineCacheCreateInfo>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( VkPipelineCacheCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineCacheCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkPipelineCacheCreateInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineCacheCreateInfo ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCacheCreateInfo ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineCacheCreateInfo ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCacheCreateInfo ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineCacheCreateInfo ) ) . flags as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCacheCreateInfo ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineCacheCreateInfo ) ) .
                initialDataSize as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCacheCreateInfo ) , "::" , stringify ! (
                initialDataSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineCacheCreateInfo ) ) .
                pInitialData as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCacheCreateInfo ) , "::" , stringify ! (
                pInitialData ) ));
}
impl Clone for VkPipelineCacheCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSpecializationMapEntry {
    pub constantID: u32,
    pub offset: u32,
    pub size: usize,
}
#[test]
fn bindgen_test_layout_VkSpecializationMapEntry() {
    assert_eq!(::std::mem::size_of::<VkSpecializationMapEntry>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( VkSpecializationMapEntry ) ));
    assert_eq! (::std::mem::align_of::<VkSpecializationMapEntry>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSpecializationMapEntry ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSpecializationMapEntry ) ) . constantID
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSpecializationMapEntry ) , "::" , stringify ! ( constantID )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSpecializationMapEntry ) ) . offset as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSpecializationMapEntry ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSpecializationMapEntry ) ) . size as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSpecializationMapEntry ) , "::" , stringify ! ( size ) ));
}
impl Clone for VkSpecializationMapEntry {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSpecializationInfo {
    pub mapEntryCount: u32,
    pub pMapEntries: *const VkSpecializationMapEntry,
    pub dataSize: usize,
    pub pData: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkSpecializationInfo() {
    assert_eq!(::std::mem::size_of::<VkSpecializationInfo>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( VkSpecializationInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkSpecializationInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSpecializationInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSpecializationInfo ) ) . mapEntryCount
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSpecializationInfo )
                , "::" , stringify ! ( mapEntryCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSpecializationInfo ) ) . pMapEntries as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSpecializationInfo )
                , "::" , stringify ! ( pMapEntries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSpecializationInfo ) ) . dataSize as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSpecializationInfo )
                , "::" , stringify ! ( dataSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSpecializationInfo ) ) . pData as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSpecializationInfo )
                , "::" , stringify ! ( pData ) ));
}
impl Clone for VkSpecializationInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineShaderStageCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineShaderStageCreateFlags,
    pub stage: VkShaderStageFlagBits,
    pub module: VkShaderModule,
    pub pName: *const ::std::os::raw::c_char,
    pub pSpecializationInfo: *const VkSpecializationInfo,
}
#[test]
fn bindgen_test_layout_VkPipelineShaderStageCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineShaderStageCreateInfo>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( VkPipelineShaderStageCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkPipelineShaderStageCreateInfo>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineShaderStageCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineShaderStageCreateInfo ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineShaderStageCreateInfo ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineShaderStageCreateInfo ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineShaderStageCreateInfo ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineShaderStageCreateInfo ) ) .
                flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineShaderStageCreateInfo ) , "::" , stringify ! ( flags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineShaderStageCreateInfo ) ) .
                stage as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineShaderStageCreateInfo ) , "::" , stringify ! ( stage
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineShaderStageCreateInfo ) ) .
                module as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineShaderStageCreateInfo ) , "::" , stringify ! (
                module ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineShaderStageCreateInfo ) ) .
                pName as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineShaderStageCreateInfo ) , "::" , stringify ! ( pName
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineShaderStageCreateInfo ) ) .
                pSpecializationInfo as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineShaderStageCreateInfo ) , "::" , stringify ! (
                pSpecializationInfo ) ));
}
impl Clone for VkPipelineShaderStageCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkVertexInputBindingDescription {
    pub binding: u32,
    pub stride: u32,
    pub inputRate: VkVertexInputRate,
}
#[test]
fn bindgen_test_layout_VkVertexInputBindingDescription() {
    assert_eq!(::std::mem::size_of::<VkVertexInputBindingDescription>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( VkVertexInputBindingDescription )
               ));
    assert_eq! (::std::mem::align_of::<VkVertexInputBindingDescription>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                VkVertexInputBindingDescription ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkVertexInputBindingDescription ) ) .
                binding as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkVertexInputBindingDescription ) , "::" , stringify ! (
                binding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkVertexInputBindingDescription ) ) .
                stride as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkVertexInputBindingDescription ) , "::" , stringify ! (
                stride ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkVertexInputBindingDescription ) ) .
                inputRate as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkVertexInputBindingDescription ) , "::" , stringify ! (
                inputRate ) ));
}
impl Clone for VkVertexInputBindingDescription {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkVertexInputAttributeDescription {
    pub location: u32,
    pub binding: u32,
    pub format: VkFormat,
    pub offset: u32,
}
#[test]
fn bindgen_test_layout_VkVertexInputAttributeDescription() {
    assert_eq!(::std::mem::size_of::<VkVertexInputAttributeDescription>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( VkVertexInputAttributeDescription )
               ));
    assert_eq! (::std::mem::align_of::<VkVertexInputAttributeDescription>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                VkVertexInputAttributeDescription ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkVertexInputAttributeDescription ) ) .
                location as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkVertexInputAttributeDescription ) , "::" , stringify ! (
                location ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkVertexInputAttributeDescription ) ) .
                binding as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkVertexInputAttributeDescription ) , "::" , stringify ! (
                binding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkVertexInputAttributeDescription ) ) .
                format as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkVertexInputAttributeDescription ) , "::" , stringify ! (
                format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkVertexInputAttributeDescription ) ) .
                offset as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkVertexInputAttributeDescription ) , "::" , stringify ! (
                offset ) ));
}
impl Clone for VkVertexInputAttributeDescription {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineVertexInputStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineVertexInputStateCreateFlags,
    pub vertexBindingDescriptionCount: u32,
    pub pVertexBindingDescriptions: *const VkVertexInputBindingDescription,
    pub vertexAttributeDescriptionCount: u32,
    pub pVertexAttributeDescriptions: *const VkVertexInputAttributeDescription,
}
#[test]
fn bindgen_test_layout_VkPipelineVertexInputStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineVertexInputStateCreateInfo>() ,
               48usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineVertexInputStateCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineVertexInputStateCreateInfo>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineVertexInputStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineVertexInputStateCreateInfo ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineVertexInputStateCreateInfo ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineVertexInputStateCreateInfo ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineVertexInputStateCreateInfo ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineVertexInputStateCreateInfo ) )
                . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineVertexInputStateCreateInfo ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineVertexInputStateCreateInfo ) )
                . vertexBindingDescriptionCount as * const _ as usize } ,
                20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineVertexInputStateCreateInfo ) , "::" , stringify ! (
                vertexBindingDescriptionCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineVertexInputStateCreateInfo ) )
                . pVertexBindingDescriptions as * const _ as usize } , 24usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineVertexInputStateCreateInfo ) , "::" , stringify ! (
                pVertexBindingDescriptions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineVertexInputStateCreateInfo ) )
                . vertexAttributeDescriptionCount as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineVertexInputStateCreateInfo ) , "::" , stringify ! (
                vertexAttributeDescriptionCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineVertexInputStateCreateInfo ) )
                . pVertexAttributeDescriptions as * const _ as usize } ,
                40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineVertexInputStateCreateInfo ) , "::" , stringify ! (
                pVertexAttributeDescriptions ) ));
}
impl Clone for VkPipelineVertexInputStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineInputAssemblyStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineInputAssemblyStateCreateFlags,
    pub topology: VkPrimitiveTopology,
    pub primitiveRestartEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineInputAssemblyStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineInputAssemblyStateCreateInfo>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineInputAssemblyStateCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineInputAssemblyStateCreateInfo>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineInputAssemblyStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineInputAssemblyStateCreateInfo )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineInputAssemblyStateCreateInfo ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineInputAssemblyStateCreateInfo )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineInputAssemblyStateCreateInfo ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineInputAssemblyStateCreateInfo )
                ) . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineInputAssemblyStateCreateInfo ) , "::" , stringify !
                ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineInputAssemblyStateCreateInfo )
                ) . topology as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineInputAssemblyStateCreateInfo ) , "::" , stringify !
                ( topology ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineInputAssemblyStateCreateInfo )
                ) . primitiveRestartEnable as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineInputAssemblyStateCreateInfo ) , "::" , stringify !
                ( primitiveRestartEnable ) ));
}
impl Clone for VkPipelineInputAssemblyStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineTessellationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineTessellationStateCreateFlags,
    pub patchControlPoints: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineTessellationStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineTessellationStateCreateInfo>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineTessellationStateCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineTessellationStateCreateInfo>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineTessellationStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineTessellationStateCreateInfo ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineTessellationStateCreateInfo ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineTessellationStateCreateInfo ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineTessellationStateCreateInfo ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineTessellationStateCreateInfo ) )
                . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineTessellationStateCreateInfo ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineTessellationStateCreateInfo ) )
                . patchControlPoints as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineTessellationStateCreateInfo ) , "::" , stringify ! (
                patchControlPoints ) ));
}
impl Clone for VkPipelineTessellationStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkViewport {
    pub x: f32,
    pub y: f32,
    pub width: f32,
    pub height: f32,
    pub minDepth: f32,
    pub maxDepth: f32,
}
#[test]
fn bindgen_test_layout_VkViewport() {
    assert_eq!(::std::mem::size_of::<VkViewport>() , 24usize , concat ! (
               "Size of: " , stringify ! ( VkViewport ) ));
    assert_eq! (::std::mem::align_of::<VkViewport>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkViewport ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewport ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewport ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewport ) ) . y as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewport ) , "::" ,
                stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewport ) ) . width as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewport ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewport ) ) . height as * const _ as
                usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewport ) , "::" ,
                stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewport ) ) . minDepth as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewport ) , "::" ,
                stringify ! ( minDepth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewport ) ) . maxDepth as * const _ as
                usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewport ) , "::" ,
                stringify ! ( maxDepth ) ));
}
impl Clone for VkViewport {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkOffset2D {
    pub x: i32,
    pub y: i32,
}
#[test]
fn bindgen_test_layout_VkOffset2D() {
    assert_eq!(::std::mem::size_of::<VkOffset2D>() , 8usize , concat ! (
               "Size of: " , stringify ! ( VkOffset2D ) ));
    assert_eq! (::std::mem::align_of::<VkOffset2D>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkOffset2D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkOffset2D ) ) . x as * const _ as usize
                } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkOffset2D ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkOffset2D ) ) . y as * const _ as usize
                } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkOffset2D ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for VkOffset2D {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExtent2D {
    pub width: u32,
    pub height: u32,
}
#[test]
fn bindgen_test_layout_VkExtent2D() {
    assert_eq!(::std::mem::size_of::<VkExtent2D>() , 8usize , concat ! (
               "Size of: " , stringify ! ( VkExtent2D ) ));
    assert_eq! (::std::mem::align_of::<VkExtent2D>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkExtent2D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExtent2D ) ) . width as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkExtent2D ) , "::" ,
                stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExtent2D ) ) . height as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkExtent2D ) , "::" ,
                stringify ! ( height ) ));
}
impl Clone for VkExtent2D {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkRect2D {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkRect2D() {
    assert_eq!(::std::mem::size_of::<VkRect2D>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VkRect2D ) ));
    assert_eq! (::std::mem::align_of::<VkRect2D>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkRect2D ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRect2D ) ) . offset as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRect2D ) , "::" ,
                stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRect2D ) ) . extent as * const _ as
                usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRect2D ) , "::" ,
                stringify ! ( extent ) ));
}
impl Clone for VkRect2D {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineViewportStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineViewportStateCreateFlags,
    pub viewportCount: u32,
    pub pViewports: *const VkViewport,
    pub scissorCount: u32,
    pub pScissors: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineViewportStateCreateInfo>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( VkPipelineViewportStateCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkPipelineViewportStateCreateInfo>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineViewportStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineViewportStateCreateInfo ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportStateCreateInfo ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineViewportStateCreateInfo ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportStateCreateInfo ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineViewportStateCreateInfo ) ) .
                flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportStateCreateInfo ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineViewportStateCreateInfo ) ) .
                viewportCount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportStateCreateInfo ) , "::" , stringify ! (
                viewportCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineViewportStateCreateInfo ) ) .
                pViewports as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportStateCreateInfo ) , "::" , stringify ! (
                pViewports ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineViewportStateCreateInfo ) ) .
                scissorCount as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportStateCreateInfo ) , "::" , stringify ! (
                scissorCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineViewportStateCreateInfo ) ) .
                pScissors as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportStateCreateInfo ) , "::" , stringify ! (
                pScissors ) ));
}
impl Clone for VkPipelineViewportStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineRasterizationStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineRasterizationStateCreateFlags,
    pub depthClampEnable: VkBool32,
    pub rasterizerDiscardEnable: VkBool32,
    pub polygonMode: VkPolygonMode,
    pub cullMode: VkCullModeFlags,
    pub frontFace: VkFrontFace,
    pub depthBiasEnable: VkBool32,
    pub depthBiasConstantFactor: f32,
    pub depthBiasClamp: f32,
    pub depthBiasSlopeFactor: f32,
    pub lineWidth: f32,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineRasterizationStateCreateInfo>()
               , 64usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineRasterizationStateCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineRasterizationStateCreateInfo>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . depthClampEnable as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( depthClampEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . rasterizerDiscardEnable as * const _ as usize } , 24usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( rasterizerDiscardEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . polygonMode as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( polygonMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . cullMode as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( cullMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . frontFace as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( frontFace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . depthBiasEnable as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( depthBiasEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . depthBiasConstantFactor as * const _ as usize } , 44usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( depthBiasConstantFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . depthBiasClamp as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( depthBiasClamp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . depthBiasSlopeFactor as * const _ as usize } , 52usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( depthBiasSlopeFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineRasterizationStateCreateInfo )
                ) . lineWidth as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateCreateInfo ) , "::" , stringify !
                ( lineWidth ) ));
}
impl Clone for VkPipelineRasterizationStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineMultisampleStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineMultisampleStateCreateFlags,
    pub rasterizationSamples: VkSampleCountFlagBits,
    pub sampleShadingEnable: VkBool32,
    pub minSampleShading: f32,
    pub pSampleMask: *const VkSampleMask,
    pub alphaToCoverageEnable: VkBool32,
    pub alphaToOneEnable: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPipelineMultisampleStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineMultisampleStateCreateInfo>() ,
               48usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineMultisampleStateCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineMultisampleStateCreateInfo>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . rasterizationSamples as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                rasterizationSamples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . sampleShadingEnable as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                sampleShadingEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . minSampleShading as * const _ as usize } , 28usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                minSampleShading ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . pSampleMask as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                pSampleMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . alphaToCoverageEnable as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                alphaToCoverageEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineMultisampleStateCreateInfo ) )
                . alphaToOneEnable as * const _ as usize } , 44usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineMultisampleStateCreateInfo ) , "::" , stringify ! (
                alphaToOneEnable ) ));
}
impl Clone for VkPipelineMultisampleStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkStencilOpState {
    pub failOp: VkStencilOp,
    pub passOp: VkStencilOp,
    pub depthFailOp: VkStencilOp,
    pub compareOp: VkCompareOp,
    pub compareMask: u32,
    pub writeMask: u32,
    pub reference: u32,
}
#[test]
fn bindgen_test_layout_VkStencilOpState() {
    assert_eq!(::std::mem::size_of::<VkStencilOpState>() , 28usize , concat !
               ( "Size of: " , stringify ! ( VkStencilOpState ) ));
    assert_eq! (::std::mem::align_of::<VkStencilOpState>() , 4usize , concat !
                ( "Alignment of " , stringify ! ( VkStencilOpState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkStencilOpState ) ) . failOp as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkStencilOpState ) ,
                "::" , stringify ! ( failOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkStencilOpState ) ) . passOp as * const
                _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkStencilOpState ) ,
                "::" , stringify ! ( passOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkStencilOpState ) ) . depthFailOp as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkStencilOpState ) ,
                "::" , stringify ! ( depthFailOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkStencilOpState ) ) . compareOp as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkStencilOpState ) ,
                "::" , stringify ! ( compareOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkStencilOpState ) ) . compareMask as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkStencilOpState ) ,
                "::" , stringify ! ( compareMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkStencilOpState ) ) . writeMask as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkStencilOpState ) ,
                "::" , stringify ! ( writeMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkStencilOpState ) ) . reference as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkStencilOpState ) ,
                "::" , stringify ! ( reference ) ));
}
impl Clone for VkStencilOpState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineDepthStencilStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDepthStencilStateCreateFlags,
    pub depthTestEnable: VkBool32,
    pub depthWriteEnable: VkBool32,
    pub depthCompareOp: VkCompareOp,
    pub depthBoundsTestEnable: VkBool32,
    pub stencilTestEnable: VkBool32,
    pub front: VkStencilOpState,
    pub back: VkStencilOpState,
    pub minDepthBounds: f32,
    pub maxDepthBounds: f32,
}
#[test]
fn bindgen_test_layout_VkPipelineDepthStencilStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineDepthStencilStateCreateInfo>()
               , 104usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineDepthStencilStateCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineDepthStencilStateCreateInfo>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . depthTestEnable as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                depthTestEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . depthWriteEnable as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                depthWriteEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . depthCompareOp as * const _ as usize } , 28usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                depthCompareOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . depthBoundsTestEnable as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                depthBoundsTestEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . stencilTestEnable as * const _ as usize } , 36usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                stencilTestEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . front as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                front ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . back as * const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                back ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . minDepthBounds as * const _ as usize } , 96usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                minDepthBounds ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDepthStencilStateCreateInfo ) )
                . maxDepthBounds as * const _ as usize } , 100usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPipelineDepthStencilStateCreateInfo ) , "::" , stringify ! (
                maxDepthBounds ) ));
}
impl Clone for VkPipelineDepthStencilStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineColorBlendAttachmentState {
    pub blendEnable: VkBool32,
    pub srcColorBlendFactor: VkBlendFactor,
    pub dstColorBlendFactor: VkBlendFactor,
    pub colorBlendOp: VkBlendOp,
    pub srcAlphaBlendFactor: VkBlendFactor,
    pub dstAlphaBlendFactor: VkBlendFactor,
    pub alphaBlendOp: VkBlendOp,
    pub colorWriteMask: VkColorComponentFlags,
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendAttachmentState() {
    assert_eq!(::std::mem::size_of::<VkPipelineColorBlendAttachmentState>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkPipelineColorBlendAttachmentState
               ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineColorBlendAttachmentState>()
                , 4usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineColorBlendAttachmentState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendAttachmentState ) ) .
                blendEnable as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAttachmentState ) , "::" , stringify ! (
                blendEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendAttachmentState ) ) .
                srcColorBlendFactor as * const _ as usize } , 4usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAttachmentState ) , "::" , stringify ! (
                srcColorBlendFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendAttachmentState ) ) .
                dstColorBlendFactor as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAttachmentState ) , "::" , stringify ! (
                dstColorBlendFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendAttachmentState ) ) .
                colorBlendOp as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAttachmentState ) , "::" , stringify ! (
                colorBlendOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendAttachmentState ) ) .
                srcAlphaBlendFactor as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAttachmentState ) , "::" , stringify ! (
                srcAlphaBlendFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendAttachmentState ) ) .
                dstAlphaBlendFactor as * const _ as usize } , 20usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAttachmentState ) , "::" , stringify ! (
                dstAlphaBlendFactor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendAttachmentState ) ) .
                alphaBlendOp as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAttachmentState ) , "::" , stringify ! (
                alphaBlendOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendAttachmentState ) ) .
                colorWriteMask as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAttachmentState ) , "::" , stringify ! (
                colorWriteMask ) ));
}
impl Clone for VkPipelineColorBlendAttachmentState {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineColorBlendStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineColorBlendStateCreateFlags,
    pub logicOpEnable: VkBool32,
    pub logicOp: VkLogicOp,
    pub attachmentCount: u32,
    pub pAttachments: *const VkPipelineColorBlendAttachmentState,
    pub blendConstants: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineColorBlendStateCreateInfo>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( VkPipelineColorBlendStateCreateInfo
               ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineColorBlendStateCreateInfo>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendStateCreateInfo ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendStateCreateInfo ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendStateCreateInfo ) ) .
                flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendStateCreateInfo ) ) .
                logicOpEnable as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) , "::" , stringify ! (
                logicOpEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendStateCreateInfo ) ) .
                logicOp as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) , "::" , stringify ! (
                logicOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendStateCreateInfo ) ) .
                attachmentCount as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) , "::" , stringify ! (
                attachmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendStateCreateInfo ) ) .
                pAttachments as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) , "::" , stringify ! (
                pAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineColorBlendStateCreateInfo ) ) .
                blendConstants as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendStateCreateInfo ) , "::" , stringify ! (
                blendConstants ) ));
}
impl Clone for VkPipelineColorBlendStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineDynamicStateCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDynamicStateCreateFlags,
    pub dynamicStateCount: u32,
    pub pDynamicStates: *const VkDynamicState,
}
#[test]
fn bindgen_test_layout_VkPipelineDynamicStateCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineDynamicStateCreateInfo>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkPipelineDynamicStateCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkPipelineDynamicStateCreateInfo>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineDynamicStateCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDynamicStateCreateInfo ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDynamicStateCreateInfo ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDynamicStateCreateInfo ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDynamicStateCreateInfo ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDynamicStateCreateInfo ) ) .
                flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDynamicStateCreateInfo ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDynamicStateCreateInfo ) ) .
                dynamicStateCount as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPipelineDynamicStateCreateInfo ) , "::" , stringify ! (
                dynamicStateCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineDynamicStateCreateInfo ) ) .
                pDynamicStates as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDynamicStateCreateInfo ) , "::" , stringify ! (
                pDynamicStates ) ));
}
impl Clone for VkPipelineDynamicStateCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkGraphicsPipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stageCount: u32,
    pub pStages: *const VkPipelineShaderStageCreateInfo,
    pub pVertexInputState: *const VkPipelineVertexInputStateCreateInfo,
    pub pInputAssemblyState: *const VkPipelineInputAssemblyStateCreateInfo,
    pub pTessellationState: *const VkPipelineTessellationStateCreateInfo,
    pub pViewportState: *const VkPipelineViewportStateCreateInfo,
    pub pRasterizationState: *const VkPipelineRasterizationStateCreateInfo,
    pub pMultisampleState: *const VkPipelineMultisampleStateCreateInfo,
    pub pDepthStencilState: *const VkPipelineDepthStencilStateCreateInfo,
    pub pColorBlendState: *const VkPipelineColorBlendStateCreateInfo,
    pub pDynamicState: *const VkPipelineDynamicStateCreateInfo,
    pub layout: VkPipelineLayout,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkGraphicsPipelineCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkGraphicsPipelineCreateInfo>() ,
               144usize , concat ! (
               "Size of: " , stringify ! ( VkGraphicsPipelineCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkGraphicsPipelineCreateInfo>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkGraphicsPipelineCreateInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) . flags
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                stageCount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                stageCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pStages as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! ( pStages
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pVertexInputState as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pVertexInputState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pInputAssemblyState as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pInputAssemblyState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pTessellationState as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pTessellationState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pViewportState as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pViewportState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pRasterizationState as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pRasterizationState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pMultisampleState as * const _ as usize } , 72usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pMultisampleState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pDepthStencilState as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pDepthStencilState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pColorBlendState as * const _ as usize } , 88usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pColorBlendState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                pDynamicState as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                pDynamicState ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) . layout
                as * const _ as usize } , 104usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! ( layout )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                renderPass as * const _ as usize } , 112usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                renderPass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                subpass as * const _ as usize } , 120usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! ( subpass
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                basePipelineHandle as * const _ as usize } , 128usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                basePipelineHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkGraphicsPipelineCreateInfo ) ) .
                basePipelineIndex as * const _ as usize } , 136usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkGraphicsPipelineCreateInfo ) , "::" , stringify ! (
                basePipelineIndex ) ));
}
impl Clone for VkGraphicsPipelineCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkComputePipelineCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCreateFlags,
    pub stage: VkPipelineShaderStageCreateInfo,
    pub layout: VkPipelineLayout,
    pub basePipelineHandle: VkPipeline,
    pub basePipelineIndex: i32,
}
#[test]
fn bindgen_test_layout_VkComputePipelineCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkComputePipelineCreateInfo>() , 96usize
               , concat ! (
               "Size of: " , stringify ! ( VkComputePipelineCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkComputePipelineCreateInfo>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkComputePipelineCreateInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComputePipelineCreateInfo ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkComputePipelineCreateInfo ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComputePipelineCreateInfo ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkComputePipelineCreateInfo ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComputePipelineCreateInfo ) ) . flags
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkComputePipelineCreateInfo ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComputePipelineCreateInfo ) ) . stage
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkComputePipelineCreateInfo ) , "::" , stringify ! ( stage )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComputePipelineCreateInfo ) ) . layout
                as * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkComputePipelineCreateInfo ) , "::" , stringify ! ( layout )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComputePipelineCreateInfo ) ) .
                basePipelineHandle as * const _ as usize } , 80usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkComputePipelineCreateInfo ) , "::" , stringify ! (
                basePipelineHandle ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkComputePipelineCreateInfo ) ) .
                basePipelineIndex as * const _ as usize } , 88usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkComputePipelineCreateInfo ) , "::" , stringify ! (
                basePipelineIndex ) ));
}
impl Clone for VkComputePipelineCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPushConstantRange {
    pub stageFlags: VkShaderStageFlags,
    pub offset: u32,
    pub size: u32,
}
#[test]
fn bindgen_test_layout_VkPushConstantRange() {
    assert_eq!(::std::mem::size_of::<VkPushConstantRange>() , 12usize , concat
               ! ( "Size of: " , stringify ! ( VkPushConstantRange ) ));
    assert_eq! (::std::mem::align_of::<VkPushConstantRange>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkPushConstantRange ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPushConstantRange ) ) . stageFlags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPushConstantRange ) ,
                "::" , stringify ! ( stageFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPushConstantRange ) ) . offset as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPushConstantRange ) ,
                "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPushConstantRange ) ) . size as * const
                _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPushConstantRange ) ,
                "::" , stringify ! ( size ) ));
}
impl Clone for VkPushConstantRange {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineLayoutCreateFlags,
    pub setLayoutCount: u32,
    pub pSetLayouts: *const VkDescriptorSetLayout,
    pub pushConstantRangeCount: u32,
    pub pPushConstantRanges: *const VkPushConstantRange,
}
#[test]
fn bindgen_test_layout_VkPipelineLayoutCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkPipelineLayoutCreateInfo>() , 48usize ,
               concat ! (
               "Size of: " , stringify ! ( VkPipelineLayoutCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineLayoutCreateInfo>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkPipelineLayoutCreateInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineLayoutCreateInfo ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineLayoutCreateInfo ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineLayoutCreateInfo ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineLayoutCreateInfo ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineLayoutCreateInfo ) ) . flags as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineLayoutCreateInfo ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineLayoutCreateInfo ) ) .
                setLayoutCount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineLayoutCreateInfo ) , "::" , stringify ! (
                setLayoutCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineLayoutCreateInfo ) ) .
                pSetLayouts as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineLayoutCreateInfo ) , "::" , stringify ! (
                pSetLayouts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineLayoutCreateInfo ) ) .
                pushConstantRangeCount as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineLayoutCreateInfo ) , "::" , stringify ! (
                pushConstantRangeCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPipelineLayoutCreateInfo ) ) .
                pPushConstantRanges as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPipelineLayoutCreateInfo ) , "::" , stringify ! (
                pPushConstantRanges ) ));
}
impl Clone for VkPipelineLayoutCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSamplerCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSamplerCreateFlags,
    pub magFilter: VkFilter,
    pub minFilter: VkFilter,
    pub mipmapMode: VkSamplerMipmapMode,
    pub addressModeU: VkSamplerAddressMode,
    pub addressModeV: VkSamplerAddressMode,
    pub addressModeW: VkSamplerAddressMode,
    pub mipLodBias: f32,
    pub anisotropyEnable: VkBool32,
    pub maxAnisotropy: f32,
    pub compareEnable: VkBool32,
    pub compareOp: VkCompareOp,
    pub minLod: f32,
    pub maxLod: f32,
    pub borderColor: VkBorderColor,
    pub unnormalizedCoordinates: VkBool32,
}
#[test]
fn bindgen_test_layout_VkSamplerCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkSamplerCreateInfo>() , 80usize , concat
               ! ( "Size of: " , stringify ! ( VkSamplerCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkSamplerCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSamplerCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . magFilter as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( magFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . minFilter as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( minFilter ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . mipmapMode as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( mipmapMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . addressModeU as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( addressModeU ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . addressModeV as
                * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( addressModeV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . addressModeW as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( addressModeW ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . mipLodBias as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( mipLodBias ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) .
                anisotropyEnable as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( anisotropyEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . maxAnisotropy
                as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( maxAnisotropy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . compareEnable
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( compareEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . compareOp as *
                const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( compareOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . minLod as *
                const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( minLod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . maxLod as *
                const _ as usize } , 68usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( maxLod ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) . borderColor as
                * const _ as usize } , 72usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( borderColor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerCreateInfo ) ) .
                unnormalizedCoordinates as * const _ as usize } , 76usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkSamplerCreateInfo ) ,
                "::" , stringify ! ( unnormalizedCoordinates ) ));
}
impl Clone for VkSamplerCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorSetLayoutBinding {
    pub binding: u32,
    pub descriptorType: VkDescriptorType,
    pub descriptorCount: u32,
    pub stageFlags: VkShaderStageFlags,
    pub pImmutableSamplers: *const VkSampler,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutBinding() {
    assert_eq!(::std::mem::size_of::<VkDescriptorSetLayoutBinding>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( VkDescriptorSetLayoutBinding ) ));
    assert_eq! (::std::mem::align_of::<VkDescriptorSetLayoutBinding>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkDescriptorSetLayoutBinding )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutBinding ) ) .
                binding as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutBinding ) , "::" , stringify ! ( binding
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutBinding ) ) .
                descriptorType as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutBinding ) , "::" , stringify ! (
                descriptorType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutBinding ) ) .
                descriptorCount as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutBinding ) , "::" , stringify ! (
                descriptorCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutBinding ) ) .
                stageFlags as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutBinding ) , "::" , stringify ! (
                stageFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutBinding ) ) .
                pImmutableSamplers as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutBinding ) , "::" , stringify ! (
                pImmutableSamplers ) ));
}
impl Clone for VkDescriptorSetLayoutBinding {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorSetLayoutCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorSetLayoutCreateFlags,
    pub bindingCount: u32,
    pub pBindings: *const VkDescriptorSetLayoutBinding,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetLayoutCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkDescriptorSetLayoutCreateInfo>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkDescriptorSetLayoutCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkDescriptorSetLayoutCreateInfo>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDescriptorSetLayoutCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutCreateInfo ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutCreateInfo ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutCreateInfo ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutCreateInfo ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutCreateInfo ) ) .
                flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutCreateInfo ) , "::" , stringify ! ( flags
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutCreateInfo ) ) .
                bindingCount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutCreateInfo ) , "::" , stringify ! (
                bindingCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetLayoutCreateInfo ) ) .
                pBindings as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetLayoutCreateInfo ) , "::" , stringify ! (
                pBindings ) ));
}
impl Clone for VkDescriptorSetLayoutCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorPoolSize {
    pub type_: VkDescriptorType,
    pub descriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorPoolSize() {
    assert_eq!(::std::mem::size_of::<VkDescriptorPoolSize>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( VkDescriptorPoolSize ) ));
    assert_eq! (::std::mem::align_of::<VkDescriptorPoolSize>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDescriptorPoolSize ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorPoolSize ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDescriptorPoolSize )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorPoolSize ) ) .
                descriptorCount as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDescriptorPoolSize )
                , "::" , stringify ! ( descriptorCount ) ));
}
impl Clone for VkDescriptorPoolSize {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDescriptorPoolCreateFlags,
    pub maxSets: u32,
    pub poolSizeCount: u32,
    pub pPoolSizes: *const VkDescriptorPoolSize,
}
#[test]
fn bindgen_test_layout_VkDescriptorPoolCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkDescriptorPoolCreateInfo>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDescriptorPoolCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkDescriptorPoolCreateInfo>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDescriptorPoolCreateInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorPoolCreateInfo ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorPoolCreateInfo ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorPoolCreateInfo ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorPoolCreateInfo ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorPoolCreateInfo ) ) . flags as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorPoolCreateInfo ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorPoolCreateInfo ) ) . maxSets
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorPoolCreateInfo ) , "::" , stringify ! ( maxSets )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorPoolCreateInfo ) ) .
                poolSizeCount as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorPoolCreateInfo ) , "::" , stringify ! (
                poolSizeCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorPoolCreateInfo ) ) .
                pPoolSizes as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorPoolCreateInfo ) , "::" , stringify ! ( pPoolSizes
                ) ));
}
impl Clone for VkDescriptorPoolCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorSetAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub descriptorPool: VkDescriptorPool,
    pub descriptorSetCount: u32,
    pub pSetLayouts: *const VkDescriptorSetLayout,
}
#[test]
fn bindgen_test_layout_VkDescriptorSetAllocateInfo() {
    assert_eq!(::std::mem::size_of::<VkDescriptorSetAllocateInfo>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( VkDescriptorSetAllocateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkDescriptorSetAllocateInfo>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDescriptorSetAllocateInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetAllocateInfo ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetAllocateInfo ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetAllocateInfo ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetAllocateInfo ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetAllocateInfo ) ) .
                descriptorPool as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetAllocateInfo ) , "::" , stringify ! (
                descriptorPool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetAllocateInfo ) ) .
                descriptorSetCount as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetAllocateInfo ) , "::" , stringify ! (
                descriptorSetCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorSetAllocateInfo ) ) .
                pSetLayouts as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorSetAllocateInfo ) , "::" , stringify ! (
                pSetLayouts ) ));
}
impl Clone for VkDescriptorSetAllocateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorImageInfo {
    pub sampler: VkSampler,
    pub imageView: VkImageView,
    pub imageLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkDescriptorImageInfo() {
    assert_eq!(::std::mem::size_of::<VkDescriptorImageInfo>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( VkDescriptorImageInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkDescriptorImageInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDescriptorImageInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorImageInfo ) ) . sampler as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDescriptorImageInfo )
                , "::" , stringify ! ( sampler ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorImageInfo ) ) . imageView as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDescriptorImageInfo )
                , "::" , stringify ! ( imageView ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorImageInfo ) ) . imageLayout
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDescriptorImageInfo )
                , "::" , stringify ! ( imageLayout ) ));
}
impl Clone for VkDescriptorImageInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorBufferInfo {
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub range: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkDescriptorBufferInfo() {
    assert_eq!(::std::mem::size_of::<VkDescriptorBufferInfo>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( VkDescriptorBufferInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkDescriptorBufferInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDescriptorBufferInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorBufferInfo ) ) . buffer as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDescriptorBufferInfo
                ) , "::" , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorBufferInfo ) ) . offset as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDescriptorBufferInfo
                ) , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorBufferInfo ) ) . range as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDescriptorBufferInfo
                ) , "::" , stringify ! ( range ) ));
}
impl Clone for VkDescriptorBufferInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkWriteDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
    pub descriptorType: VkDescriptorType,
    pub pImageInfo: *const VkDescriptorImageInfo,
    pub pBufferInfo: *const VkDescriptorBufferInfo,
    pub pTexelBufferView: *const VkBufferView,
}
#[test]
fn bindgen_test_layout_VkWriteDescriptorSet() {
    assert_eq!(::std::mem::size_of::<VkWriteDescriptorSet>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( VkWriteDescriptorSet )
               ));
    assert_eq! (::std::mem::align_of::<VkWriteDescriptorSet>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkWriteDescriptorSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) . dstSet as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( dstSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) . dstBinding as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( dstBinding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) .
                dstArrayElement as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( dstArrayElement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) .
                descriptorCount as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( descriptorCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) . descriptorType
                as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( descriptorType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) . pImageInfo as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( pImageInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) . pBufferInfo as
                * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( pBufferInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkWriteDescriptorSet ) ) .
                pTexelBufferView as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkWriteDescriptorSet )
                , "::" , stringify ! ( pTexelBufferView ) ));
}
impl Clone for VkWriteDescriptorSet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkCopyDescriptorSet {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcSet: VkDescriptorSet,
    pub srcBinding: u32,
    pub srcArrayElement: u32,
    pub dstSet: VkDescriptorSet,
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
}
#[test]
fn bindgen_test_layout_VkCopyDescriptorSet() {
    assert_eq!(::std::mem::size_of::<VkCopyDescriptorSet>() , 56usize , concat
               ! ( "Size of: " , stringify ! ( VkCopyDescriptorSet ) ));
    assert_eq! (::std::mem::align_of::<VkCopyDescriptorSet>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkCopyDescriptorSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . srcSet as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( srcSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . srcBinding as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( srcBinding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . srcArrayElement
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( srcArrayElement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . dstSet as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( dstSet ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . dstBinding as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( dstBinding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . dstArrayElement
                as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( dstArrayElement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCopyDescriptorSet ) ) . descriptorCount
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCopyDescriptorSet ) ,
                "::" , stringify ! ( descriptorCount ) ));
}
impl Clone for VkCopyDescriptorSet {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkFramebufferCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkFramebufferCreateFlags,
    pub renderPass: VkRenderPass,
    pub attachmentCount: u32,
    pub pAttachments: *const VkImageView,
    pub width: u32,
    pub height: u32,
    pub layers: u32,
}
#[test]
fn bindgen_test_layout_VkFramebufferCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkFramebufferCreateInfo>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( VkFramebufferCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkFramebufferCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkFramebufferCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) . renderPass
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( renderPass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) .
                attachmentCount as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( attachmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) .
                pAttachments as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( pAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) . width as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( width ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) . height as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( height ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFramebufferCreateInfo ) ) . layers as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFramebufferCreateInfo
                ) , "::" , stringify ! ( layers ) ));
}
impl Clone for VkFramebufferCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkAttachmentDescription {
    pub flags: VkAttachmentDescriptionFlags,
    pub format: VkFormat,
    pub samples: VkSampleCountFlagBits,
    pub loadOp: VkAttachmentLoadOp,
    pub storeOp: VkAttachmentStoreOp,
    pub stencilLoadOp: VkAttachmentLoadOp,
    pub stencilStoreOp: VkAttachmentStoreOp,
    pub initialLayout: VkImageLayout,
    pub finalLayout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentDescription() {
    assert_eq!(::std::mem::size_of::<VkAttachmentDescription>() , 36usize ,
               concat ! (
               "Size of: " , stringify ! ( VkAttachmentDescription ) ));
    assert_eq! (::std::mem::align_of::<VkAttachmentDescription>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkAttachmentDescription ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) . flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) . format as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) . samples as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( samples ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) . loadOp as *
                const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( loadOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) . storeOp as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( storeOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) .
                stencilLoadOp as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( stencilLoadOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) .
                stencilStoreOp as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( stencilStoreOp ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) .
                initialLayout as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( initialLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentDescription ) ) . finalLayout
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentDescription
                ) , "::" , stringify ! ( finalLayout ) ));
}
impl Clone for VkAttachmentDescription {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkAttachmentReference {
    pub attachment: u32,
    pub layout: VkImageLayout,
}
#[test]
fn bindgen_test_layout_VkAttachmentReference() {
    assert_eq!(::std::mem::size_of::<VkAttachmentReference>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( VkAttachmentReference )
               ));
    assert_eq! (::std::mem::align_of::<VkAttachmentReference>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkAttachmentReference ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentReference ) ) . attachment as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentReference )
                , "::" , stringify ! ( attachment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAttachmentReference ) ) . layout as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkAttachmentReference )
                , "::" , stringify ! ( layout ) ));
}
impl Clone for VkAttachmentReference {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSubpassDescription {
    pub flags: VkSubpassDescriptionFlags,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub inputAttachmentCount: u32,
    pub pInputAttachments: *const VkAttachmentReference,
    pub colorAttachmentCount: u32,
    pub pColorAttachments: *const VkAttachmentReference,
    pub pResolveAttachments: *const VkAttachmentReference,
    pub pDepthStencilAttachment: *const VkAttachmentReference,
    pub preserveAttachmentCount: u32,
    pub pPreserveAttachments: *const u32,
}
#[test]
fn bindgen_test_layout_VkSubpassDescription() {
    assert_eq!(::std::mem::size_of::<VkSubpassDescription>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( VkSubpassDescription )
               ));
    assert_eq! (::std::mem::align_of::<VkSubpassDescription>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSubpassDescription ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) . flags as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                pipelineBindPoint as * const _ as usize } , 4usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( pipelineBindPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                inputAttachmentCount as * const _ as usize } , 8usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( inputAttachmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                pInputAttachments as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( pInputAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                colorAttachmentCount as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( colorAttachmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                pColorAttachments as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( pColorAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                pResolveAttachments as * const _ as usize } , 40usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( pResolveAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                pDepthStencilAttachment as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( pDepthStencilAttachment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                preserveAttachmentCount as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( preserveAttachmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDescription ) ) .
                pPreserveAttachments as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDescription )
                , "::" , stringify ! ( pPreserveAttachments ) ));
}
impl Clone for VkSubpassDescription {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSubpassDependency {
    pub srcSubpass: u32,
    pub dstSubpass: u32,
    pub srcStageMask: VkPipelineStageFlags,
    pub dstStageMask: VkPipelineStageFlags,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub dependencyFlags: VkDependencyFlags,
}
#[test]
fn bindgen_test_layout_VkSubpassDependency() {
    assert_eq!(::std::mem::size_of::<VkSubpassDependency>() , 28usize , concat
               ! ( "Size of: " , stringify ! ( VkSubpassDependency ) ));
    assert_eq! (::std::mem::align_of::<VkSubpassDependency>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSubpassDependency ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDependency ) ) . srcSubpass as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDependency ) ,
                "::" , stringify ! ( srcSubpass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDependency ) ) . dstSubpass as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDependency ) ,
                "::" , stringify ! ( dstSubpass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDependency ) ) . srcStageMask as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDependency ) ,
                "::" , stringify ! ( srcStageMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDependency ) ) . dstStageMask as
                * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDependency ) ,
                "::" , stringify ! ( dstStageMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDependency ) ) . srcAccessMask
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDependency ) ,
                "::" , stringify ! ( srcAccessMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDependency ) ) . dstAccessMask
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDependency ) ,
                "::" , stringify ! ( dstAccessMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSubpassDependency ) ) . dependencyFlags
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSubpassDependency ) ,
                "::" , stringify ! ( dependencyFlags ) ));
}
impl Clone for VkSubpassDependency {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkRenderPassCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkRenderPassCreateFlags,
    pub attachmentCount: u32,
    pub pAttachments: *const VkAttachmentDescription,
    pub subpassCount: u32,
    pub pSubpasses: *const VkSubpassDescription,
    pub dependencyCount: u32,
    pub pDependencies: *const VkSubpassDependency,
}
#[test]
fn bindgen_test_layout_VkRenderPassCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkRenderPassCreateInfo>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( VkRenderPassCreateInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkRenderPassCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkRenderPassCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) .
                attachmentCount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( attachmentCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) . pAttachments
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( pAttachments ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) . subpassCount
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( subpassCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) . pSubpasses
                as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( pSubpasses ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) .
                dependencyCount as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( dependencyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassCreateInfo ) ) .
                pDependencies as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassCreateInfo
                ) , "::" , stringify ! ( pDependencies ) ));
}
impl Clone for VkRenderPassCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkCommandPoolCreateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandPoolCreateFlags,
    pub queueFamilyIndex: u32,
}
#[test]
fn bindgen_test_layout_VkCommandPoolCreateInfo() {
    assert_eq!(::std::mem::size_of::<VkCommandPoolCreateInfo>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( VkCommandPoolCreateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkCommandPoolCreateInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkCommandPoolCreateInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandPoolCreateInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCommandPoolCreateInfo
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandPoolCreateInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCommandPoolCreateInfo
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandPoolCreateInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkCommandPoolCreateInfo
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandPoolCreateInfo ) ) .
                queueFamilyIndex as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkCommandPoolCreateInfo
                ) , "::" , stringify ! ( queueFamilyIndex ) ));
}
impl Clone for VkCommandPoolCreateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkCommandBufferAllocateInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub commandPool: VkCommandPool,
    pub level: VkCommandBufferLevel,
    pub commandBufferCount: u32,
}
#[test]
fn bindgen_test_layout_VkCommandBufferAllocateInfo() {
    assert_eq!(::std::mem::size_of::<VkCommandBufferAllocateInfo>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( VkCommandBufferAllocateInfo ) ));
    assert_eq! (::std::mem::align_of::<VkCommandBufferAllocateInfo>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkCommandBufferAllocateInfo )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferAllocateInfo ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferAllocateInfo ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferAllocateInfo ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferAllocateInfo ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferAllocateInfo ) ) .
                commandPool as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferAllocateInfo ) , "::" , stringify ! (
                commandPool ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferAllocateInfo ) ) . level
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferAllocateInfo ) , "::" , stringify ! ( level )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferAllocateInfo ) ) .
                commandBufferCount as * const _ as usize } , 28usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferAllocateInfo ) , "::" , stringify ! (
                commandBufferCount ) ));
}
impl Clone for VkCommandBufferAllocateInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkCommandBufferInheritanceInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub subpass: u32,
    pub framebuffer: VkFramebuffer,
    pub occlusionQueryEnable: VkBool32,
    pub queryFlags: VkQueryControlFlags,
    pub pipelineStatistics: VkQueryPipelineStatisticFlags,
}
#[test]
fn bindgen_test_layout_VkCommandBufferInheritanceInfo() {
    assert_eq!(::std::mem::size_of::<VkCommandBufferInheritanceInfo>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( VkCommandBufferInheritanceInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkCommandBufferInheritanceInfo>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkCommandBufferInheritanceInfo
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferInheritanceInfo ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferInheritanceInfo ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferInheritanceInfo ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferInheritanceInfo ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferInheritanceInfo ) ) .
                renderPass as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferInheritanceInfo ) , "::" , stringify ! (
                renderPass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferInheritanceInfo ) ) .
                subpass as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferInheritanceInfo ) , "::" , stringify ! (
                subpass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferInheritanceInfo ) ) .
                framebuffer as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferInheritanceInfo ) , "::" , stringify ! (
                framebuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferInheritanceInfo ) ) .
                occlusionQueryEnable as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferInheritanceInfo ) , "::" , stringify ! (
                occlusionQueryEnable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferInheritanceInfo ) ) .
                queryFlags as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferInheritanceInfo ) , "::" , stringify ! (
                queryFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferInheritanceInfo ) ) .
                pipelineStatistics as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferInheritanceInfo ) , "::" , stringify ! (
                pipelineStatistics ) ));
}
impl Clone for VkCommandBufferInheritanceInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkCommandBufferBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkCommandBufferUsageFlags,
    pub pInheritanceInfo: *const VkCommandBufferInheritanceInfo,
}
#[test]
fn bindgen_test_layout_VkCommandBufferBeginInfo() {
    assert_eq!(::std::mem::size_of::<VkCommandBufferBeginInfo>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( VkCommandBufferBeginInfo ) ));
    assert_eq! (::std::mem::align_of::<VkCommandBufferBeginInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkCommandBufferBeginInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferBeginInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferBeginInfo ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferBeginInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferBeginInfo ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferBeginInfo ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCommandBufferBeginInfo ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCommandBufferBeginInfo ) ) .
                pInheritanceInfo as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkCommandBufferBeginInfo ) , "::" , stringify ! (
                pInheritanceInfo ) ));
}
impl Clone for VkCommandBufferBeginInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBufferCopy {
    pub srcOffset: VkDeviceSize,
    pub dstOffset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferCopy() {
    assert_eq!(::std::mem::size_of::<VkBufferCopy>() , 24usize , concat ! (
               "Size of: " , stringify ! ( VkBufferCopy ) ));
    assert_eq! (::std::mem::align_of::<VkBufferCopy>() , 8usize , concat ! (
                "Alignment of " , stringify ! ( VkBufferCopy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCopy ) ) . srcOffset as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCopy ) , "::" ,
                stringify ! ( srcOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCopy ) ) . dstOffset as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCopy ) , "::" ,
                stringify ! ( dstOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferCopy ) ) . size as * const _ as
                usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferCopy ) , "::" ,
                stringify ! ( size ) ));
}
impl Clone for VkBufferCopy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageSubresourceLayers {
    pub aspectMask: VkImageAspectFlags,
    pub mipLevel: u32,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkImageSubresourceLayers() {
    assert_eq!(::std::mem::size_of::<VkImageSubresourceLayers>() , 16usize ,
               concat ! (
               "Size of: " , stringify ! ( VkImageSubresourceLayers ) ));
    assert_eq! (::std::mem::align_of::<VkImageSubresourceLayers>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkImageSubresourceLayers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceLayers ) ) . aspectMask
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSubresourceLayers ) , "::" , stringify ! ( aspectMask )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceLayers ) ) . mipLevel
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSubresourceLayers ) , "::" , stringify ! ( mipLevel )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceLayers ) ) .
                baseArrayLayer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSubresourceLayers ) , "::" , stringify ! (
                baseArrayLayer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSubresourceLayers ) ) . layerCount
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSubresourceLayers ) , "::" , stringify ! ( layerCount )
                ));
}
impl Clone for VkImageSubresourceLayers {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageCopy {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkImageCopy() {
    assert_eq!(::std::mem::size_of::<VkImageCopy>() , 68usize , concat ! (
               "Size of: " , stringify ! ( VkImageCopy ) ));
    assert_eq! (::std::mem::align_of::<VkImageCopy>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkImageCopy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCopy ) ) . srcSubresource as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCopy ) , "::" ,
                stringify ! ( srcSubresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCopy ) ) . srcOffset as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCopy ) , "::" ,
                stringify ! ( srcOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCopy ) ) . dstSubresource as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCopy ) , "::" ,
                stringify ! ( dstSubresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCopy ) ) . dstOffset as * const _
                as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCopy ) , "::" ,
                stringify ! ( dstOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageCopy ) ) . extent as * const _ as
                usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageCopy ) , "::" ,
                stringify ! ( extent ) ));
}
impl Clone for VkImageCopy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageBlit {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffsets: [VkOffset3D; 2usize],
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffsets: [VkOffset3D; 2usize],
}
#[test]
fn bindgen_test_layout_VkImageBlit() {
    assert_eq!(::std::mem::size_of::<VkImageBlit>() , 80usize , concat ! (
               "Size of: " , stringify ! ( VkImageBlit ) ));
    assert_eq! (::std::mem::align_of::<VkImageBlit>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkImageBlit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageBlit ) ) . srcSubresource as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageBlit ) , "::" ,
                stringify ! ( srcSubresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageBlit ) ) . srcOffsets as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageBlit ) , "::" ,
                stringify ! ( srcOffsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageBlit ) ) . dstSubresource as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageBlit ) , "::" ,
                stringify ! ( dstSubresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageBlit ) ) . dstOffsets as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageBlit ) , "::" ,
                stringify ! ( dstOffsets ) ));
}
impl Clone for VkImageBlit {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBufferImageCopy {
    pub bufferOffset: VkDeviceSize,
    pub bufferRowLength: u32,
    pub bufferImageHeight: u32,
    pub imageSubresource: VkImageSubresourceLayers,
    pub imageOffset: VkOffset3D,
    pub imageExtent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkBufferImageCopy() {
    assert_eq!(::std::mem::size_of::<VkBufferImageCopy>() , 56usize , concat !
               ( "Size of: " , stringify ! ( VkBufferImageCopy ) ));
    assert_eq! (::std::mem::align_of::<VkBufferImageCopy>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkBufferImageCopy ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferImageCopy ) ) . bufferOffset as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferImageCopy ) ,
                "::" , stringify ! ( bufferOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferImageCopy ) ) . bufferRowLength
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferImageCopy ) ,
                "::" , stringify ! ( bufferRowLength ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferImageCopy ) ) . bufferImageHeight
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferImageCopy ) ,
                "::" , stringify ! ( bufferImageHeight ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferImageCopy ) ) . imageSubresource
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferImageCopy ) ,
                "::" , stringify ! ( imageSubresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferImageCopy ) ) . imageOffset as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferImageCopy ) ,
                "::" , stringify ! ( imageOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferImageCopy ) ) . imageExtent as *
                const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferImageCopy ) ,
                "::" , stringify ! ( imageExtent ) ));
}
impl Clone for VkBufferImageCopy {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union VkClearColorValue {
    pub float32: [f32; 4usize],
    pub int32: [i32; 4usize],
    pub uint32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_VkClearColorValue() {
    assert_eq!(::std::mem::size_of::<VkClearColorValue>() , 16usize , concat !
               ( "Size of: " , stringify ! ( VkClearColorValue ) ));
    assert_eq! (::std::mem::align_of::<VkClearColorValue>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VkClearColorValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearColorValue ) ) . float32 as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearColorValue ) ,
                "::" , stringify ! ( float32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearColorValue ) ) . int32 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearColorValue ) ,
                "::" , stringify ! ( int32 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearColorValue ) ) . uint32 as * const
                _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearColorValue ) ,
                "::" , stringify ! ( uint32 ) ));
}
impl Clone for VkClearColorValue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkClearDepthStencilValue {
    pub depth: f32,
    pub stencil: u32,
}
#[test]
fn bindgen_test_layout_VkClearDepthStencilValue() {
    assert_eq!(::std::mem::size_of::<VkClearDepthStencilValue>() , 8usize ,
               concat ! (
               "Size of: " , stringify ! ( VkClearDepthStencilValue ) ));
    assert_eq! (::std::mem::align_of::<VkClearDepthStencilValue>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkClearDepthStencilValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearDepthStencilValue ) ) . depth as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkClearDepthStencilValue ) , "::" , stringify ! ( depth ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearDepthStencilValue ) ) . stencil as
                * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkClearDepthStencilValue ) , "::" , stringify ! ( stencil )
                ));
}
impl Clone for VkClearDepthStencilValue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub union VkClearValue {
    pub color: VkClearColorValue,
    pub depthStencil: VkClearDepthStencilValue,
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_VkClearValue() {
    assert_eq!(::std::mem::size_of::<VkClearValue>() , 16usize , concat ! (
               "Size of: " , stringify ! ( VkClearValue ) ));
    assert_eq! (::std::mem::align_of::<VkClearValue>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkClearValue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearValue ) ) . color as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearValue ) , "::" ,
                stringify ! ( color ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearValue ) ) . depthStencil as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearValue ) , "::" ,
                stringify ! ( depthStencil ) ));
}
impl Clone for VkClearValue {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct VkClearAttachment {
    pub aspectMask: VkImageAspectFlags,
    pub colorAttachment: u32,
    pub clearValue: VkClearValue,
}
#[test]
fn bindgen_test_layout_VkClearAttachment() {
    assert_eq!(::std::mem::size_of::<VkClearAttachment>() , 24usize , concat !
               ( "Size of: " , stringify ! ( VkClearAttachment ) ));
    assert_eq! (::std::mem::align_of::<VkClearAttachment>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VkClearAttachment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearAttachment ) ) . aspectMask as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearAttachment ) ,
                "::" , stringify ! ( aspectMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearAttachment ) ) . colorAttachment
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearAttachment ) ,
                "::" , stringify ! ( colorAttachment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearAttachment ) ) . clearValue as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearAttachment ) ,
                "::" , stringify ! ( clearValue ) ));
}
impl Clone for VkClearAttachment {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkClearRect {
    pub rect: VkRect2D,
    pub baseArrayLayer: u32,
    pub layerCount: u32,
}
#[test]
fn bindgen_test_layout_VkClearRect() {
    assert_eq!(::std::mem::size_of::<VkClearRect>() , 24usize , concat ! (
               "Size of: " , stringify ! ( VkClearRect ) ));
    assert_eq! (::std::mem::align_of::<VkClearRect>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkClearRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearRect ) ) . rect as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearRect ) , "::" ,
                stringify ! ( rect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearRect ) ) . baseArrayLayer as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearRect ) , "::" ,
                stringify ! ( baseArrayLayer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkClearRect ) ) . layerCount as * const _
                as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkClearRect ) , "::" ,
                stringify ! ( layerCount ) ));
}
impl Clone for VkClearRect {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageResolve {
    pub srcSubresource: VkImageSubresourceLayers,
    pub srcOffset: VkOffset3D,
    pub dstSubresource: VkImageSubresourceLayers,
    pub dstOffset: VkOffset3D,
    pub extent: VkExtent3D,
}
#[test]
fn bindgen_test_layout_VkImageResolve() {
    assert_eq!(::std::mem::size_of::<VkImageResolve>() , 68usize , concat ! (
               "Size of: " , stringify ! ( VkImageResolve ) ));
    assert_eq! (::std::mem::align_of::<VkImageResolve>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkImageResolve ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageResolve ) ) . srcSubresource as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageResolve ) , "::"
                , stringify ! ( srcSubresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageResolve ) ) . srcOffset as * const
                _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageResolve ) , "::"
                , stringify ! ( srcOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageResolve ) ) . dstSubresource as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageResolve ) , "::"
                , stringify ! ( dstSubresource ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageResolve ) ) . dstOffset as * const
                _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageResolve ) , "::"
                , stringify ! ( dstOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageResolve ) ) . extent as * const _
                as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageResolve ) , "::"
                , stringify ! ( extent ) ));
}
impl Clone for VkImageResolve {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
}
#[test]
fn bindgen_test_layout_VkMemoryBarrier() {
    assert_eq!(::std::mem::size_of::<VkMemoryBarrier>() , 24usize , concat ! (
               "Size of: " , stringify ! ( VkMemoryBarrier ) ));
    assert_eq! (::std::mem::align_of::<VkMemoryBarrier>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VkMemoryBarrier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryBarrier ) ) . sType as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryBarrier ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryBarrier ) ) . pNext as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryBarrier ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryBarrier ) ) . srcAccessMask as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryBarrier ) ,
                "::" , stringify ! ( srcAccessMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryBarrier ) ) . dstAccessMask as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryBarrier ) ,
                "::" , stringify ! ( dstAccessMask ) ));
}
impl Clone for VkMemoryBarrier {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBufferMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
    pub size: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkBufferMemoryBarrier() {
    assert_eq!(::std::mem::size_of::<VkBufferMemoryBarrier>() , 56usize ,
               concat ! ( "Size of: " , stringify ! ( VkBufferMemoryBarrier )
               ));
    assert_eq! (::std::mem::align_of::<VkBufferMemoryBarrier>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkBufferMemoryBarrier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) . srcAccessMask
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( srcAccessMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) . dstAccessMask
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( dstAccessMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) .
                srcQueueFamilyIndex as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( srcQueueFamilyIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) .
                dstQueueFamilyIndex as * const _ as usize } , 28usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( dstQueueFamilyIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) . buffer as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) . offset as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryBarrier ) ) . size as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkBufferMemoryBarrier )
                , "::" , stringify ! ( size ) ));
}
impl Clone for VkBufferMemoryBarrier {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageMemoryBarrier {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcAccessMask: VkAccessFlags,
    pub dstAccessMask: VkAccessFlags,
    pub oldLayout: VkImageLayout,
    pub newLayout: VkImageLayout,
    pub srcQueueFamilyIndex: u32,
    pub dstQueueFamilyIndex: u32,
    pub image: VkImage,
    pub subresourceRange: VkImageSubresourceRange,
}
#[test]
fn bindgen_test_layout_VkImageMemoryBarrier() {
    assert_eq!(::std::mem::size_of::<VkImageMemoryBarrier>() , 72usize ,
               concat ! ( "Size of: " , stringify ! ( VkImageMemoryBarrier )
               ));
    assert_eq! (::std::mem::align_of::<VkImageMemoryBarrier>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkImageMemoryBarrier ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) . srcAccessMask
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( srcAccessMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) . dstAccessMask
                as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( dstAccessMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) . oldLayout as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( oldLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) . newLayout as *
                const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( newLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) .
                srcQueueFamilyIndex as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( srcQueueFamilyIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) .
                dstQueueFamilyIndex as * const _ as usize } , 36usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( dstQueueFamilyIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) . image as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryBarrier ) ) .
                subresourceRange as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkImageMemoryBarrier )
                , "::" , stringify ! ( subresourceRange ) ));
}
impl Clone for VkImageMemoryBarrier {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkRenderPassBeginInfo {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub renderPass: VkRenderPass,
    pub framebuffer: VkFramebuffer,
    pub renderArea: VkRect2D,
    pub clearValueCount: u32,
    pub pClearValues: *const VkClearValue,
}
#[test]
fn bindgen_test_layout_VkRenderPassBeginInfo() {
    assert_eq!(::std::mem::size_of::<VkRenderPassBeginInfo>() , 64usize ,
               concat ! ( "Size of: " , stringify ! ( VkRenderPassBeginInfo )
               ));
    assert_eq! (::std::mem::align_of::<VkRenderPassBeginInfo>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkRenderPassBeginInfo ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassBeginInfo ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassBeginInfo )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassBeginInfo ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassBeginInfo )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassBeginInfo ) ) . renderPass as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassBeginInfo )
                , "::" , stringify ! ( renderPass ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassBeginInfo ) ) . framebuffer
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassBeginInfo )
                , "::" , stringify ! ( framebuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassBeginInfo ) ) . renderArea as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassBeginInfo )
                , "::" , stringify ! ( renderArea ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassBeginInfo ) ) .
                clearValueCount as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassBeginInfo )
                , "::" , stringify ! ( clearValueCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassBeginInfo ) ) . pClearValues
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRenderPassBeginInfo )
                , "::" , stringify ! ( pClearValues ) ));
}
impl Clone for VkRenderPassBeginInfo {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDispatchIndirectCommand {
    pub x: u32,
    pub y: u32,
    pub z: u32,
}
#[test]
fn bindgen_test_layout_VkDispatchIndirectCommand() {
    assert_eq!(::std::mem::size_of::<VkDispatchIndirectCommand>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDispatchIndirectCommand ) ));
    assert_eq! (::std::mem::align_of::<VkDispatchIndirectCommand>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDispatchIndirectCommand )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDispatchIndirectCommand ) ) . x as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDispatchIndirectCommand ) , "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDispatchIndirectCommand ) ) . y as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDispatchIndirectCommand ) , "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDispatchIndirectCommand ) ) . z as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDispatchIndirectCommand ) , "::" , stringify ! ( z ) ));
}
impl Clone for VkDispatchIndirectCommand {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDrawIndexedIndirectCommand {
    pub indexCount: u32,
    pub instanceCount: u32,
    pub firstIndex: u32,
    pub vertexOffset: i32,
    pub firstInstance: u32,
}
#[test]
fn bindgen_test_layout_VkDrawIndexedIndirectCommand() {
    assert_eq!(::std::mem::size_of::<VkDrawIndexedIndirectCommand>() , 20usize
               , concat ! (
               "Size of: " , stringify ! ( VkDrawIndexedIndirectCommand ) ));
    assert_eq! (::std::mem::align_of::<VkDrawIndexedIndirectCommand>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( VkDrawIndexedIndirectCommand )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndexedIndirectCommand ) ) .
                indexCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDrawIndexedIndirectCommand ) , "::" , stringify ! (
                indexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndexedIndirectCommand ) ) .
                instanceCount as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDrawIndexedIndirectCommand ) , "::" , stringify ! (
                instanceCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndexedIndirectCommand ) ) .
                firstIndex as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDrawIndexedIndirectCommand ) , "::" , stringify ! (
                firstIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndexedIndirectCommand ) ) .
                vertexOffset as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDrawIndexedIndirectCommand ) , "::" , stringify ! (
                vertexOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndexedIndirectCommand ) ) .
                firstInstance as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDrawIndexedIndirectCommand ) , "::" , stringify ! (
                firstInstance ) ));
}
impl Clone for VkDrawIndexedIndirectCommand {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDrawIndirectCommand {
    pub vertexCount: u32,
    pub instanceCount: u32,
    pub firstVertex: u32,
    pub firstInstance: u32,
}
#[test]
fn bindgen_test_layout_VkDrawIndirectCommand() {
    assert_eq!(::std::mem::size_of::<VkDrawIndirectCommand>() , 16usize ,
               concat ! ( "Size of: " , stringify ! ( VkDrawIndirectCommand )
               ));
    assert_eq! (::std::mem::align_of::<VkDrawIndirectCommand>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDrawIndirectCommand ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndirectCommand ) ) . vertexCount
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDrawIndirectCommand )
                , "::" , stringify ! ( vertexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndirectCommand ) ) . instanceCount
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDrawIndirectCommand )
                , "::" , stringify ! ( instanceCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndirectCommand ) ) . firstVertex
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDrawIndirectCommand )
                , "::" , stringify ! ( firstVertex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDrawIndirectCommand ) ) . firstInstance
                as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDrawIndirectCommand )
                , "::" , stringify ! ( firstInstance ) ));
}
impl Clone for VkDrawIndirectCommand {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCreateInstance =
    ::std::option::Option<unsafe extern "C" fn(pCreateInfo:
                                                   *const VkInstanceCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pInstance: *mut VkInstance)
                              -> VkResult>;
pub type PFN_vkDestroyInstance =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkEnumeratePhysicalDevices =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pPhysicalDeviceCount: *mut u32,
                                               pPhysicalDevices:
                                                   *mut VkPhysicalDevice)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceFeatures =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pFeatures:
                                                   *mut VkPhysicalDeviceFeatures)>;
pub type PFN_vkGetPhysicalDeviceFormatProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               pFormatProperties:
                                                   *mut VkFormatProperties)>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               type_: VkImageType,
                                               tiling: VkImageTiling,
                                               usage: VkImageUsageFlags,
                                               flags: VkImageCreateFlags,
                                               pImageFormatProperties:
                                                   *mut VkImageFormatProperties)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pProperties:
                                                   *mut VkPhysicalDeviceProperties)>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pQueueFamilyPropertyCount:
                                                   *mut u32,
                                               pQueueFamilyProperties:
                                                   *mut VkQueueFamilyProperties)>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pMemoryProperties:
                                                   *mut VkPhysicalDeviceMemoryProperties)>;
pub type PFN_vkGetInstanceProcAddr =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pName:
                                                   *const ::std::os::raw::c_char)
                              -> PFN_vkVoidFunction>;
pub type PFN_vkGetDeviceProcAddr =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pName:
                                                   *const ::std::os::raw::c_char)
                              -> PFN_vkVoidFunction>;
pub type PFN_vkCreateDevice =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pCreateInfo:
                                                   *const VkDeviceCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pDevice: *mut VkDevice)
                              -> VkResult>;
pub type PFN_vkDestroyDevice =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkEnumerateInstanceExtensionProperties =
    ::std::option::Option<unsafe extern "C" fn(pLayerName:
                                                   *const ::std::os::raw::c_char,
                                               pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkExtensionProperties)
                              -> VkResult>;
pub type PFN_vkEnumerateDeviceExtensionProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pLayerName:
                                                   *const ::std::os::raw::c_char,
                                               pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkExtensionProperties)
                              -> VkResult>;
pub type PFN_vkEnumerateInstanceLayerProperties =
    ::std::option::Option<unsafe extern "C" fn(pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkLayerProperties)
                              -> VkResult>;
pub type PFN_vkEnumerateDeviceLayerProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkLayerProperties)
                              -> VkResult>;
pub type PFN_vkGetDeviceQueue =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               queueFamilyIndex: u32,
                                               queueIndex: u32,
                                               pQueue: *mut VkQueue)>;
pub type PFN_vkQueueSubmit =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue,
                                               submitCount: u32,
                                               pSubmits: *const VkSubmitInfo,
                                               fence: VkFence) -> VkResult>;
pub type PFN_vkQueueWaitIdle =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue) -> VkResult>;
pub type PFN_vkDeviceWaitIdle =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice) -> VkResult>;
pub type PFN_vkAllocateMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAllocateInfo:
                                                   *const VkMemoryAllocateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pMemory: *mut VkDeviceMemory)
                              -> VkResult>;
pub type PFN_vkFreeMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memory: VkDeviceMemory,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkMapMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memory: VkDeviceMemory,
                                               offset: VkDeviceSize,
                                               size: VkDeviceSize,
                                               flags: VkMemoryMapFlags,
                                               ppData:
                                                   *mut *mut ::std::os::raw::c_void)
                              -> VkResult>;
pub type PFN_vkUnmapMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memory: VkDeviceMemory)>;
pub type PFN_vkFlushMappedMemoryRanges =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memoryRangeCount: u32,
                                               pMemoryRanges:
                                                   *const VkMappedMemoryRange)
                              -> VkResult>;
pub type PFN_vkInvalidateMappedMemoryRanges =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memoryRangeCount: u32,
                                               pMemoryRanges:
                                                   *const VkMappedMemoryRange)
                              -> VkResult>;
pub type PFN_vkGetDeviceMemoryCommitment =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               memory: VkDeviceMemory,
                                               pCommittedMemoryInBytes:
                                                   *mut VkDeviceSize)>;
pub type PFN_vkBindBufferMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               buffer: VkBuffer,
                                               memory: VkDeviceMemory,
                                               memoryOffset: VkDeviceSize)
                              -> VkResult>;
pub type PFN_vkBindImageMemory =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               memory: VkDeviceMemory,
                                               memoryOffset: VkDeviceSize)
                              -> VkResult>;
pub type PFN_vkGetBufferMemoryRequirements =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               buffer: VkBuffer,
                                               pMemoryRequirements:
                                                   *mut VkMemoryRequirements)>;
pub type PFN_vkGetImageMemoryRequirements =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               pMemoryRequirements:
                                                   *mut VkMemoryRequirements)>;
pub type PFN_vkGetImageSparseMemoryRequirements =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               pSparseMemoryRequirementCount:
                                                   *mut u32,
                                               pSparseMemoryRequirements:
                                                   *mut VkSparseImageMemoryRequirements)>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               type_: VkImageType,
                                               samples: VkSampleCountFlagBits,
                                               usage: VkImageUsageFlags,
                                               tiling: VkImageTiling,
                                               pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkSparseImageFormatProperties)>;
pub type PFN_vkQueueBindSparse =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue,
                                               bindInfoCount: u32,
                                               pBindInfo:
                                                   *const VkBindSparseInfo,
                                               fence: VkFence) -> VkResult>;
pub type PFN_vkCreateFence =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkFenceCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pFence: *mut VkFence)
                              -> VkResult>;
pub type PFN_vkDestroyFence =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               fence: VkFence,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkResetFences =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               fenceCount: u32,
                                               pFences: *const VkFence)
                              -> VkResult>;
pub type PFN_vkGetFenceStatus =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               fence: VkFence) -> VkResult>;
pub type PFN_vkWaitForFences =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               fenceCount: u32,
                                               pFences: *const VkFence,
                                               waitAll: VkBool32,
                                               timeout: u64) -> VkResult>;
pub type PFN_vkCreateSemaphore =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkSemaphoreCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSemaphore: *mut VkSemaphore)
                              -> VkResult>;
pub type PFN_vkDestroySemaphore =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               semaphore: VkSemaphore,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkEventCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pEvent: *mut VkEvent)
                              -> VkResult>;
pub type PFN_vkDestroyEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               event: VkEvent,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetEventStatus =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               event: VkEvent) -> VkResult>;
pub type PFN_vkSetEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               event: VkEvent) -> VkResult>;
pub type PFN_vkResetEvent =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               event: VkEvent) -> VkResult>;
pub type PFN_vkCreateQueryPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkQueryPoolCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pQueryPool: *mut VkQueryPool)
                              -> VkResult>;
pub type PFN_vkDestroyQueryPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               queryPool: VkQueryPool,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetQueryPoolResults =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               queryPool: VkQueryPool,
                                               firstQuery: u32,
                                               queryCount: u32,
                                               dataSize: usize,
                                               pData:
                                                   *mut ::std::os::raw::c_void,
                                               stride: VkDeviceSize,
                                               flags: VkQueryResultFlags)
                              -> VkResult>;
pub type PFN_vkCreateBuffer =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkBufferCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pBuffer: *mut VkBuffer)
                              -> VkResult>;
pub type PFN_vkDestroyBuffer =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               buffer: VkBuffer,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateBufferView =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkBufferViewCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pView: *mut VkBufferView)
                              -> VkResult>;
pub type PFN_vkDestroyBufferView =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               bufferView: VkBufferView,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateImage =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkImageCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pImage: *mut VkImage)
                              -> VkResult>;
pub type PFN_vkDestroyImage =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetImageSubresourceLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               image: VkImage,
                                               pSubresource:
                                                   *const VkImageSubresource,
                                               pLayout:
                                                   *mut VkSubresourceLayout)>;
pub type PFN_vkCreateImageView =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkImageViewCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pView: *mut VkImageView)
                              -> VkResult>;
pub type PFN_vkDestroyImageView =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               imageView: VkImageView,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateShaderModule =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkShaderModuleCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pShaderModule:
                                                   *mut VkShaderModule)
                              -> VkResult>;
pub type PFN_vkDestroyShaderModule =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               shaderModule: VkShaderModule,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreatePipelineCache =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkPipelineCacheCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pPipelineCache:
                                                   *mut VkPipelineCache)
                              -> VkResult>;
pub type PFN_vkDestroyPipelineCache =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineCache: VkPipelineCache,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetPipelineCacheData =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineCache: VkPipelineCache,
                                               pDataSize: *mut usize,
                                               pData:
                                                   *mut ::std::os::raw::c_void)
                              -> VkResult>;
pub type PFN_vkMergePipelineCaches =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               dstCache: VkPipelineCache,
                                               srcCacheCount: u32,
                                               pSrcCaches:
                                                   *const VkPipelineCache)
                              -> VkResult>;
pub type PFN_vkCreateGraphicsPipelines =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineCache: VkPipelineCache,
                                               createInfoCount: u32,
                                               pCreateInfos:
                                                   *const VkGraphicsPipelineCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pPipelines: *mut VkPipeline)
                              -> VkResult>;
pub type PFN_vkCreateComputePipelines =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineCache: VkPipelineCache,
                                               createInfoCount: u32,
                                               pCreateInfos:
                                                   *const VkComputePipelineCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pPipelines: *mut VkPipeline)
                              -> VkResult>;
pub type PFN_vkDestroyPipeline =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipeline: VkPipeline,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreatePipelineLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkPipelineLayoutCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pPipelineLayout:
                                                   *mut VkPipelineLayout)
                              -> VkResult>;
pub type PFN_vkDestroyPipelineLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pipelineLayout:
                                                   VkPipelineLayout,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateSampler =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkSamplerCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSampler: *mut VkSampler)
                              -> VkResult>;
pub type PFN_vkDestroySampler =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               sampler: VkSampler,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateDescriptorSetLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkDescriptorSetLayoutCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSetLayout:
                                                   *mut VkDescriptorSetLayout)
                              -> VkResult>;
pub type PFN_vkDestroyDescriptorSetLayout =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorSetLayout:
                                                   VkDescriptorSetLayout,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateDescriptorPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkDescriptorPoolCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pDescriptorPool:
                                                   *mut VkDescriptorPool)
                              -> VkResult>;
pub type PFN_vkDestroyDescriptorPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorPool:
                                                   VkDescriptorPool,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkResetDescriptorPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorPool:
                                                   VkDescriptorPool,
                                               flags:
                                                   VkDescriptorPoolResetFlags)
                              -> VkResult>;
pub type PFN_vkAllocateDescriptorSets =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAllocateInfo:
                                                   *const VkDescriptorSetAllocateInfo,
                                               pDescriptorSets:
                                                   *mut VkDescriptorSet)
                              -> VkResult>;
pub type PFN_vkFreeDescriptorSets =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorPool:
                                                   VkDescriptorPool,
                                               descriptorSetCount: u32,
                                               pDescriptorSets:
                                                   *const VkDescriptorSet)
                              -> VkResult>;
pub type PFN_vkUpdateDescriptorSets =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorWriteCount: u32,
                                               pDescriptorWrites:
                                                   *const VkWriteDescriptorSet,
                                               descriptorCopyCount: u32,
                                               pDescriptorCopies:
                                                   *const VkCopyDescriptorSet)>;
pub type PFN_vkCreateFramebuffer =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkFramebufferCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pFramebuffer:
                                                   *mut VkFramebuffer)
                              -> VkResult>;
pub type PFN_vkDestroyFramebuffer =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               framebuffer: VkFramebuffer,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateRenderPass =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkRenderPassCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pRenderPass: *mut VkRenderPass)
                              -> VkResult>;
pub type PFN_vkDestroyRenderPass =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               renderPass: VkRenderPass,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetRenderAreaGranularity =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               renderPass: VkRenderPass,
                                               pGranularity:
                                                   *mut VkExtent2D)>;
pub type PFN_vkCreateCommandPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkCommandPoolCreateInfo,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pCommandPool:
                                                   *mut VkCommandPool)
                              -> VkResult>;
pub type PFN_vkDestroyCommandPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               commandPool: VkCommandPool,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkResetCommandPool =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               commandPool: VkCommandPool,
                                               flags: VkCommandPoolResetFlags)
                              -> VkResult>;
pub type PFN_vkAllocateCommandBuffers =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAllocateInfo:
                                                   *const VkCommandBufferAllocateInfo,
                                               pCommandBuffers:
                                                   *mut VkCommandBuffer)
                              -> VkResult>;
pub type PFN_vkFreeCommandBuffers =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               commandPool: VkCommandPool,
                                               commandBufferCount: u32,
                                               pCommandBuffers:
                                                   *const VkCommandBuffer)>;
pub type PFN_vkBeginCommandBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pBeginInfo:
                                                   *const VkCommandBufferBeginInfo)
                              -> VkResult>;
pub type PFN_vkEndCommandBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer)
                              -> VkResult>;
pub type PFN_vkResetCommandBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               flags:
                                                   VkCommandBufferResetFlags)
                              -> VkResult>;
pub type PFN_vkCmdBindPipeline =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pipelineBindPoint:
                                                   VkPipelineBindPoint,
                                               pipeline: VkPipeline)>;
pub type PFN_vkCmdSetViewport =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               firstViewport: u32,
                                               viewportCount: u32,
                                               pViewports:
                                                   *const VkViewport)>;
pub type PFN_vkCmdSetScissor =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               firstScissor: u32,
                                               scissorCount: u32,
                                               pScissors: *const VkRect2D)>;
pub type PFN_vkCmdSetLineWidth =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               lineWidth: f32)>;
pub type PFN_vkCmdSetDepthBias =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               depthBiasConstantFactor: f32,
                                               depthBiasClamp: f32,
                                               depthBiasSlopeFactor: f32)>;
pub type PFN_vkCmdSetBlendConstants =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               blendConstants: *const f32)>;
pub type PFN_vkCmdSetDepthBounds =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               minDepthBounds: f32,
                                               maxDepthBounds: f32)>;
pub type PFN_vkCmdSetStencilCompareMask =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               faceMask: VkStencilFaceFlags,
                                               compareMask: u32)>;
pub type PFN_vkCmdSetStencilWriteMask =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               faceMask: VkStencilFaceFlags,
                                               writeMask: u32)>;
pub type PFN_vkCmdSetStencilReference =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               faceMask: VkStencilFaceFlags,
                                               reference: u32)>;
pub type PFN_vkCmdBindDescriptorSets =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pipelineBindPoint:
                                                   VkPipelineBindPoint,
                                               layout: VkPipelineLayout,
                                               firstSet: u32,
                                               descriptorSetCount: u32,
                                               pDescriptorSets:
                                                   *const VkDescriptorSet,
                                               dynamicOffsetCount: u32,
                                               pDynamicOffsets: *const u32)>;
pub type PFN_vkCmdBindIndexBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               buffer: VkBuffer,
                                               offset: VkDeviceSize,
                                               indexType: VkIndexType)>;
pub type PFN_vkCmdBindVertexBuffers =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               firstBinding: u32,
                                               bindingCount: u32,
                                               pBuffers: *const VkBuffer,
                                               pOffsets:
                                                   *const VkDeviceSize)>;
pub type PFN_vkCmdDraw =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               vertexCount: u32,
                                               instanceCount: u32,
                                               firstVertex: u32,
                                               firstInstance: u32)>;
pub type PFN_vkCmdDrawIndexed =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               indexCount: u32,
                                               instanceCount: u32,
                                               firstIndex: u32,
                                               vertexOffset: i32,
                                               firstInstance: u32)>;
pub type PFN_vkCmdDrawIndirect =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               buffer: VkBuffer,
                                               offset: VkDeviceSize,
                                               drawCount: u32, stride: u32)>;
pub type PFN_vkCmdDrawIndexedIndirect =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               buffer: VkBuffer,
                                               offset: VkDeviceSize,
                                               drawCount: u32, stride: u32)>;
pub type PFN_vkCmdDispatch =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               groupCountX: u32,
                                               groupCountY: u32,
                                               groupCountZ: u32)>;
pub type PFN_vkCmdDispatchIndirect =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               buffer: VkBuffer,
                                               offset: VkDeviceSize)>;
pub type PFN_vkCmdCopyBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcBuffer: VkBuffer,
                                               dstBuffer: VkBuffer,
                                               regionCount: u32,
                                               pRegions:
                                                   *const VkBufferCopy)>;
pub type PFN_vkCmdCopyImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcImage: VkImage,
                                               srcImageLayout: VkImageLayout,
                                               dstImage: VkImage,
                                               dstImageLayout: VkImageLayout,
                                               regionCount: u32,
                                               pRegions: *const VkImageCopy)>;
pub type PFN_vkCmdBlitImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcImage: VkImage,
                                               srcImageLayout: VkImageLayout,
                                               dstImage: VkImage,
                                               dstImageLayout: VkImageLayout,
                                               regionCount: u32,
                                               pRegions: *const VkImageBlit,
                                               filter: VkFilter)>;
pub type PFN_vkCmdCopyBufferToImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcBuffer: VkBuffer,
                                               dstImage: VkImage,
                                               dstImageLayout: VkImageLayout,
                                               regionCount: u32,
                                               pRegions:
                                                   *const VkBufferImageCopy)>;
pub type PFN_vkCmdCopyImageToBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcImage: VkImage,
                                               srcImageLayout: VkImageLayout,
                                               dstBuffer: VkBuffer,
                                               regionCount: u32,
                                               pRegions:
                                                   *const VkBufferImageCopy)>;
pub type PFN_vkCmdUpdateBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               dstBuffer: VkBuffer,
                                               dstOffset: VkDeviceSize,
                                               dataSize: VkDeviceSize,
                                               pData:
                                                   *const ::std::os::raw::c_void)>;
pub type PFN_vkCmdFillBuffer =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               dstBuffer: VkBuffer,
                                               dstOffset: VkDeviceSize,
                                               size: VkDeviceSize,
                                               data: u32)>;
pub type PFN_vkCmdClearColorImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               image: VkImage,
                                               imageLayout: VkImageLayout,
                                               pColor:
                                                   *const VkClearColorValue,
                                               rangeCount: u32,
                                               pRanges:
                                                   *const VkImageSubresourceRange)>;
pub type PFN_vkCmdClearDepthStencilImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               image: VkImage,
                                               imageLayout: VkImageLayout,
                                               pDepthStencil:
                                                   *const VkClearDepthStencilValue,
                                               rangeCount: u32,
                                               pRanges:
                                                   *const VkImageSubresourceRange)>;
pub type PFN_vkCmdClearAttachments =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               attachmentCount: u32,
                                               pAttachments:
                                                   *const VkClearAttachment,
                                               rectCount: u32,
                                               pRects: *const VkClearRect)>;
pub type PFN_vkCmdResolveImage =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcImage: VkImage,
                                               srcImageLayout: VkImageLayout,
                                               dstImage: VkImage,
                                               dstImageLayout: VkImageLayout,
                                               regionCount: u32,
                                               pRegions:
                                                   *const VkImageResolve)>;
pub type PFN_vkCmdSetEvent =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               event: VkEvent,
                                               stageMask:
                                                   VkPipelineStageFlags)>;
pub type PFN_vkCmdResetEvent =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               event: VkEvent,
                                               stageMask:
                                                   VkPipelineStageFlags)>;
pub type PFN_vkCmdWaitEvents =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               eventCount: u32,
                                               pEvents: *const VkEvent,
                                               srcStageMask:
                                                   VkPipelineStageFlags,
                                               dstStageMask:
                                                   VkPipelineStageFlags,
                                               memoryBarrierCount: u32,
                                               pMemoryBarriers:
                                                   *const VkMemoryBarrier,
                                               bufferMemoryBarrierCount: u32,
                                               pBufferMemoryBarriers:
                                                   *const VkBufferMemoryBarrier,
                                               imageMemoryBarrierCount: u32,
                                               pImageMemoryBarriers:
                                                   *const VkImageMemoryBarrier)>;
pub type PFN_vkCmdPipelineBarrier =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               srcStageMask:
                                                   VkPipelineStageFlags,
                                               dstStageMask:
                                                   VkPipelineStageFlags,
                                               dependencyFlags:
                                                   VkDependencyFlags,
                                               memoryBarrierCount: u32,
                                               pMemoryBarriers:
                                                   *const VkMemoryBarrier,
                                               bufferMemoryBarrierCount: u32,
                                               pBufferMemoryBarriers:
                                                   *const VkBufferMemoryBarrier,
                                               imageMemoryBarrierCount: u32,
                                               pImageMemoryBarriers:
                                                   *const VkImageMemoryBarrier)>;
pub type PFN_vkCmdBeginQuery =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               queryPool: VkQueryPool,
                                               query: u32,
                                               flags: VkQueryControlFlags)>;
pub type PFN_vkCmdEndQuery =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               queryPool: VkQueryPool,
                                               query: u32)>;
pub type PFN_vkCmdResetQueryPool =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               queryPool: VkQueryPool,
                                               firstQuery: u32,
                                               queryCount: u32)>;
pub type PFN_vkCmdWriteTimestamp =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pipelineStage:
                                                   VkPipelineStageFlagBits,
                                               queryPool: VkQueryPool,
                                               query: u32)>;
pub type PFN_vkCmdCopyQueryPoolResults =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               queryPool: VkQueryPool,
                                               firstQuery: u32,
                                               queryCount: u32,
                                               dstBuffer: VkBuffer,
                                               dstOffset: VkDeviceSize,
                                               stride: VkDeviceSize,
                                               flags: VkQueryResultFlags)>;
pub type PFN_vkCmdPushConstants =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               layout: VkPipelineLayout,
                                               stageFlags: VkShaderStageFlags,
                                               offset: u32, size: u32,
                                               pValues:
                                                   *const ::std::os::raw::c_void)>;
pub type PFN_vkCmdBeginRenderPass =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pRenderPassBegin:
                                                   *const VkRenderPassBeginInfo,
                                               contents: VkSubpassContents)>;
pub type PFN_vkCmdNextSubpass =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               contents: VkSubpassContents)>;
pub type PFN_vkCmdEndRenderPass =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer:
                                                   VkCommandBuffer)>;
pub type PFN_vkCmdExecuteCommands =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               commandBufferCount: u32,
                                               pCommandBuffers:
                                                   *const VkCommandBuffer)>;
extern "C" {
    pub fn vkCreateInstance(pCreateInfo: *const VkInstanceCreateInfo,
                            pAllocator: *const VkAllocationCallbacks,
                            pInstance: *mut VkInstance) -> VkResult;
}
extern "C" {
    pub fn vkDestroyInstance(instance: VkInstance,
                             pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkEnumeratePhysicalDevices(instance: VkInstance,
                                      pPhysicalDeviceCount: *mut u32,
                                      pPhysicalDevices: *mut VkPhysicalDevice)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceFeatures(physicalDevice: VkPhysicalDevice,
                                       pFeatures:
                                           *mut VkPhysicalDeviceFeatures);
}
extern "C" {
    pub fn vkGetPhysicalDeviceFormatProperties(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               pFormatProperties:
                                                   *mut VkFormatProperties);
}
extern "C" {
    pub fn vkGetPhysicalDeviceImageFormatProperties(physicalDevice:
                                                        VkPhysicalDevice,
                                                    format: VkFormat,
                                                    type_: VkImageType,
                                                    tiling: VkImageTiling,
                                                    usage: VkImageUsageFlags,
                                                    flags: VkImageCreateFlags,
                                                    pImageFormatProperties:
                                                        *mut VkImageFormatProperties)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceProperties(physicalDevice: VkPhysicalDevice,
                                         pProperties:
                                             *mut VkPhysicalDeviceProperties);
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyProperties(physicalDevice:
                                                        VkPhysicalDevice,
                                                    pQueueFamilyPropertyCount:
                                                        *mut u32,
                                                    pQueueFamilyProperties:
                                                        *mut VkQueueFamilyProperties);
}
extern "C" {
    pub fn vkGetPhysicalDeviceMemoryProperties(physicalDevice:
                                                   VkPhysicalDevice,
                                               pMemoryProperties:
                                                   *mut VkPhysicalDeviceMemoryProperties);
}
extern "C" {
    pub fn vkGetInstanceProcAddr(instance: VkInstance,
                                 pName: *const ::std::os::raw::c_char)
     -> PFN_vkVoidFunction;
}
extern "C" {
    pub fn vkGetDeviceProcAddr(device: VkDevice,
                               pName: *const ::std::os::raw::c_char)
     -> PFN_vkVoidFunction;
}
extern "C" {
    pub fn vkCreateDevice(physicalDevice: VkPhysicalDevice,
                          pCreateInfo: *const VkDeviceCreateInfo,
                          pAllocator: *const VkAllocationCallbacks,
                          pDevice: *mut VkDevice) -> VkResult;
}
extern "C" {
    pub fn vkDestroyDevice(device: VkDevice,
                           pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkEnumerateInstanceExtensionProperties(pLayerName:
                                                      *const ::std::os::raw::c_char,
                                                  pPropertyCount: *mut u32,
                                                  pProperties:
                                                      *mut VkExtensionProperties)
     -> VkResult;
}
extern "C" {
    pub fn vkEnumerateDeviceExtensionProperties(physicalDevice:
                                                    VkPhysicalDevice,
                                                pLayerName:
                                                    *const ::std::os::raw::c_char,
                                                pPropertyCount: *mut u32,
                                                pProperties:
                                                    *mut VkExtensionProperties)
     -> VkResult;
}
extern "C" {
    pub fn vkEnumerateInstanceLayerProperties(pPropertyCount: *mut u32,
                                              pProperties:
                                                  *mut VkLayerProperties)
     -> VkResult;
}
extern "C" {
    pub fn vkEnumerateDeviceLayerProperties(physicalDevice: VkPhysicalDevice,
                                            pPropertyCount: *mut u32,
                                            pProperties:
                                                *mut VkLayerProperties)
     -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceQueue(device: VkDevice, queueFamilyIndex: u32,
                            queueIndex: u32, pQueue: *mut VkQueue);
}
extern "C" {
    pub fn vkQueueSubmit(queue: VkQueue, submitCount: u32,
                         pSubmits: *const VkSubmitInfo, fence: VkFence)
     -> VkResult;
}
extern "C" {
    pub fn vkQueueWaitIdle(queue: VkQueue) -> VkResult;
}
extern "C" {
    pub fn vkDeviceWaitIdle(device: VkDevice) -> VkResult;
}
extern "C" {
    pub fn vkAllocateMemory(device: VkDevice,
                            pAllocateInfo: *const VkMemoryAllocateInfo,
                            pAllocator: *const VkAllocationCallbacks,
                            pMemory: *mut VkDeviceMemory) -> VkResult;
}
extern "C" {
    pub fn vkFreeMemory(device: VkDevice, memory: VkDeviceMemory,
                        pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkMapMemory(device: VkDevice, memory: VkDeviceMemory,
                       offset: VkDeviceSize, size: VkDeviceSize,
                       flags: VkMemoryMapFlags,
                       ppData: *mut *mut ::std::os::raw::c_void) -> VkResult;
}
extern "C" {
    pub fn vkUnmapMemory(device: VkDevice, memory: VkDeviceMemory);
}
extern "C" {
    pub fn vkFlushMappedMemoryRanges(device: VkDevice, memoryRangeCount: u32,
                                     pMemoryRanges:
                                         *const VkMappedMemoryRange)
     -> VkResult;
}
extern "C" {
    pub fn vkInvalidateMappedMemoryRanges(device: VkDevice,
                                          memoryRangeCount: u32,
                                          pMemoryRanges:
                                              *const VkMappedMemoryRange)
     -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceMemoryCommitment(device: VkDevice,
                                       memory: VkDeviceMemory,
                                       pCommittedMemoryInBytes:
                                           *mut VkDeviceSize);
}
extern "C" {
    pub fn vkBindBufferMemory(device: VkDevice, buffer: VkBuffer,
                              memory: VkDeviceMemory,
                              memoryOffset: VkDeviceSize) -> VkResult;
}
extern "C" {
    pub fn vkBindImageMemory(device: VkDevice, image: VkImage,
                             memory: VkDeviceMemory,
                             memoryOffset: VkDeviceSize) -> VkResult;
}
extern "C" {
    pub fn vkGetBufferMemoryRequirements(device: VkDevice, buffer: VkBuffer,
                                         pMemoryRequirements:
                                             *mut VkMemoryRequirements);
}
extern "C" {
    pub fn vkGetImageMemoryRequirements(device: VkDevice, image: VkImage,
                                        pMemoryRequirements:
                                            *mut VkMemoryRequirements);
}
extern "C" {
    pub fn vkGetImageSparseMemoryRequirements(device: VkDevice,
                                              image: VkImage,
                                              pSparseMemoryRequirementCount:
                                                  *mut u32,
                                              pSparseMemoryRequirements:
                                                  *mut VkSparseImageMemoryRequirements);
}
extern "C" {
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties(physicalDevice:
                                                              VkPhysicalDevice,
                                                          format: VkFormat,
                                                          type_: VkImageType,
                                                          samples:
                                                              VkSampleCountFlagBits,
                                                          usage:
                                                              VkImageUsageFlags,
                                                          tiling:
                                                              VkImageTiling,
                                                          pPropertyCount:
                                                              *mut u32,
                                                          pProperties:
                                                              *mut VkSparseImageFormatProperties);
}
extern "C" {
    pub fn vkQueueBindSparse(queue: VkQueue, bindInfoCount: u32,
                             pBindInfo: *const VkBindSparseInfo,
                             fence: VkFence) -> VkResult;
}
extern "C" {
    pub fn vkCreateFence(device: VkDevice,
                         pCreateInfo: *const VkFenceCreateInfo,
                         pAllocator: *const VkAllocationCallbacks,
                         pFence: *mut VkFence) -> VkResult;
}
extern "C" {
    pub fn vkDestroyFence(device: VkDevice, fence: VkFence,
                          pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkResetFences(device: VkDevice, fenceCount: u32,
                         pFences: *const VkFence) -> VkResult;
}
extern "C" {
    pub fn vkGetFenceStatus(device: VkDevice, fence: VkFence) -> VkResult;
}
extern "C" {
    pub fn vkWaitForFences(device: VkDevice, fenceCount: u32,
                           pFences: *const VkFence, waitAll: VkBool32,
                           timeout: u64) -> VkResult;
}
extern "C" {
    pub fn vkCreateSemaphore(device: VkDevice,
                             pCreateInfo: *const VkSemaphoreCreateInfo,
                             pAllocator: *const VkAllocationCallbacks,
                             pSemaphore: *mut VkSemaphore) -> VkResult;
}
extern "C" {
    pub fn vkDestroySemaphore(device: VkDevice, semaphore: VkSemaphore,
                              pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateEvent(device: VkDevice,
                         pCreateInfo: *const VkEventCreateInfo,
                         pAllocator: *const VkAllocationCallbacks,
                         pEvent: *mut VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkDestroyEvent(device: VkDevice, event: VkEvent,
                          pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkGetEventStatus(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkSetEvent(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkResetEvent(device: VkDevice, event: VkEvent) -> VkResult;
}
extern "C" {
    pub fn vkCreateQueryPool(device: VkDevice,
                             pCreateInfo: *const VkQueryPoolCreateInfo,
                             pAllocator: *const VkAllocationCallbacks,
                             pQueryPool: *mut VkQueryPool) -> VkResult;
}
extern "C" {
    pub fn vkDestroyQueryPool(device: VkDevice, queryPool: VkQueryPool,
                              pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkGetQueryPoolResults(device: VkDevice, queryPool: VkQueryPool,
                                 firstQuery: u32, queryCount: u32,
                                 dataSize: usize,
                                 pData: *mut ::std::os::raw::c_void,
                                 stride: VkDeviceSize,
                                 flags: VkQueryResultFlags) -> VkResult;
}
extern "C" {
    pub fn vkCreateBuffer(device: VkDevice,
                          pCreateInfo: *const VkBufferCreateInfo,
                          pAllocator: *const VkAllocationCallbacks,
                          pBuffer: *mut VkBuffer) -> VkResult;
}
extern "C" {
    pub fn vkDestroyBuffer(device: VkDevice, buffer: VkBuffer,
                           pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateBufferView(device: VkDevice,
                              pCreateInfo: *const VkBufferViewCreateInfo,
                              pAllocator: *const VkAllocationCallbacks,
                              pView: *mut VkBufferView) -> VkResult;
}
extern "C" {
    pub fn vkDestroyBufferView(device: VkDevice, bufferView: VkBufferView,
                               pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateImage(device: VkDevice,
                         pCreateInfo: *const VkImageCreateInfo,
                         pAllocator: *const VkAllocationCallbacks,
                         pImage: *mut VkImage) -> VkResult;
}
extern "C" {
    pub fn vkDestroyImage(device: VkDevice, image: VkImage,
                          pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkGetImageSubresourceLayout(device: VkDevice, image: VkImage,
                                       pSubresource:
                                           *const VkImageSubresource,
                                       pLayout: *mut VkSubresourceLayout);
}
extern "C" {
    pub fn vkCreateImageView(device: VkDevice,
                             pCreateInfo: *const VkImageViewCreateInfo,
                             pAllocator: *const VkAllocationCallbacks,
                             pView: *mut VkImageView) -> VkResult;
}
extern "C" {
    pub fn vkDestroyImageView(device: VkDevice, imageView: VkImageView,
                              pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateShaderModule(device: VkDevice,
                                pCreateInfo: *const VkShaderModuleCreateInfo,
                                pAllocator: *const VkAllocationCallbacks,
                                pShaderModule: *mut VkShaderModule)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyShaderModule(device: VkDevice,
                                 shaderModule: VkShaderModule,
                                 pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreatePipelineCache(device: VkDevice,
                                 pCreateInfo:
                                     *const VkPipelineCacheCreateInfo,
                                 pAllocator: *const VkAllocationCallbacks,
                                 pPipelineCache: *mut VkPipelineCache)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipelineCache(device: VkDevice,
                                  pipelineCache: VkPipelineCache,
                                  pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkGetPipelineCacheData(device: VkDevice,
                                  pipelineCache: VkPipelineCache,
                                  pDataSize: *mut usize,
                                  pData: *mut ::std::os::raw::c_void)
     -> VkResult;
}
extern "C" {
    pub fn vkMergePipelineCaches(device: VkDevice, dstCache: VkPipelineCache,
                                 srcCacheCount: u32,
                                 pSrcCaches: *const VkPipelineCache)
     -> VkResult;
}
extern "C" {
    pub fn vkCreateGraphicsPipelines(device: VkDevice,
                                     pipelineCache: VkPipelineCache,
                                     createInfoCount: u32,
                                     pCreateInfos:
                                         *const VkGraphicsPipelineCreateInfo,
                                     pAllocator: *const VkAllocationCallbacks,
                                     pPipelines: *mut VkPipeline) -> VkResult;
}
extern "C" {
    pub fn vkCreateComputePipelines(device: VkDevice,
                                    pipelineCache: VkPipelineCache,
                                    createInfoCount: u32,
                                    pCreateInfos:
                                        *const VkComputePipelineCreateInfo,
                                    pAllocator: *const VkAllocationCallbacks,
                                    pPipelines: *mut VkPipeline) -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipeline(device: VkDevice, pipeline: VkPipeline,
                             pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreatePipelineLayout(device: VkDevice,
                                  pCreateInfo:
                                      *const VkPipelineLayoutCreateInfo,
                                  pAllocator: *const VkAllocationCallbacks,
                                  pPipelineLayout: *mut VkPipelineLayout)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyPipelineLayout(device: VkDevice,
                                   pipelineLayout: VkPipelineLayout,
                                   pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateSampler(device: VkDevice,
                           pCreateInfo: *const VkSamplerCreateInfo,
                           pAllocator: *const VkAllocationCallbacks,
                           pSampler: *mut VkSampler) -> VkResult;
}
extern "C" {
    pub fn vkDestroySampler(device: VkDevice, sampler: VkSampler,
                            pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateDescriptorSetLayout(device: VkDevice,
                                       pCreateInfo:
                                           *const VkDescriptorSetLayoutCreateInfo,
                                       pAllocator:
                                           *const VkAllocationCallbacks,
                                       pSetLayout: *mut VkDescriptorSetLayout)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorSetLayout(device: VkDevice,
                                        descriptorSetLayout:
                                            VkDescriptorSetLayout,
                                        pAllocator:
                                            *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateDescriptorPool(device: VkDevice,
                                  pCreateInfo:
                                      *const VkDescriptorPoolCreateInfo,
                                  pAllocator: *const VkAllocationCallbacks,
                                  pDescriptorPool: *mut VkDescriptorPool)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorPool(device: VkDevice,
                                   descriptorPool: VkDescriptorPool,
                                   pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkResetDescriptorPool(device: VkDevice,
                                 descriptorPool: VkDescriptorPool,
                                 flags: VkDescriptorPoolResetFlags)
     -> VkResult;
}
extern "C" {
    pub fn vkAllocateDescriptorSets(device: VkDevice,
                                    pAllocateInfo:
                                        *const VkDescriptorSetAllocateInfo,
                                    pDescriptorSets: *mut VkDescriptorSet)
     -> VkResult;
}
extern "C" {
    pub fn vkFreeDescriptorSets(device: VkDevice,
                                descriptorPool: VkDescriptorPool,
                                descriptorSetCount: u32,
                                pDescriptorSets: *const VkDescriptorSet)
     -> VkResult;
}
extern "C" {
    pub fn vkUpdateDescriptorSets(device: VkDevice, descriptorWriteCount: u32,
                                  pDescriptorWrites:
                                      *const VkWriteDescriptorSet,
                                  descriptorCopyCount: u32,
                                  pDescriptorCopies:
                                      *const VkCopyDescriptorSet);
}
extern "C" {
    pub fn vkCreateFramebuffer(device: VkDevice,
                               pCreateInfo: *const VkFramebufferCreateInfo,
                               pAllocator: *const VkAllocationCallbacks,
                               pFramebuffer: *mut VkFramebuffer) -> VkResult;
}
extern "C" {
    pub fn vkDestroyFramebuffer(device: VkDevice, framebuffer: VkFramebuffer,
                                pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateRenderPass(device: VkDevice,
                              pCreateInfo: *const VkRenderPassCreateInfo,
                              pAllocator: *const VkAllocationCallbacks,
                              pRenderPass: *mut VkRenderPass) -> VkResult;
}
extern "C" {
    pub fn vkDestroyRenderPass(device: VkDevice, renderPass: VkRenderPass,
                               pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkGetRenderAreaGranularity(device: VkDevice,
                                      renderPass: VkRenderPass,
                                      pGranularity: *mut VkExtent2D);
}
extern "C" {
    pub fn vkCreateCommandPool(device: VkDevice,
                               pCreateInfo: *const VkCommandPoolCreateInfo,
                               pAllocator: *const VkAllocationCallbacks,
                               pCommandPool: *mut VkCommandPool) -> VkResult;
}
extern "C" {
    pub fn vkDestroyCommandPool(device: VkDevice, commandPool: VkCommandPool,
                                pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkResetCommandPool(device: VkDevice, commandPool: VkCommandPool,
                              flags: VkCommandPoolResetFlags) -> VkResult;
}
extern "C" {
    pub fn vkAllocateCommandBuffers(device: VkDevice,
                                    pAllocateInfo:
                                        *const VkCommandBufferAllocateInfo,
                                    pCommandBuffers: *mut VkCommandBuffer)
     -> VkResult;
}
extern "C" {
    pub fn vkFreeCommandBuffers(device: VkDevice, commandPool: VkCommandPool,
                                commandBufferCount: u32,
                                pCommandBuffers: *const VkCommandBuffer);
}
extern "C" {
    pub fn vkBeginCommandBuffer(commandBuffer: VkCommandBuffer,
                                pBeginInfo: *const VkCommandBufferBeginInfo)
     -> VkResult;
}
extern "C" {
    pub fn vkEndCommandBuffer(commandBuffer: VkCommandBuffer) -> VkResult;
}
extern "C" {
    pub fn vkResetCommandBuffer(commandBuffer: VkCommandBuffer,
                                flags: VkCommandBufferResetFlags) -> VkResult;
}
extern "C" {
    pub fn vkCmdBindPipeline(commandBuffer: VkCommandBuffer,
                             pipelineBindPoint: VkPipelineBindPoint,
                             pipeline: VkPipeline);
}
extern "C" {
    pub fn vkCmdSetViewport(commandBuffer: VkCommandBuffer,
                            firstViewport: u32, viewportCount: u32,
                            pViewports: *const VkViewport);
}
extern "C" {
    pub fn vkCmdSetScissor(commandBuffer: VkCommandBuffer, firstScissor: u32,
                           scissorCount: u32, pScissors: *const VkRect2D);
}
extern "C" {
    pub fn vkCmdSetLineWidth(commandBuffer: VkCommandBuffer, lineWidth: f32);
}
extern "C" {
    pub fn vkCmdSetDepthBias(commandBuffer: VkCommandBuffer,
                             depthBiasConstantFactor: f32,
                             depthBiasClamp: f32, depthBiasSlopeFactor: f32);
}
extern "C" {
    pub fn vkCmdSetBlendConstants(commandBuffer: VkCommandBuffer,
                                  blendConstants: *const f32);
}
extern "C" {
    pub fn vkCmdSetDepthBounds(commandBuffer: VkCommandBuffer,
                               minDepthBounds: f32, maxDepthBounds: f32);
}
extern "C" {
    pub fn vkCmdSetStencilCompareMask(commandBuffer: VkCommandBuffer,
                                      faceMask: VkStencilFaceFlags,
                                      compareMask: u32);
}
extern "C" {
    pub fn vkCmdSetStencilWriteMask(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    writeMask: u32);
}
extern "C" {
    pub fn vkCmdSetStencilReference(commandBuffer: VkCommandBuffer,
                                    faceMask: VkStencilFaceFlags,
                                    reference: u32);
}
extern "C" {
    pub fn vkCmdBindDescriptorSets(commandBuffer: VkCommandBuffer,
                                   pipelineBindPoint: VkPipelineBindPoint,
                                   layout: VkPipelineLayout, firstSet: u32,
                                   descriptorSetCount: u32,
                                   pDescriptorSets: *const VkDescriptorSet,
                                   dynamicOffsetCount: u32,
                                   pDynamicOffsets: *const u32);
}
extern "C" {
    pub fn vkCmdBindIndexBuffer(commandBuffer: VkCommandBuffer,
                                buffer: VkBuffer, offset: VkDeviceSize,
                                indexType: VkIndexType);
}
extern "C" {
    pub fn vkCmdBindVertexBuffers(commandBuffer: VkCommandBuffer,
                                  firstBinding: u32, bindingCount: u32,
                                  pBuffers: *const VkBuffer,
                                  pOffsets: *const VkDeviceSize);
}
extern "C" {
    pub fn vkCmdDraw(commandBuffer: VkCommandBuffer, vertexCount: u32,
                     instanceCount: u32, firstVertex: u32,
                     firstInstance: u32);
}
extern "C" {
    pub fn vkCmdDrawIndexed(commandBuffer: VkCommandBuffer, indexCount: u32,
                            instanceCount: u32, firstIndex: u32,
                            vertexOffset: i32, firstInstance: u32);
}
extern "C" {
    pub fn vkCmdDrawIndirect(commandBuffer: VkCommandBuffer, buffer: VkBuffer,
                             offset: VkDeviceSize, drawCount: u32,
                             stride: u32);
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirect(commandBuffer: VkCommandBuffer,
                                    buffer: VkBuffer, offset: VkDeviceSize,
                                    drawCount: u32, stride: u32);
}
extern "C" {
    pub fn vkCmdDispatch(commandBuffer: VkCommandBuffer, groupCountX: u32,
                         groupCountY: u32, groupCountZ: u32);
}
extern "C" {
    pub fn vkCmdDispatchIndirect(commandBuffer: VkCommandBuffer,
                                 buffer: VkBuffer, offset: VkDeviceSize);
}
extern "C" {
    pub fn vkCmdCopyBuffer(commandBuffer: VkCommandBuffer,
                           srcBuffer: VkBuffer, dstBuffer: VkBuffer,
                           regionCount: u32, pRegions: *const VkBufferCopy);
}
extern "C" {
    pub fn vkCmdCopyImage(commandBuffer: VkCommandBuffer, srcImage: VkImage,
                          srcImageLayout: VkImageLayout, dstImage: VkImage,
                          dstImageLayout: VkImageLayout, regionCount: u32,
                          pRegions: *const VkImageCopy);
}
extern "C" {
    pub fn vkCmdBlitImage(commandBuffer: VkCommandBuffer, srcImage: VkImage,
                          srcImageLayout: VkImageLayout, dstImage: VkImage,
                          dstImageLayout: VkImageLayout, regionCount: u32,
                          pRegions: *const VkImageBlit, filter: VkFilter);
}
extern "C" {
    pub fn vkCmdCopyBufferToImage(commandBuffer: VkCommandBuffer,
                                  srcBuffer: VkBuffer, dstImage: VkImage,
                                  dstImageLayout: VkImageLayout,
                                  regionCount: u32,
                                  pRegions: *const VkBufferImageCopy);
}
extern "C" {
    pub fn vkCmdCopyImageToBuffer(commandBuffer: VkCommandBuffer,
                                  srcImage: VkImage,
                                  srcImageLayout: VkImageLayout,
                                  dstBuffer: VkBuffer, regionCount: u32,
                                  pRegions: *const VkBufferImageCopy);
}
extern "C" {
    pub fn vkCmdUpdateBuffer(commandBuffer: VkCommandBuffer,
                             dstBuffer: VkBuffer, dstOffset: VkDeviceSize,
                             dataSize: VkDeviceSize,
                             pData: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vkCmdFillBuffer(commandBuffer: VkCommandBuffer,
                           dstBuffer: VkBuffer, dstOffset: VkDeviceSize,
                           size: VkDeviceSize, data: u32);
}
extern "C" {
    pub fn vkCmdClearColorImage(commandBuffer: VkCommandBuffer,
                                image: VkImage, imageLayout: VkImageLayout,
                                pColor: *const VkClearColorValue,
                                rangeCount: u32,
                                pRanges: *const VkImageSubresourceRange);
}
extern "C" {
    pub fn vkCmdClearDepthStencilImage(commandBuffer: VkCommandBuffer,
                                       image: VkImage,
                                       imageLayout: VkImageLayout,
                                       pDepthStencil:
                                           *const VkClearDepthStencilValue,
                                       rangeCount: u32,
                                       pRanges:
                                           *const VkImageSubresourceRange);
}
extern "C" {
    pub fn vkCmdClearAttachments(commandBuffer: VkCommandBuffer,
                                 attachmentCount: u32,
                                 pAttachments: *const VkClearAttachment,
                                 rectCount: u32, pRects: *const VkClearRect);
}
extern "C" {
    pub fn vkCmdResolveImage(commandBuffer: VkCommandBuffer,
                             srcImage: VkImage, srcImageLayout: VkImageLayout,
                             dstImage: VkImage, dstImageLayout: VkImageLayout,
                             regionCount: u32,
                             pRegions: *const VkImageResolve);
}
extern "C" {
    pub fn vkCmdSetEvent(commandBuffer: VkCommandBuffer, event: VkEvent,
                         stageMask: VkPipelineStageFlags);
}
extern "C" {
    pub fn vkCmdResetEvent(commandBuffer: VkCommandBuffer, event: VkEvent,
                           stageMask: VkPipelineStageFlags);
}
extern "C" {
    pub fn vkCmdWaitEvents(commandBuffer: VkCommandBuffer, eventCount: u32,
                           pEvents: *const VkEvent,
                           srcStageMask: VkPipelineStageFlags,
                           dstStageMask: VkPipelineStageFlags,
                           memoryBarrierCount: u32,
                           pMemoryBarriers: *const VkMemoryBarrier,
                           bufferMemoryBarrierCount: u32,
                           pBufferMemoryBarriers:
                               *const VkBufferMemoryBarrier,
                           imageMemoryBarrierCount: u32,
                           pImageMemoryBarriers: *const VkImageMemoryBarrier);
}
extern "C" {
    pub fn vkCmdPipelineBarrier(commandBuffer: VkCommandBuffer,
                                srcStageMask: VkPipelineStageFlags,
                                dstStageMask: VkPipelineStageFlags,
                                dependencyFlags: VkDependencyFlags,
                                memoryBarrierCount: u32,
                                pMemoryBarriers: *const VkMemoryBarrier,
                                bufferMemoryBarrierCount: u32,
                                pBufferMemoryBarriers:
                                    *const VkBufferMemoryBarrier,
                                imageMemoryBarrierCount: u32,
                                pImageMemoryBarriers:
                                    *const VkImageMemoryBarrier);
}
extern "C" {
    pub fn vkCmdBeginQuery(commandBuffer: VkCommandBuffer,
                           queryPool: VkQueryPool, query: u32,
                           flags: VkQueryControlFlags);
}
extern "C" {
    pub fn vkCmdEndQuery(commandBuffer: VkCommandBuffer,
                         queryPool: VkQueryPool, query: u32);
}
extern "C" {
    pub fn vkCmdResetQueryPool(commandBuffer: VkCommandBuffer,
                               queryPool: VkQueryPool, firstQuery: u32,
                               queryCount: u32);
}
extern "C" {
    pub fn vkCmdWriteTimestamp(commandBuffer: VkCommandBuffer,
                               pipelineStage: VkPipelineStageFlagBits,
                               queryPool: VkQueryPool, query: u32);
}
extern "C" {
    pub fn vkCmdCopyQueryPoolResults(commandBuffer: VkCommandBuffer,
                                     queryPool: VkQueryPool, firstQuery: u32,
                                     queryCount: u32, dstBuffer: VkBuffer,
                                     dstOffset: VkDeviceSize,
                                     stride: VkDeviceSize,
                                     flags: VkQueryResultFlags);
}
extern "C" {
    pub fn vkCmdPushConstants(commandBuffer: VkCommandBuffer,
                              layout: VkPipelineLayout,
                              stageFlags: VkShaderStageFlags, offset: u32,
                              size: u32,
                              pValues: *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vkCmdBeginRenderPass(commandBuffer: VkCommandBuffer,
                                pRenderPassBegin:
                                    *const VkRenderPassBeginInfo,
                                contents: VkSubpassContents);
}
extern "C" {
    pub fn vkCmdNextSubpass(commandBuffer: VkCommandBuffer,
                            contents: VkSubpassContents);
}
extern "C" {
    pub fn vkCmdEndRenderPass(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdExecuteCommands(commandBuffer: VkCommandBuffer,
                                commandBufferCount: u32,
                                pCommandBuffers: *const VkCommandBuffer);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSurfaceKHR_T {
    _unused: [u8; 0],
}
pub type VkSurfaceKHR = *mut VkSurfaceKHR_T;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_BEGIN_RANGE_KHR: VkColorSpaceKHR =
    VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
pub const VkColorSpaceKHR_VK_COLOR_SPACE_END_RANGE_KHR: VkColorSpaceKHR =
    VkColorSpaceKHR::VK_COLOR_SPACE_SRGB_NONLINEAR_KHR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkColorSpaceKHR {
    VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
    VK_COLOR_SPACE_DISPLAY_P3_NONLINEAR_EXT = 1000104001,
    VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
    VK_COLOR_SPACE_DCI_P3_LINEAR_EXT = 1000104003,
    VK_COLOR_SPACE_DCI_P3_NONLINEAR_EXT = 1000104004,
    VK_COLOR_SPACE_BT709_LINEAR_EXT = 1000104005,
    VK_COLOR_SPACE_BT709_NONLINEAR_EXT = 1000104006,
    VK_COLOR_SPACE_BT2020_LINEAR_EXT = 1000104007,
    VK_COLOR_SPACE_HDR10_ST2084_EXT = 1000104008,
    VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
    VK_COLOR_SPACE_HDR10_HLG_EXT = 1000104010,
    VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
    VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
    VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
    VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
    VK_COLOR_SPACE_RANGE_SIZE_KHR = 1,
    VK_COLOR_SPACE_MAX_ENUM_KHR = 2147483647,
}
pub const VkPresentModeKHR_VK_PRESENT_MODE_BEGIN_RANGE_KHR: VkPresentModeKHR =
    VkPresentModeKHR::VK_PRESENT_MODE_IMMEDIATE_KHR;
pub const VkPresentModeKHR_VK_PRESENT_MODE_END_RANGE_KHR: VkPresentModeKHR =
    VkPresentModeKHR::VK_PRESENT_MODE_FIFO_RELAXED_KHR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPresentModeKHR {
    VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
    VK_PRESENT_MODE_MAILBOX_KHR = 1,
    VK_PRESENT_MODE_FIFO_KHR = 2,
    VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
    VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
    VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
    VK_PRESENT_MODE_RANGE_SIZE_KHR = 4,
    VK_PRESENT_MODE_MAX_ENUM_KHR = 2147483647,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSurfaceTransformFlagBitsKHR {
    VK_SURFACE_TRANSFORM_IDENTITY_BIT_KHR = 1,
    VK_SURFACE_TRANSFORM_ROTATE_90_BIT_KHR = 2,
    VK_SURFACE_TRANSFORM_ROTATE_180_BIT_KHR = 4,
    VK_SURFACE_TRANSFORM_ROTATE_270_BIT_KHR = 8,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_BIT_KHR = 16,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_90_BIT_KHR = 32,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_180_BIT_KHR = 64,
    VK_SURFACE_TRANSFORM_HORIZONTAL_MIRROR_ROTATE_270_BIT_KHR = 128,
    VK_SURFACE_TRANSFORM_INHERIT_BIT_KHR = 256,
    VK_SURFACE_TRANSFORM_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkSurfaceTransformFlagsKHR = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCompositeAlphaFlagBitsKHR {
    VK_COMPOSITE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_COMPOSITE_ALPHA_PRE_MULTIPLIED_BIT_KHR = 2,
    VK_COMPOSITE_ALPHA_POST_MULTIPLIED_BIT_KHR = 4,
    VK_COMPOSITE_ALPHA_INHERIT_BIT_KHR = 8,
    VK_COMPOSITE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkCompositeAlphaFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSurfaceCapabilitiesKHR {
    pub minImageCount: u32,
    pub maxImageCount: u32,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: u32,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilitiesKHR() {
    assert_eq!(::std::mem::size_of::<VkSurfaceCapabilitiesKHR>() , 52usize ,
               concat ! (
               "Size of: " , stringify ! ( VkSurfaceCapabilitiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkSurfaceCapabilitiesKHR>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSurfaceCapabilitiesKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                minImageCount as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                minImageCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                maxImageCount as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                maxImageCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                currentExtent as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                currentExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                minImageExtent as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                minImageExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                maxImageExtent as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                maxImageExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                maxImageArrayLayers as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                maxImageArrayLayers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                supportedTransforms as * const _ as usize } , 36usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                supportedTransforms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                currentTransform as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                currentTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                supportedCompositeAlpha as * const _ as usize } , 44usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                supportedCompositeAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilitiesKHR ) ) .
                supportedUsageFlags as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                supportedUsageFlags ) ));
}
impl Clone for VkSurfaceCapabilitiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSurfaceFormatKHR {
    pub format: VkFormat,
    pub colorSpace: VkColorSpaceKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceFormatKHR() {
    assert_eq!(::std::mem::size_of::<VkSurfaceFormatKHR>() , 8usize , concat !
               ( "Size of: " , stringify ! ( VkSurfaceFormatKHR ) ));
    assert_eq! (::std::mem::align_of::<VkSurfaceFormatKHR>() , 4usize , concat
                ! ( "Alignment of " , stringify ! ( VkSurfaceFormatKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceFormatKHR ) ) . format as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSurfaceFormatKHR ) ,
                "::" , stringify ! ( format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceFormatKHR ) ) . colorSpace as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSurfaceFormatKHR ) ,
                "::" , stringify ! ( colorSpace ) ));
}
impl Clone for VkSurfaceFormatKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkDestroySurfaceKHR =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               surface: VkSurfaceKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetPhysicalDeviceSurfaceSupportKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               queueFamilyIndex: u32,
                                               surface: VkSurfaceKHR,
                                               pSupported: *mut VkBool32)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               surface: VkSurfaceKHR,
                                               pSurfaceCapabilities:
                                                   *mut VkSurfaceCapabilitiesKHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceSurfaceFormatsKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               surface: VkSurfaceKHR,
                                               pSurfaceFormatCount: *mut u32,
                                               pSurfaceFormats:
                                                   *mut VkSurfaceFormatKHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceSurfacePresentModesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               surface: VkSurfaceKHR,
                                               pPresentModeCount: *mut u32,
                                               pPresentModes:
                                                   *mut VkPresentModeKHR)
                              -> VkResult>;
extern "C" {
    pub fn vkDestroySurfaceKHR(instance: VkInstance, surface: VkSurfaceKHR,
                               pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceSupportKHR(physicalDevice:
                                                    VkPhysicalDevice,
                                                queueFamilyIndex: u32,
                                                surface: VkSurfaceKHR,
                                                pSupported: *mut VkBool32)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilitiesKHR(physicalDevice:
                                                         VkPhysicalDevice,
                                                     surface: VkSurfaceKHR,
                                                     pSurfaceCapabilities:
                                                         *mut VkSurfaceCapabilitiesKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceFormatsKHR(physicalDevice:
                                                    VkPhysicalDevice,
                                                surface: VkSurfaceKHR,
                                                pSurfaceFormatCount: *mut u32,
                                                pSurfaceFormats:
                                                    *mut VkSurfaceFormatKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfacePresentModesKHR(physicalDevice:
                                                         VkPhysicalDevice,
                                                     surface: VkSurfaceKHR,
                                                     pPresentModeCount:
                                                         *mut u32,
                                                     pPresentModes:
                                                         *mut VkPresentModeKHR)
     -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkSwapchainKHR_T {
    _unused: [u8; 0],
}
pub type VkSwapchainKHR = *mut VkSwapchainKHR_T;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSwapchainCreateFlagBitsKHR {
    VK_SWAPCHAIN_CREATE_BIND_SFR_BIT_KHX = 1,
    VK_SWAPCHAIN_CREATE_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkSwapchainCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSwapchainCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkSwapchainCreateFlagsKHR,
    pub surface: VkSurfaceKHR,
    pub minImageCount: u32,
    pub imageFormat: VkFormat,
    pub imageColorSpace: VkColorSpaceKHR,
    pub imageExtent: VkExtent2D,
    pub imageArrayLayers: u32,
    pub imageUsage: VkImageUsageFlags,
    pub imageSharingMode: VkSharingMode,
    pub queueFamilyIndexCount: u32,
    pub pQueueFamilyIndices: *const u32,
    pub preTransform: VkSurfaceTransformFlagBitsKHR,
    pub compositeAlpha: VkCompositeAlphaFlagBitsKHR,
    pub presentMode: VkPresentModeKHR,
    pub clipped: VkBool32,
    pub oldSwapchain: VkSwapchainKHR,
}
#[test]
fn bindgen_test_layout_VkSwapchainCreateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkSwapchainCreateInfoKHR>() , 104usize ,
               concat ! (
               "Size of: " , stringify ! ( VkSwapchainCreateInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkSwapchainCreateInfoKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSwapchainCreateInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) . flags as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) . surface as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( surface )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                minImageCount as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! (
                minImageCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                imageFormat as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( imageFormat
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                imageColorSpace as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! (
                imageColorSpace ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                imageExtent as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( imageExtent
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                imageArrayLayers as * const _ as usize } , 52usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! (
                imageArrayLayers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) . imageUsage
                as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( imageUsage )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                imageSharingMode as * const _ as usize } , 60usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! (
                imageSharingMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                queueFamilyIndexCount as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! (
                queueFamilyIndexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                pQueueFamilyIndices as * const _ as usize } , 72usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! (
                pQueueFamilyIndices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                preTransform as * const _ as usize } , 80usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( preTransform
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                compositeAlpha as * const _ as usize } , 84usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! (
                compositeAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                presentMode as * const _ as usize } , 88usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( presentMode
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) . clipped as
                * const _ as usize } , 92usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( clipped )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCreateInfoKHR ) ) .
                oldSwapchain as * const _ as usize } , 96usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCreateInfoKHR ) , "::" , stringify ! ( oldSwapchain
                ) ));
}
impl Clone for VkSwapchainCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphores: *const VkSemaphore,
    pub swapchainCount: u32,
    pub pSwapchains: *const VkSwapchainKHR,
    pub pImageIndices: *const u32,
    pub pResults: *mut VkResult,
}
#[test]
fn bindgen_test_layout_VkPresentInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkPresentInfoKHR>() , 64usize , concat !
               ( "Size of: " , stringify ! ( VkPresentInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPresentInfoKHR>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VkPresentInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentInfoKHR ) ) . sType as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentInfoKHR ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentInfoKHR ) ) . pNext as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentInfoKHR ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentInfoKHR ) ) . waitSemaphoreCount
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentInfoKHR ) ,
                "::" , stringify ! ( waitSemaphoreCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentInfoKHR ) ) . pWaitSemaphores as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentInfoKHR ) ,
                "::" , stringify ! ( pWaitSemaphores ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentInfoKHR ) ) . swapchainCount as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentInfoKHR ) ,
                "::" , stringify ! ( swapchainCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentInfoKHR ) ) . pSwapchains as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentInfoKHR ) ,
                "::" , stringify ! ( pSwapchains ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentInfoKHR ) ) . pImageIndices as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentInfoKHR ) ,
                "::" , stringify ! ( pImageIndices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentInfoKHR ) ) . pResults as *
                const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentInfoKHR ) ,
                "::" , stringify ! ( pResults ) ));
}
impl Clone for VkPresentInfoKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCreateSwapchainKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkSwapchainCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSwapchain:
                                                   *mut VkSwapchainKHR)
                              -> VkResult>;
pub type PFN_vkDestroySwapchainKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkGetSwapchainImagesKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               pSwapchainImageCount: *mut u32,
                                               pSwapchainImages: *mut VkImage)
                              -> VkResult>;
pub type PFN_vkAcquireNextImageKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               timeout: u64,
                                               semaphore: VkSemaphore,
                                               fence: VkFence,
                                               pImageIndex: *mut u32)
                              -> VkResult>;
pub type PFN_vkQueuePresentKHR =
    ::std::option::Option<unsafe extern "C" fn(queue: VkQueue,
                                               pPresentInfo:
                                                   *const VkPresentInfoKHR)
                              -> VkResult>;
extern "C" {
    pub fn vkCreateSwapchainKHR(device: VkDevice,
                                pCreateInfo: *const VkSwapchainCreateInfoKHR,
                                pAllocator: *const VkAllocationCallbacks,
                                pSwapchain: *mut VkSwapchainKHR) -> VkResult;
}
extern "C" {
    pub fn vkDestroySwapchainKHR(device: VkDevice, swapchain: VkSwapchainKHR,
                                 pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkGetSwapchainImagesKHR(device: VkDevice,
                                   swapchain: VkSwapchainKHR,
                                   pSwapchainImageCount: *mut u32,
                                   pSwapchainImages: *mut VkImage)
     -> VkResult;
}
extern "C" {
    pub fn vkAcquireNextImageKHR(device: VkDevice, swapchain: VkSwapchainKHR,
                                 timeout: u64, semaphore: VkSemaphore,
                                 fence: VkFence, pImageIndex: *mut u32)
     -> VkResult;
}
extern "C" {
    pub fn vkQueuePresentKHR(queue: VkQueue,
                             pPresentInfo: *const VkPresentInfoKHR)
     -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayKHR_T {
    _unused: [u8; 0],
}
pub type VkDisplayKHR = *mut VkDisplayKHR_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDisplayModeKHR_T {
    _unused: [u8; 0],
}
pub type VkDisplayModeKHR = *mut VkDisplayModeKHR_T;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDisplayPlaneAlphaFlagBitsKHR {
    VK_DISPLAY_PLANE_ALPHA_OPAQUE_BIT_KHR = 1,
    VK_DISPLAY_PLANE_ALPHA_GLOBAL_BIT_KHR = 2,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_BIT_KHR = 4,
    VK_DISPLAY_PLANE_ALPHA_PER_PIXEL_PREMULTIPLIED_BIT_KHR = 8,
    VK_DISPLAY_PLANE_ALPHA_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkDisplayPlaneAlphaFlagsKHR = VkFlags;
pub type VkDisplayModeCreateFlagsKHR = VkFlags;
pub type VkDisplaySurfaceCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayPropertiesKHR {
    pub display: VkDisplayKHR,
    pub displayName: *const ::std::os::raw::c_char,
    pub physicalDimensions: VkExtent2D,
    pub physicalResolution: VkExtent2D,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub planeReorderPossible: VkBool32,
    pub persistentContent: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDisplayPropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkDisplayPropertiesKHR>() , 48usize ,
               concat ! ( "Size of: " , stringify ! ( VkDisplayPropertiesKHR )
               ));
    assert_eq! (::std::mem::align_of::<VkDisplayPropertiesKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDisplayPropertiesKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPropertiesKHR ) ) . display as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPropertiesKHR
                ) , "::" , stringify ! ( display ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPropertiesKHR ) ) . displayName
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPropertiesKHR
                ) , "::" , stringify ! ( displayName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPropertiesKHR ) ) .
                physicalDimensions as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkDisplayPropertiesKHR
                ) , "::" , stringify ! ( physicalDimensions ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPropertiesKHR ) ) .
                physicalResolution as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkDisplayPropertiesKHR
                ) , "::" , stringify ! ( physicalResolution ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPropertiesKHR ) ) .
                supportedTransforms as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkDisplayPropertiesKHR
                ) , "::" , stringify ! ( supportedTransforms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPropertiesKHR ) ) .
                planeReorderPossible as * const _ as usize } , 36usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPropertiesKHR
                ) , "::" , stringify ! ( planeReorderPossible ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPropertiesKHR ) ) .
                persistentContent as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkDisplayPropertiesKHR
                ) , "::" , stringify ! ( persistentContent ) ));
}
impl Clone for VkDisplayPropertiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayModeParametersKHR {
    pub visibleRegion: VkExtent2D,
    pub refreshRate: u32,
}
#[test]
fn bindgen_test_layout_VkDisplayModeParametersKHR() {
    assert_eq!(::std::mem::size_of::<VkDisplayModeParametersKHR>() , 12usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDisplayModeParametersKHR ) ));
    assert_eq! (::std::mem::align_of::<VkDisplayModeParametersKHR>() , 4usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDisplayModeParametersKHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayModeParametersKHR ) ) .
                visibleRegion as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayModeParametersKHR ) , "::" , stringify ! (
                visibleRegion ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayModeParametersKHR ) ) .
                refreshRate as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayModeParametersKHR ) , "::" , stringify ! (
                refreshRate ) ));
}
impl Clone for VkDisplayModeParametersKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayModePropertiesKHR {
    pub displayMode: VkDisplayModeKHR,
    pub parameters: VkDisplayModeParametersKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayModePropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkDisplayModePropertiesKHR>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDisplayModePropertiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkDisplayModePropertiesKHR>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDisplayModePropertiesKHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayModePropertiesKHR ) ) .
                displayMode as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayModePropertiesKHR ) , "::" , stringify ! (
                displayMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayModePropertiesKHR ) ) .
                parameters as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayModePropertiesKHR ) , "::" , stringify ! ( parameters
                ) ));
}
impl Clone for VkDisplayModePropertiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayModeCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplayModeCreateFlagsKHR,
    pub parameters: VkDisplayModeParametersKHR,
}
#[test]
fn bindgen_test_layout_VkDisplayModeCreateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkDisplayModeCreateInfoKHR>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDisplayModeCreateInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkDisplayModeCreateInfoKHR>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDisplayModeCreateInfoKHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayModeCreateInfoKHR ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayModeCreateInfoKHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayModeCreateInfoKHR ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayModeCreateInfoKHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayModeCreateInfoKHR ) ) . flags as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayModeCreateInfoKHR ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayModeCreateInfoKHR ) ) .
                parameters as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayModeCreateInfoKHR ) , "::" , stringify ! ( parameters
                ) ));
}
impl Clone for VkDisplayModeCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayPlaneCapabilitiesKHR {
    pub supportedAlpha: VkDisplayPlaneAlphaFlagsKHR,
    pub minSrcPosition: VkOffset2D,
    pub maxSrcPosition: VkOffset2D,
    pub minSrcExtent: VkExtent2D,
    pub maxSrcExtent: VkExtent2D,
    pub minDstPosition: VkOffset2D,
    pub maxDstPosition: VkOffset2D,
    pub minDstExtent: VkExtent2D,
    pub maxDstExtent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkDisplayPlaneCapabilitiesKHR() {
    assert_eq!(::std::mem::size_of::<VkDisplayPlaneCapabilitiesKHR>() ,
               68usize , concat ! (
               "Size of: " , stringify ! ( VkDisplayPlaneCapabilitiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkDisplayPlaneCapabilitiesKHR>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( VkDisplayPlaneCapabilitiesKHR
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                supportedAlpha as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                supportedAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                minSrcPosition as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                minSrcPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                maxSrcPosition as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                maxSrcPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                minSrcExtent as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                minSrcExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                maxSrcExtent as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                maxSrcExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                minDstPosition as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                minDstPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                maxDstPosition as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                maxDstPosition ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                minDstExtent as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                minDstExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlaneCapabilitiesKHR ) ) .
                maxDstExtent as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlaneCapabilitiesKHR ) , "::" , stringify ! (
                maxDstExtent ) ));
}
impl Clone for VkDisplayPlaneCapabilitiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayPlanePropertiesKHR {
    pub currentDisplay: VkDisplayKHR,
    pub currentStackIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDisplayPlanePropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkDisplayPlanePropertiesKHR>() , 16usize
               , concat ! (
               "Size of: " , stringify ! ( VkDisplayPlanePropertiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkDisplayPlanePropertiesKHR>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDisplayPlanePropertiesKHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlanePropertiesKHR ) ) .
                currentDisplay as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplayPlanePropertiesKHR ) , "::" , stringify ! (
                currentDisplay ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPlanePropertiesKHR ) ) .
                currentStackIndex as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkDisplayPlanePropertiesKHR ) , "::" , stringify ! (
                currentStackIndex ) ));
}
impl Clone for VkDisplayPlanePropertiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplaySurfaceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDisplaySurfaceCreateFlagsKHR,
    pub displayMode: VkDisplayModeKHR,
    pub planeIndex: u32,
    pub planeStackIndex: u32,
    pub transform: VkSurfaceTransformFlagBitsKHR,
    pub globalAlpha: f32,
    pub alphaMode: VkDisplayPlaneAlphaFlagBitsKHR,
    pub imageExtent: VkExtent2D,
}
#[test]
fn bindgen_test_layout_VkDisplaySurfaceCreateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkDisplaySurfaceCreateInfoKHR>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( VkDisplaySurfaceCreateInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkDisplaySurfaceCreateInfoKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkDisplaySurfaceCreateInfoKHR
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) . flags
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) .
                displayMode as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! (
                displayMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) .
                planeIndex as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! (
                planeIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) .
                planeStackIndex as * const _ as usize } , 36usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! (
                planeStackIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) .
                transform as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! (
                transform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) .
                globalAlpha as * const _ as usize } , 44usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! (
                globalAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) .
                alphaMode as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! (
                alphaMode ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplaySurfaceCreateInfoKHR ) ) .
                imageExtent as * const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDisplaySurfaceCreateInfoKHR ) , "::" , stringify ! (
                imageExtent ) ));
}
impl Clone for VkDisplaySurfaceCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetPhysicalDeviceDisplayPropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkDisplayPropertiesKHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceDisplayPlanePropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkDisplayPlanePropertiesKHR)
                              -> VkResult>;
pub type PFN_vkGetDisplayPlaneSupportedDisplaysKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               planeIndex: u32,
                                               pDisplayCount: *mut u32,
                                               pDisplays: *mut VkDisplayKHR)
                              -> VkResult>;
pub type PFN_vkGetDisplayModePropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               display: VkDisplayKHR,
                                               pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkDisplayModePropertiesKHR)
                              -> VkResult>;
pub type PFN_vkCreateDisplayModeKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               display: VkDisplayKHR,
                                               pCreateInfo:
                                                   *const VkDisplayModeCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pMode: *mut VkDisplayModeKHR)
                              -> VkResult>;
pub type PFN_vkGetDisplayPlaneCapabilitiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               mode: VkDisplayModeKHR,
                                               planeIndex: u32,
                                               pCapabilities:
                                                   *mut VkDisplayPlaneCapabilitiesKHR)
                              -> VkResult>;
pub type PFN_vkCreateDisplayPlaneSurfaceKHR =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pCreateInfo:
                                                   *const VkDisplaySurfaceCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSurface: *mut VkSurfaceKHR)
                              -> VkResult>;
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayPropertiesKHR(physicalDevice:
                                                       VkPhysicalDevice,
                                                   pPropertyCount: *mut u32,
                                                   pProperties:
                                                       *mut VkDisplayPropertiesKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceDisplayPlanePropertiesKHR(physicalDevice:
                                                            VkPhysicalDevice,
                                                        pPropertyCount:
                                                            *mut u32,
                                                        pProperties:
                                                            *mut VkDisplayPlanePropertiesKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayPlaneSupportedDisplaysKHR(physicalDevice:
                                                     VkPhysicalDevice,
                                                 planeIndex: u32,
                                                 pDisplayCount: *mut u32,
                                                 pDisplays: *mut VkDisplayKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayModePropertiesKHR(physicalDevice: VkPhysicalDevice,
                                         display: VkDisplayKHR,
                                         pPropertyCount: *mut u32,
                                         pProperties:
                                             *mut VkDisplayModePropertiesKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkCreateDisplayModeKHR(physicalDevice: VkPhysicalDevice,
                                  display: VkDisplayKHR,
                                  pCreateInfo:
                                      *const VkDisplayModeCreateInfoKHR,
                                  pAllocator: *const VkAllocationCallbacks,
                                  pMode: *mut VkDisplayModeKHR) -> VkResult;
}
extern "C" {
    pub fn vkGetDisplayPlaneCapabilitiesKHR(physicalDevice: VkPhysicalDevice,
                                            mode: VkDisplayModeKHR,
                                            planeIndex: u32,
                                            pCapabilities:
                                                *mut VkDisplayPlaneCapabilitiesKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkCreateDisplayPlaneSurfaceKHR(instance: VkInstance,
                                          pCreateInfo:
                                              *const VkDisplaySurfaceCreateInfoKHR,
                                          pAllocator:
                                              *const VkAllocationCallbacks,
                                          pSurface: *mut VkSurfaceKHR)
     -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayPresentInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcRect: VkRect2D,
    pub dstRect: VkRect2D,
    pub persistent: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDisplayPresentInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkDisplayPresentInfoKHR>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDisplayPresentInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkDisplayPresentInfoKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDisplayPresentInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPresentInfoKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPresentInfoKHR
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPresentInfoKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPresentInfoKHR
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPresentInfoKHR ) ) . srcRect as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPresentInfoKHR
                ) , "::" , stringify ! ( srcRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPresentInfoKHR ) ) . dstRect as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPresentInfoKHR
                ) , "::" , stringify ! ( dstRect ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPresentInfoKHR ) ) . persistent
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPresentInfoKHR
                ) , "::" , stringify ! ( persistent ) ));
}
impl Clone for VkDisplayPresentInfoKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCreateSharedSwapchainsKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchainCount: u32,
                                               pCreateInfos:
                                                   *const VkSwapchainCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pSwapchains:
                                                   *mut VkSwapchainKHR)
                              -> VkResult>;
extern "C" {
    pub fn vkCreateSharedSwapchainsKHR(device: VkDevice, swapchainCount: u32,
                                       pCreateInfos:
                                           *const VkSwapchainCreateInfoKHR,
                                       pAllocator:
                                           *const VkAllocationCallbacks,
                                       pSwapchains: *mut VkSwapchainKHR)
     -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceFeatures2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub features: VkPhysicalDeviceFeatures,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceFeatures2KHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceFeatures2KHR>() ,
               240usize , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceFeatures2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceFeatures2KHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkPhysicalDeviceFeatures2KHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures2KHR ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures2KHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures2KHR ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures2KHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceFeatures2KHR ) ) .
                features as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceFeatures2KHR ) , "::" , stringify ! ( features
                ) ));
}
impl Clone for VkPhysicalDeviceFeatures2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Copy)]
pub struct VkPhysicalDeviceProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub properties: VkPhysicalDeviceProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceProperties2KHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceProperties2KHR>() ,
               840usize , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceProperties2KHR )
               ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceProperties2KHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkPhysicalDeviceProperties2KHR
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties2KHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties2KHR ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties2KHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties2KHR ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceProperties2KHR ) ) .
                properties as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceProperties2KHR ) , "::" , stringify ! (
                properties ) ));
}
impl Clone for VkPhysicalDeviceProperties2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkFormatProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub formatProperties: VkFormatProperties,
}
#[test]
fn bindgen_test_layout_VkFormatProperties2KHR() {
    assert_eq!(::std::mem::size_of::<VkFormatProperties2KHR>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( VkFormatProperties2KHR )
               ));
    assert_eq! (::std::mem::align_of::<VkFormatProperties2KHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkFormatProperties2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFormatProperties2KHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFormatProperties2KHR
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFormatProperties2KHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFormatProperties2KHR
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFormatProperties2KHR ) ) .
                formatProperties as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkFormatProperties2KHR
                ) , "::" , stringify ! ( formatProperties ) ));
}
impl Clone for VkFormatProperties2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageFormatProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub imageFormatProperties: VkImageFormatProperties,
}
#[test]
fn bindgen_test_layout_VkImageFormatProperties2KHR() {
    assert_eq!(::std::mem::size_of::<VkImageFormatProperties2KHR>() , 48usize
               , concat ! (
               "Size of: " , stringify ! ( VkImageFormatProperties2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkImageFormatProperties2KHR>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkImageFormatProperties2KHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageFormatProperties2KHR ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageFormatProperties2KHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageFormatProperties2KHR ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageFormatProperties2KHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageFormatProperties2KHR ) ) .
                imageFormatProperties as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkImageFormatProperties2KHR ) , "::" , stringify ! (
                imageFormatProperties ) ));
}
impl Clone for VkImageFormatProperties2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceImageFormatInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
    pub type_: VkImageType,
    pub tiling: VkImageTiling,
    pub usage: VkImageUsageFlags,
    pub flags: VkImageCreateFlags,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceImageFormatInfo2KHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceImageFormatInfo2KHR>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceImageFormatInfo2KHR
               ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceImageFormatInfo2KHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceImageFormatInfo2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceImageFormatInfo2KHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceImageFormatInfo2KHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceImageFormatInfo2KHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceImageFormatInfo2KHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceImageFormatInfo2KHR ) ) .
                format as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceImageFormatInfo2KHR ) , "::" , stringify ! (
                format ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceImageFormatInfo2KHR ) ) .
                type_ as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceImageFormatInfo2KHR ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceImageFormatInfo2KHR ) ) .
                tiling as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceImageFormatInfo2KHR ) , "::" , stringify ! (
                tiling ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceImageFormatInfo2KHR ) ) .
                usage as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceImageFormatInfo2KHR ) , "::" , stringify ! (
                usage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceImageFormatInfo2KHR ) ) .
                flags as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceImageFormatInfo2KHR ) , "::" , stringify ! (
                flags ) ));
}
impl Clone for VkPhysicalDeviceImageFormatInfo2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkQueueFamilyProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub queueFamilyProperties: VkQueueFamilyProperties,
}
#[test]
fn bindgen_test_layout_VkQueueFamilyProperties2KHR() {
    assert_eq!(::std::mem::size_of::<VkQueueFamilyProperties2KHR>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( VkQueueFamilyProperties2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkQueueFamilyProperties2KHR>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkQueueFamilyProperties2KHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueueFamilyProperties2KHR ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkQueueFamilyProperties2KHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueueFamilyProperties2KHR ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkQueueFamilyProperties2KHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkQueueFamilyProperties2KHR ) ) .
                queueFamilyProperties as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkQueueFamilyProperties2KHR ) , "::" , stringify ! (
                queueFamilyProperties ) ));
}
impl Clone for VkQueueFamilyProperties2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceMemoryProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryProperties: VkPhysicalDeviceMemoryProperties,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMemoryProperties2KHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceMemoryProperties2KHR>() ,
               536usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceMemoryProperties2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceMemoryProperties2KHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceMemoryProperties2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMemoryProperties2KHR ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMemoryProperties2KHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMemoryProperties2KHR ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMemoryProperties2KHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMemoryProperties2KHR ) )
                . memoryProperties as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMemoryProperties2KHR ) , "::" , stringify ! (
                memoryProperties ) ));
}
impl Clone for VkPhysicalDeviceMemoryProperties2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseImageFormatProperties2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub properties: VkSparseImageFormatProperties,
}
#[test]
fn bindgen_test_layout_VkSparseImageFormatProperties2KHR() {
    assert_eq!(::std::mem::size_of::<VkSparseImageFormatProperties2KHR>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( VkSparseImageFormatProperties2KHR )
               ));
    assert_eq! (::std::mem::align_of::<VkSparseImageFormatProperties2KHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkSparseImageFormatProperties2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageFormatProperties2KHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageFormatProperties2KHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageFormatProperties2KHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageFormatProperties2KHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageFormatProperties2KHR ) ) .
                properties as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageFormatProperties2KHR ) , "::" , stringify ! (
                properties ) ));
}
impl Clone for VkSparseImageFormatProperties2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceSparseImageFormatInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub format: VkFormat,
    pub type_: VkImageType,
    pub samples: VkSampleCountFlagBits,
    pub usage: VkImageUsageFlags,
    pub tiling: VkImageTiling,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSparseImageFormatInfo2KHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceSparseImageFormatInfo2KHR>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceSparseImageFormatInfo2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceSparseImageFormatInfo2KHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceSparseImageFormatInfo2KHR ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceSparseImageFormatInfo2KHR ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseImageFormatInfo2KHR ) , "::" , stringify
                ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceSparseImageFormatInfo2KHR ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseImageFormatInfo2KHR ) , "::" , stringify
                ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceSparseImageFormatInfo2KHR ) )
                . format as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseImageFormatInfo2KHR ) , "::" , stringify
                ! ( format ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceSparseImageFormatInfo2KHR ) )
                . type_ as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseImageFormatInfo2KHR ) , "::" , stringify
                ! ( type_ ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceSparseImageFormatInfo2KHR ) )
                . samples as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseImageFormatInfo2KHR ) , "::" , stringify
                ! ( samples ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceSparseImageFormatInfo2KHR ) )
                . usage as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseImageFormatInfo2KHR ) , "::" , stringify
                ! ( usage ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceSparseImageFormatInfo2KHR ) )
                . tiling as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSparseImageFormatInfo2KHR ) , "::" , stringify
                ! ( tiling ) ));
}
impl Clone for VkPhysicalDeviceSparseImageFormatInfo2KHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetPhysicalDeviceFeatures2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pFeatures:
                                                   *mut VkPhysicalDeviceFeatures2KHR)>;
pub type PFN_vkGetPhysicalDeviceProperties2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pProperties:
                                                   *mut VkPhysicalDeviceProperties2KHR)>;
pub type PFN_vkGetPhysicalDeviceFormatProperties2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               pFormatProperties:
                                                   *mut VkFormatProperties2KHR)>;
pub type PFN_vkGetPhysicalDeviceImageFormatProperties2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pImageFormatInfo:
                                                   *const VkPhysicalDeviceImageFormatInfo2KHR,
                                               pImageFormatProperties:
                                                   *mut VkImageFormatProperties2KHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceQueueFamilyProperties2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pQueueFamilyPropertyCount:
                                                   *mut u32,
                                               pQueueFamilyProperties:
                                                   *mut VkQueueFamilyProperties2KHR)>;
pub type PFN_vkGetPhysicalDeviceMemoryProperties2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pMemoryProperties:
                                                   *mut VkPhysicalDeviceMemoryProperties2KHR)>;
pub type PFN_vkGetPhysicalDeviceSparseImageFormatProperties2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pFormatInfo:
                                                   *const VkPhysicalDeviceSparseImageFormatInfo2KHR,
                                               pPropertyCount: *mut u32,
                                               pProperties:
                                                   *mut VkSparseImageFormatProperties2KHR)>;
extern "C" {
    pub fn vkGetPhysicalDeviceFeatures2KHR(physicalDevice: VkPhysicalDevice,
                                           pFeatures:
                                               *mut VkPhysicalDeviceFeatures2KHR);
}
extern "C" {
    pub fn vkGetPhysicalDeviceProperties2KHR(physicalDevice: VkPhysicalDevice,
                                             pProperties:
                                                 *mut VkPhysicalDeviceProperties2KHR);
}
extern "C" {
    pub fn vkGetPhysicalDeviceFormatProperties2KHR(physicalDevice:
                                                       VkPhysicalDevice,
                                                   format: VkFormat,
                                                   pFormatProperties:
                                                       *mut VkFormatProperties2KHR);
}
extern "C" {
    pub fn vkGetPhysicalDeviceImageFormatProperties2KHR(physicalDevice:
                                                            VkPhysicalDevice,
                                                        pImageFormatInfo:
                                                            *const VkPhysicalDeviceImageFormatInfo2KHR,
                                                        pImageFormatProperties:
                                                            *mut VkImageFormatProperties2KHR)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceQueueFamilyProperties2KHR(physicalDevice:
                                                            VkPhysicalDevice,
                                                        pQueueFamilyPropertyCount:
                                                            *mut u32,
                                                        pQueueFamilyProperties:
                                                            *mut VkQueueFamilyProperties2KHR);
}
extern "C" {
    pub fn vkGetPhysicalDeviceMemoryProperties2KHR(physicalDevice:
                                                       VkPhysicalDevice,
                                                   pMemoryProperties:
                                                       *mut VkPhysicalDeviceMemoryProperties2KHR);
}
extern "C" {
    pub fn vkGetPhysicalDeviceSparseImageFormatProperties2KHR(physicalDevice:
                                                                  VkPhysicalDevice,
                                                              pFormatInfo:
                                                                  *const VkPhysicalDeviceSparseImageFormatInfo2KHR,
                                                              pPropertyCount:
                                                                  *mut u32,
                                                              pProperties:
                                                                  *mut VkSparseImageFormatProperties2KHR);
}
pub type VkCommandPoolTrimFlagsKHR = VkFlags;
pub type PFN_vkTrimCommandPoolKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               commandPool: VkCommandPool,
                                               flags:
                                                   VkCommandPoolTrimFlagsKHR)>;
extern "C" {
    pub fn vkTrimCommandPoolKHR(device: VkDevice, commandPool: VkCommandPool,
                                flags: VkCommandPoolTrimFlagsKHR);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkExternalMemoryHandleTypeFlagBitsKHR {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 2,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 4,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_BIT_KHR = 8,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_TEXTURE_KMT_BIT_KHR = 16,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_HEAP_BIT_KHR = 32,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D12_RESOURCE_BIT_KHR = 64,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkExternalMemoryHandleTypeFlagsKHR = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkExternalMemoryFeatureFlagBitsKHR {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_KHR = 1,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_KHR = 2,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_KHR = 4,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkExternalMemoryFeatureFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalMemoryPropertiesKHR {
    pub externalMemoryFeatures: VkExternalMemoryFeatureFlagsKHR,
    pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsKHR,
    pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryPropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkExternalMemoryPropertiesKHR>() ,
               12usize , concat ! (
               "Size of: " , stringify ! ( VkExternalMemoryPropertiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkExternalMemoryPropertiesKHR>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! ( VkExternalMemoryPropertiesKHR
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryPropertiesKHR ) ) .
                externalMemoryFeatures as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryPropertiesKHR ) , "::" , stringify ! (
                externalMemoryFeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryPropertiesKHR ) ) .
                exportFromImportedHandleTypes as * const _ as usize } , 4usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryPropertiesKHR ) , "::" , stringify ! (
                exportFromImportedHandleTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryPropertiesKHR ) ) .
                compatibleHandleTypes as * const _ as usize } , 8usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryPropertiesKHR ) , "::" , stringify ! (
                compatibleHandleTypes ) ));
}
impl Clone for VkExternalMemoryPropertiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceExternalImageFormatInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalImageFormatInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceExternalImageFormatInfoKHR>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceExternalImageFormatInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceExternalImageFormatInfoKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceExternalImageFormatInfoKHR ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceExternalImageFormatInfoKHR )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalImageFormatInfoKHR ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceExternalImageFormatInfoKHR )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalImageFormatInfoKHR ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceExternalImageFormatInfoKHR )
                ) . handleType as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalImageFormatInfoKHR ) , "::" ,
                stringify ! ( handleType ) ));
}
impl Clone for VkPhysicalDeviceExternalImageFormatInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalImageFormatPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub externalMemoryProperties: VkExternalMemoryPropertiesKHR,
}
#[test]
fn bindgen_test_layout_VkExternalImageFormatPropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkExternalImageFormatPropertiesKHR>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkExternalImageFormatPropertiesKHR
               ) ));
    assert_eq! (::std::mem::align_of::<VkExternalImageFormatPropertiesKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkExternalImageFormatPropertiesKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalImageFormatPropertiesKHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalImageFormatPropertiesKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalImageFormatPropertiesKHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalImageFormatPropertiesKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalImageFormatPropertiesKHR ) ) .
                externalMemoryProperties as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalImageFormatPropertiesKHR ) , "::" , stringify ! (
                externalMemoryProperties ) ));
}
impl Clone for VkExternalImageFormatPropertiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceExternalBufferInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkBufferCreateFlags,
    pub usage: VkBufferUsageFlags,
    pub handleType: VkExternalMemoryHandleTypeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalBufferInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceExternalBufferInfoKHR>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceExternalBufferInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceExternalBufferInfoKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceExternalBufferInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceExternalBufferInfoKHR ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalBufferInfoKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceExternalBufferInfoKHR ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalBufferInfoKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceExternalBufferInfoKHR ) )
                . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalBufferInfoKHR ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceExternalBufferInfoKHR ) )
                . usage as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalBufferInfoKHR ) , "::" , stringify ! (
                usage ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceExternalBufferInfoKHR ) )
                . handleType as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalBufferInfoKHR ) , "::" , stringify ! (
                handleType ) ));
}
impl Clone for VkPhysicalDeviceExternalBufferInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalBufferPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub externalMemoryProperties: VkExternalMemoryPropertiesKHR,
}
#[test]
fn bindgen_test_layout_VkExternalBufferPropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkExternalBufferPropertiesKHR>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkExternalBufferPropertiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkExternalBufferPropertiesKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkExternalBufferPropertiesKHR
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalBufferPropertiesKHR ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalBufferPropertiesKHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalBufferPropertiesKHR ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalBufferPropertiesKHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalBufferPropertiesKHR ) ) .
                externalMemoryProperties as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalBufferPropertiesKHR ) , "::" , stringify ! (
                externalMemoryProperties ) ));
}
impl Clone for VkExternalBufferPropertiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceIDPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub deviceUUID: [u8; 16usize],
    pub driverUUID: [u8; 16usize],
    pub deviceLUID: [u8; 8usize],
    pub deviceNodeMask: u32,
    pub deviceLUIDValid: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceIDPropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceIDPropertiesKHR>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceIDPropertiesKHR )
               ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceIDPropertiesKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceIDPropertiesKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceIDPropertiesKHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceIDPropertiesKHR ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceIDPropertiesKHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceIDPropertiesKHR ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceIDPropertiesKHR ) ) .
                deviceUUID as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceIDPropertiesKHR ) , "::" , stringify ! (
                deviceUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceIDPropertiesKHR ) ) .
                driverUUID as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceIDPropertiesKHR ) , "::" , stringify ! (
                driverUUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceIDPropertiesKHR ) ) .
                deviceLUID as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceIDPropertiesKHR ) , "::" , stringify ! (
                deviceLUID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceIDPropertiesKHR ) ) .
                deviceNodeMask as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceIDPropertiesKHR ) , "::" , stringify ! (
                deviceNodeMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceIDPropertiesKHR ) ) .
                deviceLUIDValid as * const _ as usize } , 60usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceIDPropertiesKHR ) , "::" , stringify ! (
                deviceLUIDValid ) ));
}
impl Clone for VkPhysicalDeviceIDPropertiesKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetPhysicalDeviceExternalBufferPropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pExternalBufferInfo:
                                                   *const VkPhysicalDeviceExternalBufferInfoKHR,
                                               pExternalBufferProperties:
                                                   *mut VkExternalBufferPropertiesKHR)>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalBufferPropertiesKHR(physicalDevice:
                                                              VkPhysicalDevice,
                                                          pExternalBufferInfo:
                                                              *const VkPhysicalDeviceExternalBufferInfoKHR,
                                                          pExternalBufferProperties:
                                                              *mut VkExternalBufferPropertiesKHR);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalMemoryImageCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryImageCreateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkExternalMemoryImageCreateInfoKHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkExternalMemoryImageCreateInfoKHR
               ) ));
    assert_eq! (::std::mem::align_of::<VkExternalMemoryImageCreateInfoKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkExternalMemoryImageCreateInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryImageCreateInfoKHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryImageCreateInfoKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryImageCreateInfoKHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryImageCreateInfoKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryImageCreateInfoKHR ) ) .
                handleTypes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryImageCreateInfoKHR ) , "::" , stringify ! (
                handleTypes ) ));
}
impl Clone for VkExternalMemoryImageCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalMemoryBufferCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryBufferCreateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkExternalMemoryBufferCreateInfoKHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkExternalMemoryBufferCreateInfoKHR
               ) ));
    assert_eq! (::std::mem::align_of::<VkExternalMemoryBufferCreateInfoKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkExternalMemoryBufferCreateInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryBufferCreateInfoKHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryBufferCreateInfoKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryBufferCreateInfoKHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryBufferCreateInfoKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryBufferCreateInfoKHR ) ) .
                handleTypes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryBufferCreateInfoKHR ) , "::" , stringify ! (
                handleTypes ) ));
}
impl Clone for VkExternalMemoryBufferCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExportMemoryAllocateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkExportMemoryAllocateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkExportMemoryAllocateInfoKHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkExportMemoryAllocateInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkExportMemoryAllocateInfoKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkExportMemoryAllocateInfoKHR
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportMemoryAllocateInfoKHR ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportMemoryAllocateInfoKHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportMemoryAllocateInfoKHR ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportMemoryAllocateInfoKHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportMemoryAllocateInfoKHR ) ) .
                handleTypes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportMemoryAllocateInfoKHR ) , "::" , stringify ! (
                handleTypes ) ));
}
impl Clone for VkExportMemoryAllocateInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImportMemoryFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalMemoryHandleTypeFlagBitsKHR,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportMemoryFdInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkImportMemoryFdInfoKHR>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( VkImportMemoryFdInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkImportMemoryFdInfoKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkImportMemoryFdInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportMemoryFdInfoKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportMemoryFdInfoKHR
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportMemoryFdInfoKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportMemoryFdInfoKHR
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportMemoryFdInfoKHR ) ) . handleType
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportMemoryFdInfoKHR
                ) , "::" , stringify ! ( handleType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportMemoryFdInfoKHR ) ) . fd as *
                const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportMemoryFdInfoKHR
                ) , "::" , stringify ! ( fd ) ));
}
impl Clone for VkImportMemoryFdInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryFdPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryTypeBits: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryFdPropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkMemoryFdPropertiesKHR>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( VkMemoryFdPropertiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkMemoryFdPropertiesKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkMemoryFdPropertiesKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryFdPropertiesKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryFdPropertiesKHR
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryFdPropertiesKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryFdPropertiesKHR
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryFdPropertiesKHR ) ) .
                memoryTypeBits as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryFdPropertiesKHR
                ) , "::" , stringify ! ( memoryTypeBits ) ));
}
impl Clone for VkMemoryFdPropertiesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub memory: VkDeviceMemory,
    pub handleType: VkExternalMemoryHandleTypeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkMemoryGetFdInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkMemoryGetFdInfoKHR>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( VkMemoryGetFdInfoKHR )
               ));
    assert_eq! (::std::mem::align_of::<VkMemoryGetFdInfoKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkMemoryGetFdInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryGetFdInfoKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryGetFdInfoKHR )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryGetFdInfoKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryGetFdInfoKHR )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryGetFdInfoKHR ) ) . memory as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryGetFdInfoKHR )
                , "::" , stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryGetFdInfoKHR ) ) . handleType as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkMemoryGetFdInfoKHR )
                , "::" , stringify ! ( handleType ) ));
}
impl Clone for VkMemoryGetFdInfoKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetMemoryFdKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pGetFdInfo:
                                                   *const VkMemoryGetFdInfoKHR,
                                               pFd:
                                                   *mut ::std::os::raw::c_int)
                              -> VkResult>;
pub type PFN_vkGetMemoryFdPropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               handleType:
                                                   VkExternalMemoryHandleTypeFlagBitsKHR,
                                               fd: ::std::os::raw::c_int,
                                               pMemoryFdProperties:
                                                   *mut VkMemoryFdPropertiesKHR)
                              -> VkResult>;
extern "C" {
    pub fn vkGetMemoryFdKHR(device: VkDevice,
                            pGetFdInfo: *const VkMemoryGetFdInfoKHR,
                            pFd: *mut ::std::os::raw::c_int) -> VkResult;
}
extern "C" {
    pub fn vkGetMemoryFdPropertiesKHR(device: VkDevice,
                                      handleType:
                                          VkExternalMemoryHandleTypeFlagBitsKHR,
                                      fd: ::std::os::raw::c_int,
                                      pMemoryFdProperties:
                                          *mut VkMemoryFdPropertiesKHR)
     -> VkResult;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkExternalSemaphoreHandleTypeFlagBitsKHR {
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 2,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 4,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_D3D12_FENCE_BIT_KHR = 8,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 16,
    VK_EXTERNAL_SEMAPHORE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkExternalSemaphoreHandleTypeFlagsKHR = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkExternalSemaphoreFeatureFlagBitsKHR {
    VK_EXTERNAL_SEMAPHORE_FEATURE_EXPORTABLE_BIT_KHR = 1,
    VK_EXTERNAL_SEMAPHORE_FEATURE_IMPORTABLE_BIT_KHR = 2,
    VK_EXTERNAL_SEMAPHORE_FEATURE_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkExternalSemaphoreFeatureFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceExternalSemaphoreInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalSemaphoreInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceExternalSemaphoreInfoKHR>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceExternalSemaphoreInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceExternalSemaphoreInfoKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceExternalSemaphoreInfoKHR ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceExternalSemaphoreInfoKHR ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalSemaphoreInfoKHR ) , "::" , stringify
                ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceExternalSemaphoreInfoKHR ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalSemaphoreInfoKHR ) , "::" , stringify
                ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceExternalSemaphoreInfoKHR ) )
                . handleType as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalSemaphoreInfoKHR ) , "::" , stringify
                ! ( handleType ) ));
}
impl Clone for VkPhysicalDeviceExternalSemaphoreInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalSemaphorePropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub exportFromImportedHandleTypes: VkExternalSemaphoreHandleTypeFlagsKHR,
    pub compatibleHandleTypes: VkExternalSemaphoreHandleTypeFlagsKHR,
    pub externalSemaphoreFeatures: VkExternalSemaphoreFeatureFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkExternalSemaphorePropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkExternalSemaphorePropertiesKHR>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkExternalSemaphorePropertiesKHR )
               ));
    assert_eq! (::std::mem::align_of::<VkExternalSemaphorePropertiesKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkExternalSemaphorePropertiesKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalSemaphorePropertiesKHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalSemaphorePropertiesKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalSemaphorePropertiesKHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalSemaphorePropertiesKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalSemaphorePropertiesKHR ) ) .
                exportFromImportedHandleTypes as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalSemaphorePropertiesKHR ) , "::" , stringify ! (
                exportFromImportedHandleTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalSemaphorePropertiesKHR ) ) .
                compatibleHandleTypes as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalSemaphorePropertiesKHR ) , "::" , stringify ! (
                compatibleHandleTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalSemaphorePropertiesKHR ) ) .
                externalSemaphoreFeatures as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalSemaphorePropertiesKHR ) , "::" , stringify ! (
                externalSemaphoreFeatures ) ));
}
impl Clone for VkExternalSemaphorePropertiesKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetPhysicalDeviceExternalSemaphorePropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pExternalSemaphoreInfo:
                                                   *const VkPhysicalDeviceExternalSemaphoreInfoKHR,
                                               pExternalSemaphoreProperties:
                                                   *mut VkExternalSemaphorePropertiesKHR)>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalSemaphorePropertiesKHR(physicalDevice:
                                                                 VkPhysicalDevice,
                                                             pExternalSemaphoreInfo:
                                                                 *const VkPhysicalDeviceExternalSemaphoreInfoKHR,
                                                             pExternalSemaphoreProperties:
                                                                 *mut VkExternalSemaphorePropertiesKHR);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSemaphoreImportFlagBitsKHR {
    VK_SEMAPHORE_IMPORT_TEMPORARY_BIT_KHR = 1,
    VK_SEMAPHORE_IMPORT_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkSemaphoreImportFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExportSemaphoreCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalSemaphoreHandleTypeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkExportSemaphoreCreateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkExportSemaphoreCreateInfoKHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkExportSemaphoreCreateInfoKHR )
               ));
    assert_eq! (::std::mem::align_of::<VkExportSemaphoreCreateInfoKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkExportSemaphoreCreateInfoKHR
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportSemaphoreCreateInfoKHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportSemaphoreCreateInfoKHR ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportSemaphoreCreateInfoKHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportSemaphoreCreateInfoKHR ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportSemaphoreCreateInfoKHR ) ) .
                handleTypes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportSemaphoreCreateInfoKHR ) , "::" , stringify ! (
                handleTypes ) ));
}
impl Clone for VkExportSemaphoreCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImportSemaphoreFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub flags: VkSemaphoreImportFlagsKHR,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBitsKHR,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportSemaphoreFdInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkImportSemaphoreFdInfoKHR>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( VkImportSemaphoreFdInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkImportSemaphoreFdInfoKHR>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkImportSemaphoreFdInfoKHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportSemaphoreFdInfoKHR ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImportSemaphoreFdInfoKHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportSemaphoreFdInfoKHR ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImportSemaphoreFdInfoKHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportSemaphoreFdInfoKHR ) ) .
                semaphore as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImportSemaphoreFdInfoKHR ) , "::" , stringify ! ( semaphore
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportSemaphoreFdInfoKHR ) ) . flags as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImportSemaphoreFdInfoKHR ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportSemaphoreFdInfoKHR ) ) .
                handleType as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImportSemaphoreFdInfoKHR ) , "::" , stringify ! ( handleType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportSemaphoreFdInfoKHR ) ) . fd as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImportSemaphoreFdInfoKHR ) , "::" , stringify ! ( fd ) ));
}
impl Clone for VkImportSemaphoreFdInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSemaphoreGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub semaphore: VkSemaphore,
    pub handleType: VkExternalSemaphoreHandleTypeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkSemaphoreGetFdInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkSemaphoreGetFdInfoKHR>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( VkSemaphoreGetFdInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkSemaphoreGetFdInfoKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSemaphoreGetFdInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSemaphoreGetFdInfoKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSemaphoreGetFdInfoKHR
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSemaphoreGetFdInfoKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSemaphoreGetFdInfoKHR
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSemaphoreGetFdInfoKHR ) ) . semaphore
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSemaphoreGetFdInfoKHR
                ) , "::" , stringify ! ( semaphore ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSemaphoreGetFdInfoKHR ) ) . handleType
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSemaphoreGetFdInfoKHR
                ) , "::" , stringify ! ( handleType ) ));
}
impl Clone for VkSemaphoreGetFdInfoKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkImportSemaphoreFdKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pImportSemaphoreFdInfo:
                                                   *const VkImportSemaphoreFdInfoKHR)
                              -> VkResult>;
pub type PFN_vkGetSemaphoreFdKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pGetFdInfo:
                                                   *const VkSemaphoreGetFdInfoKHR,
                                               pFd:
                                                   *mut ::std::os::raw::c_int)
                              -> VkResult>;
extern "C" {
    pub fn vkImportSemaphoreFdKHR(device: VkDevice,
                                  pImportSemaphoreFdInfo:
                                      *const VkImportSemaphoreFdInfoKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkGetSemaphoreFdKHR(device: VkDevice,
                               pGetFdInfo: *const VkSemaphoreGetFdInfoKHR,
                               pFd: *mut ::std::os::raw::c_int) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDevicePushDescriptorPropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxPushDescriptors: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevicePushDescriptorPropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDevicePushDescriptorPropertiesKHR>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDevicePushDescriptorPropertiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDevicePushDescriptorPropertiesKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDevicePushDescriptorPropertiesKHR ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDevicePushDescriptorPropertiesKHR )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevicePushDescriptorPropertiesKHR ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDevicePushDescriptorPropertiesKHR )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevicePushDescriptorPropertiesKHR ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDevicePushDescriptorPropertiesKHR )
                ) . maxPushDescriptors as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevicePushDescriptorPropertiesKHR ) , "::" ,
                stringify ! ( maxPushDescriptors ) ));
}
impl Clone for VkPhysicalDevicePushDescriptorPropertiesKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCmdPushDescriptorSetKHR =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pipelineBindPoint:
                                                   VkPipelineBindPoint,
                                               layout: VkPipelineLayout,
                                               set: u32,
                                               descriptorWriteCount: u32,
                                               pDescriptorWrites:
                                                   *const VkWriteDescriptorSet)>;
extern "C" {
    pub fn vkCmdPushDescriptorSetKHR(commandBuffer: VkCommandBuffer,
                                     pipelineBindPoint: VkPipelineBindPoint,
                                     layout: VkPipelineLayout, set: u32,
                                     descriptorWriteCount: u32,
                                     pDescriptorWrites:
                                         *const VkWriteDescriptorSet);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDevice16BitStorageFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub storageBuffer16BitAccess: VkBool32,
    pub uniformAndStorageBuffer16BitAccess: VkBool32,
    pub storagePushConstant16: VkBool32,
    pub storageInputOutput16: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDevice16BitStorageFeaturesKHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDevice16BitStorageFeaturesKHR>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDevice16BitStorageFeaturesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDevice16BitStorageFeaturesKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDevice16BitStorageFeaturesKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDevice16BitStorageFeaturesKHR )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevice16BitStorageFeaturesKHR ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDevice16BitStorageFeaturesKHR )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevice16BitStorageFeaturesKHR ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDevice16BitStorageFeaturesKHR )
                ) . storageBuffer16BitAccess as * const _ as usize } , 16usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevice16BitStorageFeaturesKHR ) , "::" , stringify !
                ( storageBuffer16BitAccess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDevice16BitStorageFeaturesKHR )
                ) . uniformAndStorageBuffer16BitAccess as * const _ as usize }
                , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevice16BitStorageFeaturesKHR ) , "::" , stringify !
                ( uniformAndStorageBuffer16BitAccess ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDevice16BitStorageFeaturesKHR )
                ) . storagePushConstant16 as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevice16BitStorageFeaturesKHR ) , "::" , stringify !
                ( storagePushConstant16 ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDevice16BitStorageFeaturesKHR )
                ) . storageInputOutput16 as * const _ as usize } , 28usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDevice16BitStorageFeaturesKHR ) , "::" , stringify !
                ( storageInputOutput16 ) ));
}
impl Clone for VkPhysicalDevice16BitStorageFeaturesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkRectLayerKHR {
    pub offset: VkOffset2D,
    pub extent: VkExtent2D,
    pub layer: u32,
}
#[test]
fn bindgen_test_layout_VkRectLayerKHR() {
    assert_eq!(::std::mem::size_of::<VkRectLayerKHR>() , 20usize , concat ! (
               "Size of: " , stringify ! ( VkRectLayerKHR ) ));
    assert_eq! (::std::mem::align_of::<VkRectLayerKHR>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkRectLayerKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRectLayerKHR ) ) . offset as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRectLayerKHR ) , "::"
                , stringify ! ( offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRectLayerKHR ) ) . extent as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRectLayerKHR ) , "::"
                , stringify ! ( extent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRectLayerKHR ) ) . layer as * const _
                as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkRectLayerKHR ) , "::"
                , stringify ! ( layer ) ));
}
impl Clone for VkRectLayerKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPresentRegionKHR {
    pub rectangleCount: u32,
    pub pRectangles: *const VkRectLayerKHR,
}
#[test]
fn bindgen_test_layout_VkPresentRegionKHR() {
    assert_eq!(::std::mem::size_of::<VkPresentRegionKHR>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( VkPresentRegionKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPresentRegionKHR>() , 8usize , concat
                ! ( "Alignment of " , stringify ! ( VkPresentRegionKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentRegionKHR ) ) . rectangleCount
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentRegionKHR ) ,
                "::" , stringify ! ( rectangleCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentRegionKHR ) ) . pRectangles as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentRegionKHR ) ,
                "::" , stringify ! ( pRectangles ) ));
}
impl Clone for VkPresentRegionKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPresentRegionsKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pRegions: *const VkPresentRegionKHR,
}
#[test]
fn bindgen_test_layout_VkPresentRegionsKHR() {
    assert_eq!(::std::mem::size_of::<VkPresentRegionsKHR>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( VkPresentRegionsKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPresentRegionsKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkPresentRegionsKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentRegionsKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentRegionsKHR ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentRegionsKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentRegionsKHR ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentRegionsKHR ) ) . swapchainCount
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentRegionsKHR ) ,
                "::" , stringify ! ( swapchainCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentRegionsKHR ) ) . pRegions as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentRegionsKHR ) ,
                "::" , stringify ! ( pRegions ) ));
}
impl Clone for VkPresentRegionsKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDescriptorUpdateTemplateKHR_T {
    _unused: [u8; 0],
}
pub type VkDescriptorUpdateTemplateKHR = *mut VkDescriptorUpdateTemplateKHR_T;
pub const VkDescriptorUpdateTemplateTypeKHR_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_BEGIN_RANGE_KHR:
          VkDescriptorUpdateTemplateTypeKHR =
    VkDescriptorUpdateTemplateTypeKHR::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR;
pub const VkDescriptorUpdateTemplateTypeKHR_VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_END_RANGE_KHR:
          VkDescriptorUpdateTemplateTypeKHR =
    VkDescriptorUpdateTemplateTypeKHR::VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDescriptorUpdateTemplateTypeKHR {
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_DESCRIPTOR_SET_KHR = 0,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_PUSH_DESCRIPTORS_KHR = 1,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_RANGE_SIZE_KHR = 2,
    VK_DESCRIPTOR_UPDATE_TEMPLATE_TYPE_MAX_ENUM_KHR = 2147483647,
}
pub type VkDescriptorUpdateTemplateCreateFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorUpdateTemplateEntryKHR {
    pub dstBinding: u32,
    pub dstArrayElement: u32,
    pub descriptorCount: u32,
    pub descriptorType: VkDescriptorType,
    pub offset: usize,
    pub stride: usize,
}
#[test]
fn bindgen_test_layout_VkDescriptorUpdateTemplateEntryKHR() {
    assert_eq!(::std::mem::size_of::<VkDescriptorUpdateTemplateEntryKHR>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkDescriptorUpdateTemplateEntryKHR
               ) ));
    assert_eq! (::std::mem::align_of::<VkDescriptorUpdateTemplateEntryKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDescriptorUpdateTemplateEntryKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateEntryKHR ) ) .
                dstBinding as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateEntryKHR ) , "::" , stringify ! (
                dstBinding ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateEntryKHR ) ) .
                dstArrayElement as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateEntryKHR ) , "::" , stringify ! (
                dstArrayElement ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateEntryKHR ) ) .
                descriptorCount as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateEntryKHR ) , "::" , stringify ! (
                descriptorCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateEntryKHR ) ) .
                descriptorType as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateEntryKHR ) , "::" , stringify ! (
                descriptorType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateEntryKHR ) ) .
                offset as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateEntryKHR ) , "::" , stringify ! (
                offset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateEntryKHR ) ) .
                stride as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateEntryKHR ) , "::" , stringify ! (
                stride ) ));
}
impl Clone for VkDescriptorUpdateTemplateEntryKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDescriptorUpdateTemplateCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub flags: VkDescriptorUpdateTemplateCreateFlagsKHR,
    pub descriptorUpdateEntryCount: u32,
    pub pDescriptorUpdateEntries: *const VkDescriptorUpdateTemplateEntryKHR,
    pub templateType: VkDescriptorUpdateTemplateTypeKHR,
    pub descriptorSetLayout: VkDescriptorSetLayout,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub pipelineLayout: VkPipelineLayout,
    pub set: u32,
}
#[test]
fn bindgen_test_layout_VkDescriptorUpdateTemplateCreateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkDescriptorUpdateTemplateCreateInfoKHR>()
               , 72usize , concat ! (
               "Size of: " , stringify ! (
               VkDescriptorUpdateTemplateCreateInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkDescriptorUpdateTemplateCreateInfoKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . descriptorUpdateEntryCount as * const _ as usize } ,
                20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( descriptorUpdateEntryCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . pDescriptorUpdateEntries as * const _ as usize } , 24usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( pDescriptorUpdateEntries ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . templateType as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( templateType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . descriptorSetLayout as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( descriptorSetLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . pipelineBindPoint as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( pipelineBindPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . pipelineLayout as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( pipelineLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDescriptorUpdateTemplateCreateInfoKHR )
                ) . set as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDescriptorUpdateTemplateCreateInfoKHR ) , "::" , stringify !
                ( set ) ));
}
impl Clone for VkDescriptorUpdateTemplateCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCreateDescriptorUpdateTemplateKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkDescriptorUpdateTemplateCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pDescriptorUpdateTemplate:
                                                   *mut VkDescriptorUpdateTemplateKHR)
                              -> VkResult>;
pub type PFN_vkDestroyDescriptorUpdateTemplateKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorUpdateTemplate:
                                                   VkDescriptorUpdateTemplateKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkUpdateDescriptorSetWithTemplateKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               descriptorSet: VkDescriptorSet,
                                               descriptorUpdateTemplate:
                                                   VkDescriptorUpdateTemplateKHR,
                                               pData:
                                                   *const ::std::os::raw::c_void)>;
pub type PFN_vkCmdPushDescriptorSetWithTemplateKHR =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               descriptorUpdateTemplate:
                                                   VkDescriptorUpdateTemplateKHR,
                                               layout: VkPipelineLayout,
                                               set: u32,
                                               pData:
                                                   *const ::std::os::raw::c_void)>;
extern "C" {
    pub fn vkCreateDescriptorUpdateTemplateKHR(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkDescriptorUpdateTemplateCreateInfoKHR,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pDescriptorUpdateTemplate:
                                                   *mut VkDescriptorUpdateTemplateKHR)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyDescriptorUpdateTemplateKHR(device: VkDevice,
                                                descriptorUpdateTemplate:
                                                    VkDescriptorUpdateTemplateKHR,
                                                pAllocator:
                                                    *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkUpdateDescriptorSetWithTemplateKHR(device: VkDevice,
                                                descriptorSet:
                                                    VkDescriptorSet,
                                                descriptorUpdateTemplate:
                                                    VkDescriptorUpdateTemplateKHR,
                                                pData:
                                                    *const ::std::os::raw::c_void);
}
extern "C" {
    pub fn vkCmdPushDescriptorSetWithTemplateKHR(commandBuffer:
                                                     VkCommandBuffer,
                                                 descriptorUpdateTemplate:
                                                     VkDescriptorUpdateTemplateKHR,
                                                 layout: VkPipelineLayout,
                                                 set: u32,
                                                 pData:
                                                     *const ::std::os::raw::c_void);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSharedPresentSurfaceCapabilitiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub sharedPresentSupportedUsageFlags: VkImageUsageFlags,
}
#[test]
fn bindgen_test_layout_VkSharedPresentSurfaceCapabilitiesKHR() {
    assert_eq!(::std::mem::size_of::<VkSharedPresentSurfaceCapabilitiesKHR>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkSharedPresentSurfaceCapabilitiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkSharedPresentSurfaceCapabilitiesKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkSharedPresentSurfaceCapabilitiesKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSharedPresentSurfaceCapabilitiesKHR ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSharedPresentSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSharedPresentSurfaceCapabilitiesKHR ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSharedPresentSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSharedPresentSurfaceCapabilitiesKHR ) )
                . sharedPresentSupportedUsageFlags as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSharedPresentSurfaceCapabilitiesKHR ) , "::" , stringify ! (
                sharedPresentSupportedUsageFlags ) ));
}
impl Clone for VkSharedPresentSurfaceCapabilitiesKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetSwapchainStatusKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR)
                              -> VkResult>;
extern "C" {
    pub fn vkGetSwapchainStatusKHR(device: VkDevice,
                                   swapchain: VkSwapchainKHR) -> VkResult;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkExternalFenceHandleTypeFlagBitsKHR {
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_FD_BIT_KHR = 1,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_BIT_KHR = 2,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_KHR = 4,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_SYNC_FD_BIT_KHR = 8,
    VK_EXTERNAL_FENCE_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkExternalFenceHandleTypeFlagsKHR = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkExternalFenceFeatureFlagBitsKHR {
    VK_EXTERNAL_FENCE_FEATURE_EXPORTABLE_BIT_KHR = 1,
    VK_EXTERNAL_FENCE_FEATURE_IMPORTABLE_BIT_KHR = 2,
    VK_EXTERNAL_FENCE_FEATURE_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkExternalFenceFeatureFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceExternalFenceInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleType: VkExternalFenceHandleTypeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceExternalFenceInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceExternalFenceInfoKHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceExternalFenceInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceExternalFenceInfoKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceExternalFenceInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceExternalFenceInfoKHR ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalFenceInfoKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceExternalFenceInfoKHR ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalFenceInfoKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceExternalFenceInfoKHR ) )
                . handleType as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceExternalFenceInfoKHR ) , "::" , stringify ! (
                handleType ) ));
}
impl Clone for VkPhysicalDeviceExternalFenceInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalFencePropertiesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub exportFromImportedHandleTypes: VkExternalFenceHandleTypeFlagsKHR,
    pub compatibleHandleTypes: VkExternalFenceHandleTypeFlagsKHR,
    pub externalFenceFeatures: VkExternalFenceFeatureFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkExternalFencePropertiesKHR() {
    assert_eq!(::std::mem::size_of::<VkExternalFencePropertiesKHR>() , 32usize
               , concat ! (
               "Size of: " , stringify ! ( VkExternalFencePropertiesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkExternalFencePropertiesKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkExternalFencePropertiesKHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalFencePropertiesKHR ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalFencePropertiesKHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalFencePropertiesKHR ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalFencePropertiesKHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalFencePropertiesKHR ) ) .
                exportFromImportedHandleTypes as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalFencePropertiesKHR ) , "::" , stringify ! (
                exportFromImportedHandleTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalFencePropertiesKHR ) ) .
                compatibleHandleTypes as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalFencePropertiesKHR ) , "::" , stringify ! (
                compatibleHandleTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalFencePropertiesKHR ) ) .
                externalFenceFeatures as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalFencePropertiesKHR ) , "::" , stringify ! (
                externalFenceFeatures ) ));
}
impl Clone for VkExternalFencePropertiesKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetPhysicalDeviceExternalFencePropertiesKHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pExternalFenceInfo:
                                                   *const VkPhysicalDeviceExternalFenceInfoKHR,
                                               pExternalFenceProperties:
                                                   *mut VkExternalFencePropertiesKHR)>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalFencePropertiesKHR(physicalDevice:
                                                             VkPhysicalDevice,
                                                         pExternalFenceInfo:
                                                             *const VkPhysicalDeviceExternalFenceInfoKHR,
                                                         pExternalFenceProperties:
                                                             *mut VkExternalFencePropertiesKHR);
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkFenceImportFlagBitsKHR {
    VK_FENCE_IMPORT_TEMPORARY_BIT_KHR = 1,
    VK_FENCE_IMPORT_FLAG_BITS_MAX_ENUM_KHR = 2147483647,
}
pub type VkFenceImportFlagsKHR = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExportFenceCreateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalFenceHandleTypeFlagsKHR,
}
#[test]
fn bindgen_test_layout_VkExportFenceCreateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkExportFenceCreateInfoKHR>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( VkExportFenceCreateInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkExportFenceCreateInfoKHR>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkExportFenceCreateInfoKHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportFenceCreateInfoKHR ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportFenceCreateInfoKHR ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportFenceCreateInfoKHR ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportFenceCreateInfoKHR ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportFenceCreateInfoKHR ) ) .
                handleTypes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportFenceCreateInfoKHR ) , "::" , stringify ! (
                handleTypes ) ));
}
impl Clone for VkExportFenceCreateInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImportFenceFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fence: VkFence,
    pub flags: VkFenceImportFlagsKHR,
    pub handleType: VkExternalFenceHandleTypeFlagBitsKHR,
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_VkImportFenceFdInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkImportFenceFdInfoKHR>() , 40usize ,
               concat ! ( "Size of: " , stringify ! ( VkImportFenceFdInfoKHR )
               ));
    assert_eq! (::std::mem::align_of::<VkImportFenceFdInfoKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkImportFenceFdInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportFenceFdInfoKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportFenceFdInfoKHR
                ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportFenceFdInfoKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportFenceFdInfoKHR
                ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportFenceFdInfoKHR ) ) . fence as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportFenceFdInfoKHR
                ) , "::" , stringify ! ( fence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportFenceFdInfoKHR ) ) . flags as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportFenceFdInfoKHR
                ) , "::" , stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportFenceFdInfoKHR ) ) . handleType
                as * const _ as usize } , 28usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportFenceFdInfoKHR
                ) , "::" , stringify ! ( handleType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImportFenceFdInfoKHR ) ) . fd as *
                const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkImportFenceFdInfoKHR
                ) , "::" , stringify ! ( fd ) ));
}
impl Clone for VkImportFenceFdInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkFenceGetFdInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub fence: VkFence,
    pub handleType: VkExternalFenceHandleTypeFlagBitsKHR,
}
#[test]
fn bindgen_test_layout_VkFenceGetFdInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkFenceGetFdInfoKHR>() , 32usize , concat
               ! ( "Size of: " , stringify ! ( VkFenceGetFdInfoKHR ) ));
    assert_eq! (::std::mem::align_of::<VkFenceGetFdInfoKHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkFenceGetFdInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFenceGetFdInfoKHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFenceGetFdInfoKHR ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFenceGetFdInfoKHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFenceGetFdInfoKHR ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFenceGetFdInfoKHR ) ) . fence as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFenceGetFdInfoKHR ) ,
                "::" , stringify ! ( fence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkFenceGetFdInfoKHR ) ) . handleType as *
                const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! ( VkFenceGetFdInfoKHR ) ,
                "::" , stringify ! ( handleType ) ));
}
impl Clone for VkFenceGetFdInfoKHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkImportFenceFdKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pImportFenceFdInfo:
                                                   *const VkImportFenceFdInfoKHR)
                              -> VkResult>;
pub type PFN_vkGetFenceFdKHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pGetFdInfo:
                                                   *const VkFenceGetFdInfoKHR,
                                               pFd:
                                                   *mut ::std::os::raw::c_int)
                              -> VkResult>;
extern "C" {
    pub fn vkImportFenceFdKHR(device: VkDevice,
                              pImportFenceFdInfo:
                                  *const VkImportFenceFdInfoKHR) -> VkResult;
}
extern "C" {
    pub fn vkGetFenceFdKHR(device: VkDevice,
                           pGetFdInfo: *const VkFenceGetFdInfoKHR,
                           pFd: *mut ::std::os::raw::c_int) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceSurfaceInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub surface: VkSurfaceKHR,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSurfaceInfo2KHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceSurfaceInfo2KHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceSurfaceInfo2KHR )
               ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceSurfaceInfo2KHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceSurfaceInfo2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceSurfaceInfo2KHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSurfaceInfo2KHR ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceSurfaceInfo2KHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSurfaceInfo2KHR ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceSurfaceInfo2KHR ) ) .
                surface as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSurfaceInfo2KHR ) , "::" , stringify ! (
                surface ) ));
}
impl Clone for VkPhysicalDeviceSurfaceInfo2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSurfaceCapabilities2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub surfaceCapabilities: VkSurfaceCapabilitiesKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilities2KHR() {
    assert_eq!(::std::mem::size_of::<VkSurfaceCapabilities2KHR>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( VkSurfaceCapabilities2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkSurfaceCapabilities2KHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSurfaceCapabilities2KHR )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2KHR ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2KHR ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2KHR ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2KHR ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2KHR ) ) .
                surfaceCapabilities as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2KHR ) , "::" , stringify ! (
                surfaceCapabilities ) ));
}
impl Clone for VkSurfaceCapabilities2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSurfaceFormat2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub surfaceFormat: VkSurfaceFormatKHR,
}
#[test]
fn bindgen_test_layout_VkSurfaceFormat2KHR() {
    assert_eq!(::std::mem::size_of::<VkSurfaceFormat2KHR>() , 24usize , concat
               ! ( "Size of: " , stringify ! ( VkSurfaceFormat2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkSurfaceFormat2KHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSurfaceFormat2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceFormat2KHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSurfaceFormat2KHR ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceFormat2KHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSurfaceFormat2KHR ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceFormat2KHR ) ) . surfaceFormat
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkSurfaceFormat2KHR ) ,
                "::" , stringify ! ( surfaceFormat ) ));
}
impl Clone for VkSurfaceFormat2KHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilities2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pSurfaceInfo:
                                                   *const VkPhysicalDeviceSurfaceInfo2KHR,
                                               pSurfaceCapabilities:
                                                   *mut VkSurfaceCapabilities2KHR)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceSurfaceFormats2KHR =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pSurfaceInfo:
                                                   *const VkPhysicalDeviceSurfaceInfo2KHR,
                                               pSurfaceFormatCount: *mut u32,
                                               pSurfaceFormats:
                                                   *mut VkSurfaceFormat2KHR)
                              -> VkResult>;
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilities2KHR(physicalDevice:
                                                          VkPhysicalDevice,
                                                      pSurfaceInfo:
                                                          *const VkPhysicalDeviceSurfaceInfo2KHR,
                                                      pSurfaceCapabilities:
                                                          *mut VkSurfaceCapabilities2KHR)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceFormats2KHR(physicalDevice:
                                                     VkPhysicalDevice,
                                                 pSurfaceInfo:
                                                     *const VkPhysicalDeviceSurfaceInfo2KHR,
                                                 pSurfaceFormatCount:
                                                     *mut u32,
                                                 pSurfaceFormats:
                                                     *mut VkSurfaceFormat2KHR)
     -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceVariablePointerFeaturesKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub variablePointersStorageBuffer: VkBool32,
    pub variablePointers: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceVariablePointerFeaturesKHR() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceVariablePointerFeaturesKHR>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceVariablePointerFeaturesKHR ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceVariablePointerFeaturesKHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceVariablePointerFeaturesKHR ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceVariablePointerFeaturesKHR )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceVariablePointerFeaturesKHR ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceVariablePointerFeaturesKHR )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceVariablePointerFeaturesKHR ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceVariablePointerFeaturesKHR )
                ) . variablePointersStorageBuffer as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceVariablePointerFeaturesKHR ) , "::" ,
                stringify ! ( variablePointersStorageBuffer ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceVariablePointerFeaturesKHR )
                ) . variablePointers as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceVariablePointerFeaturesKHR ) , "::" ,
                stringify ! ( variablePointers ) ));
}
impl Clone for VkPhysicalDeviceVariablePointerFeaturesKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryDedicatedRequirementsKHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub prefersDedicatedAllocation: VkBool32,
    pub requiresDedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkMemoryDedicatedRequirementsKHR() {
    assert_eq!(::std::mem::size_of::<VkMemoryDedicatedRequirementsKHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkMemoryDedicatedRequirementsKHR )
               ));
    assert_eq! (::std::mem::align_of::<VkMemoryDedicatedRequirementsKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkMemoryDedicatedRequirementsKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryDedicatedRequirementsKHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryDedicatedRequirementsKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryDedicatedRequirementsKHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryDedicatedRequirementsKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryDedicatedRequirementsKHR ) ) .
                prefersDedicatedAllocation as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryDedicatedRequirementsKHR ) , "::" , stringify ! (
                prefersDedicatedAllocation ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryDedicatedRequirementsKHR ) ) .
                requiresDedicatedAllocation as * const _ as usize } , 20usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryDedicatedRequirementsKHR ) , "::" , stringify ! (
                requiresDedicatedAllocation ) ));
}
impl Clone for VkMemoryDedicatedRequirementsKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryDedicatedAllocateInfoKHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkMemoryDedicatedAllocateInfoKHR() {
    assert_eq!(::std::mem::size_of::<VkMemoryDedicatedAllocateInfoKHR>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkMemoryDedicatedAllocateInfoKHR )
               ));
    assert_eq! (::std::mem::align_of::<VkMemoryDedicatedAllocateInfoKHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkMemoryDedicatedAllocateInfoKHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryDedicatedAllocateInfoKHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryDedicatedAllocateInfoKHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryDedicatedAllocateInfoKHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryDedicatedAllocateInfoKHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryDedicatedAllocateInfoKHR ) ) .
                image as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryDedicatedAllocateInfoKHR ) , "::" , stringify ! (
                image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryDedicatedAllocateInfoKHR ) ) .
                buffer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryDedicatedAllocateInfoKHR ) , "::" , stringify ! (
                buffer ) ));
}
impl Clone for VkMemoryDedicatedAllocateInfoKHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBufferMemoryRequirementsInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkBufferMemoryRequirementsInfo2KHR() {
    assert_eq!(::std::mem::size_of::<VkBufferMemoryRequirementsInfo2KHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkBufferMemoryRequirementsInfo2KHR
               ) ));
    assert_eq! (::std::mem::align_of::<VkBufferMemoryRequirementsInfo2KHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkBufferMemoryRequirementsInfo2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryRequirementsInfo2KHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBufferMemoryRequirementsInfo2KHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryRequirementsInfo2KHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBufferMemoryRequirementsInfo2KHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBufferMemoryRequirementsInfo2KHR ) ) .
                buffer as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBufferMemoryRequirementsInfo2KHR ) , "::" , stringify ! (
                buffer ) ));
}
impl Clone for VkBufferMemoryRequirementsInfo2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageMemoryRequirementsInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
#[test]
fn bindgen_test_layout_VkImageMemoryRequirementsInfo2KHR() {
    assert_eq!(::std::mem::size_of::<VkImageMemoryRequirementsInfo2KHR>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkImageMemoryRequirementsInfo2KHR )
               ));
    assert_eq! (::std::mem::align_of::<VkImageMemoryRequirementsInfo2KHR>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkImageMemoryRequirementsInfo2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryRequirementsInfo2KHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageMemoryRequirementsInfo2KHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryRequirementsInfo2KHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageMemoryRequirementsInfo2KHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageMemoryRequirementsInfo2KHR ) ) .
                image as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageMemoryRequirementsInfo2KHR ) , "::" , stringify ! (
                image ) ));
}
impl Clone for VkImageMemoryRequirementsInfo2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageSparseMemoryRequirementsInfo2KHR {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
}
#[test]
fn bindgen_test_layout_VkImageSparseMemoryRequirementsInfo2KHR() {
    assert_eq!(::std::mem::size_of::<VkImageSparseMemoryRequirementsInfo2KHR>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkImageSparseMemoryRequirementsInfo2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkImageSparseMemoryRequirementsInfo2KHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkImageSparseMemoryRequirementsInfo2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSparseMemoryRequirementsInfo2KHR )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSparseMemoryRequirementsInfo2KHR ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSparseMemoryRequirementsInfo2KHR )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSparseMemoryRequirementsInfo2KHR ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSparseMemoryRequirementsInfo2KHR )
                ) . image as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSparseMemoryRequirementsInfo2KHR ) , "::" , stringify !
                ( image ) ));
}
impl Clone for VkImageSparseMemoryRequirementsInfo2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryRequirements2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryRequirements: VkMemoryRequirements,
}
#[test]
fn bindgen_test_layout_VkMemoryRequirements2KHR() {
    assert_eq!(::std::mem::size_of::<VkMemoryRequirements2KHR>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( VkMemoryRequirements2KHR ) ));
    assert_eq! (::std::mem::align_of::<VkMemoryRequirements2KHR>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkMemoryRequirements2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryRequirements2KHR ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryRequirements2KHR ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryRequirements2KHR ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryRequirements2KHR ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryRequirements2KHR ) ) .
                memoryRequirements as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkMemoryRequirements2KHR ) , "::" , stringify ! (
                memoryRequirements ) ));
}
impl Clone for VkMemoryRequirements2KHR {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSparseImageMemoryRequirements2KHR {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub memoryRequirements: VkSparseImageMemoryRequirements,
}
#[test]
fn bindgen_test_layout_VkSparseImageMemoryRequirements2KHR() {
    assert_eq!(::std::mem::size_of::<VkSparseImageMemoryRequirements2KHR>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( VkSparseImageMemoryRequirements2KHR
               ) ));
    assert_eq! (::std::mem::align_of::<VkSparseImageMemoryRequirements2KHR>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkSparseImageMemoryRequirements2KHR ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryRequirements2KHR ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryRequirements2KHR ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryRequirements2KHR ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryRequirements2KHR ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSparseImageMemoryRequirements2KHR ) ) .
                memoryRequirements as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSparseImageMemoryRequirements2KHR ) , "::" , stringify ! (
                memoryRequirements ) ));
}
impl Clone for VkSparseImageMemoryRequirements2KHR {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetImageMemoryRequirements2KHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pInfo:
                                                   *const VkImageMemoryRequirementsInfo2KHR,
                                               pMemoryRequirements:
                                                   *mut VkMemoryRequirements2KHR)>;
pub type PFN_vkGetBufferMemoryRequirements2KHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pInfo:
                                                   *const VkBufferMemoryRequirementsInfo2KHR,
                                               pMemoryRequirements:
                                                   *mut VkMemoryRequirements2KHR)>;
pub type PFN_vkGetImageSparseMemoryRequirements2KHR =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pInfo:
                                                   *const VkImageSparseMemoryRequirementsInfo2KHR,
                                               pSparseMemoryRequirementCount:
                                                   *mut u32,
                                               pSparseMemoryRequirements:
                                                   *mut VkSparseImageMemoryRequirements2KHR)>;
extern "C" {
    pub fn vkGetImageMemoryRequirements2KHR(device: VkDevice,
                                            pInfo:
                                                *const VkImageMemoryRequirementsInfo2KHR,
                                            pMemoryRequirements:
                                                *mut VkMemoryRequirements2KHR);
}
extern "C" {
    pub fn vkGetBufferMemoryRequirements2KHR(device: VkDevice,
                                             pInfo:
                                                 *const VkBufferMemoryRequirementsInfo2KHR,
                                             pMemoryRequirements:
                                                 *mut VkMemoryRequirements2KHR);
}
extern "C" {
    pub fn vkGetImageSparseMemoryRequirements2KHR(device: VkDevice,
                                                  pInfo:
                                                      *const VkImageSparseMemoryRequirementsInfo2KHR,
                                                  pSparseMemoryRequirementCount:
                                                      *mut u32,
                                                  pSparseMemoryRequirements:
                                                      *mut VkSparseImageMemoryRequirements2KHR);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkDebugReportCallbackEXT_T {
    _unused: [u8; 0],
}
pub type VkDebugReportCallbackEXT = *mut VkDebugReportCallbackEXT_T;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_BEGIN_RANGE_EXT:
          VkDebugReportObjectTypeEXT =
    VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT;
pub const VkDebugReportObjectTypeEXT_VK_DEBUG_REPORT_OBJECT_TYPE_END_RANGE_EXT:
          VkDebugReportObjectTypeEXT =
    VkDebugReportObjectTypeEXT::VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDebugReportObjectTypeEXT {
    VK_DEBUG_REPORT_OBJECT_TYPE_UNKNOWN_EXT = 0,
    VK_DEBUG_REPORT_OBJECT_TYPE_INSTANCE_EXT = 1,
    VK_DEBUG_REPORT_OBJECT_TYPE_PHYSICAL_DEVICE_EXT = 2,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_EXT = 3,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUEUE_EXT = 4,
    VK_DEBUG_REPORT_OBJECT_TYPE_SEMAPHORE_EXT = 5,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_BUFFER_EXT = 6,
    VK_DEBUG_REPORT_OBJECT_TYPE_FENCE_EXT = 7,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEVICE_MEMORY_EXT = 8,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_EXT = 9,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_EXT = 10,
    VK_DEBUG_REPORT_OBJECT_TYPE_EVENT_EXT = 11,
    VK_DEBUG_REPORT_OBJECT_TYPE_QUERY_POOL_EXT = 12,
    VK_DEBUG_REPORT_OBJECT_TYPE_BUFFER_VIEW_EXT = 13,
    VK_DEBUG_REPORT_OBJECT_TYPE_IMAGE_VIEW_EXT = 14,
    VK_DEBUG_REPORT_OBJECT_TYPE_SHADER_MODULE_EXT = 15,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_CACHE_EXT = 16,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_LAYOUT_EXT = 17,
    VK_DEBUG_REPORT_OBJECT_TYPE_RENDER_PASS_EXT = 18,
    VK_DEBUG_REPORT_OBJECT_TYPE_PIPELINE_EXT = 19,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_LAYOUT_EXT = 20,
    VK_DEBUG_REPORT_OBJECT_TYPE_SAMPLER_EXT = 21,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_POOL_EXT = 22,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_SET_EXT = 23,
    VK_DEBUG_REPORT_OBJECT_TYPE_FRAMEBUFFER_EXT = 24,
    VK_DEBUG_REPORT_OBJECT_TYPE_COMMAND_POOL_EXT = 25,
    VK_DEBUG_REPORT_OBJECT_TYPE_SURFACE_KHR_EXT = 26,
    VK_DEBUG_REPORT_OBJECT_TYPE_SWAPCHAIN_KHR_EXT = 27,
    VK_DEBUG_REPORT_OBJECT_TYPE_DEBUG_REPORT_CALLBACK_EXT_EXT = 28,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_KHR_EXT = 29,
    VK_DEBUG_REPORT_OBJECT_TYPE_DISPLAY_MODE_KHR_EXT = 30,
    VK_DEBUG_REPORT_OBJECT_TYPE_OBJECT_TABLE_NVX_EXT = 31,
    VK_DEBUG_REPORT_OBJECT_TYPE_INDIRECT_COMMANDS_LAYOUT_NVX_EXT = 32,
    VK_DEBUG_REPORT_OBJECT_TYPE_DESCRIPTOR_UPDATE_TEMPLATE_KHR_EXT =
        1000085000,
    VK_DEBUG_REPORT_OBJECT_TYPE_RANGE_SIZE_EXT = 33,
    VK_DEBUG_REPORT_OBJECT_TYPE_MAX_ENUM_EXT = 2147483647,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDebugReportFlagBitsEXT {
    VK_DEBUG_REPORT_INFORMATION_BIT_EXT = 1,
    VK_DEBUG_REPORT_WARNING_BIT_EXT = 2,
    VK_DEBUG_REPORT_PERFORMANCE_WARNING_BIT_EXT = 4,
    VK_DEBUG_REPORT_ERROR_BIT_EXT = 8,
    VK_DEBUG_REPORT_DEBUG_BIT_EXT = 16,
    VK_DEBUG_REPORT_FLAG_BITS_MAX_ENUM_EXT = 2147483647,
}
pub type VkDebugReportFlagsEXT = VkFlags;
pub type PFN_vkDebugReportCallbackEXT =
    ::std::option::Option<unsafe extern "C" fn(flags: VkDebugReportFlagsEXT,
                                               objectType:
                                                   VkDebugReportObjectTypeEXT,
                                               object: u64, location: usize,
                                               messageCode: i32,
                                               pLayerPrefix:
                                                   *const ::std::os::raw::c_char,
                                               pMessage:
                                                   *const ::std::os::raw::c_char,
                                               pUserData:
                                                   *mut ::std::os::raw::c_void)
                              -> VkBool32>;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDebugReportCallbackCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkDebugReportFlagsEXT,
    pub pfnCallback: PFN_vkDebugReportCallbackEXT,
    pub pUserData: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugReportCallbackCreateInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkDebugReportCallbackCreateInfoEXT>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( VkDebugReportCallbackCreateInfoEXT
               ) ));
    assert_eq! (::std::mem::align_of::<VkDebugReportCallbackCreateInfoEXT>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDebugReportCallbackCreateInfoEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugReportCallbackCreateInfoEXT ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugReportCallbackCreateInfoEXT ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugReportCallbackCreateInfoEXT ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugReportCallbackCreateInfoEXT ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugReportCallbackCreateInfoEXT ) ) .
                flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugReportCallbackCreateInfoEXT ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugReportCallbackCreateInfoEXT ) ) .
                pfnCallback as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugReportCallbackCreateInfoEXT ) , "::" , stringify ! (
                pfnCallback ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugReportCallbackCreateInfoEXT ) ) .
                pUserData as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugReportCallbackCreateInfoEXT ) , "::" , stringify ! (
                pUserData ) ));
}
impl Clone for VkDebugReportCallbackCreateInfoEXT {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCreateDebugReportCallbackEXT =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pCreateInfo:
                                                   *const VkDebugReportCallbackCreateInfoEXT,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pCallback:
                                                   *mut VkDebugReportCallbackEXT)
                              -> VkResult>;
pub type PFN_vkDestroyDebugReportCallbackEXT =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               callback:
                                                   VkDebugReportCallbackEXT,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkDebugReportMessageEXT =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               flags: VkDebugReportFlagsEXT,
                                               objectType:
                                                   VkDebugReportObjectTypeEXT,
                                               object: u64, location: usize,
                                               messageCode: i32,
                                               pLayerPrefix:
                                                   *const ::std::os::raw::c_char,
                                               pMessage:
                                                   *const ::std::os::raw::c_char)>;
extern "C" {
    pub fn vkCreateDebugReportCallbackEXT(instance: VkInstance,
                                          pCreateInfo:
                                              *const VkDebugReportCallbackCreateInfoEXT,
                                          pAllocator:
                                              *const VkAllocationCallbacks,
                                          pCallback:
                                              *mut VkDebugReportCallbackEXT)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyDebugReportCallbackEXT(instance: VkInstance,
                                           callback: VkDebugReportCallbackEXT,
                                           pAllocator:
                                               *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkDebugReportMessageEXT(instance: VkInstance,
                                   flags: VkDebugReportFlagsEXT,
                                   objectType: VkDebugReportObjectTypeEXT,
                                   object: u64, location: usize,
                                   messageCode: i32,
                                   pLayerPrefix:
                                       *const ::std::os::raw::c_char,
                                   pMessage: *const ::std::os::raw::c_char);
}
pub const VkRasterizationOrderAMD_VK_RASTERIZATION_ORDER_BEGIN_RANGE_AMD:
          VkRasterizationOrderAMD =
    VkRasterizationOrderAMD::VK_RASTERIZATION_ORDER_STRICT_AMD;
pub const VkRasterizationOrderAMD_VK_RASTERIZATION_ORDER_END_RANGE_AMD:
          VkRasterizationOrderAMD =
    VkRasterizationOrderAMD::VK_RASTERIZATION_ORDER_RELAXED_AMD;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkRasterizationOrderAMD {
    VK_RASTERIZATION_ORDER_STRICT_AMD = 0,
    VK_RASTERIZATION_ORDER_RELAXED_AMD = 1,
    VK_RASTERIZATION_ORDER_RANGE_SIZE_AMD = 2,
    VK_RASTERIZATION_ORDER_MAX_ENUM_AMD = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineRasterizationStateRasterizationOrderAMD {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub rasterizationOrder: VkRasterizationOrderAMD,
}
#[test]
fn bindgen_test_layout_VkPipelineRasterizationStateRasterizationOrderAMD() {
    assert_eq!(::std::mem::size_of::<VkPipelineRasterizationStateRasterizationOrderAMD>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineRasterizationStateRasterizationOrderAMD ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineRasterizationStateRasterizationOrderAMD>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineRasterizationStateRasterizationOrderAMD ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPipelineRasterizationStateRasterizationOrderAMD
                ) ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateRasterizationOrderAMD ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPipelineRasterizationStateRasterizationOrderAMD
                ) ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateRasterizationOrderAMD ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPipelineRasterizationStateRasterizationOrderAMD
                ) ) . rasterizationOrder as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineRasterizationStateRasterizationOrderAMD ) , "::" ,
                stringify ! ( rasterizationOrder ) ));
}
impl Clone for VkPipelineRasterizationStateRasterizationOrderAMD {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDebugMarkerObjectNameInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkDebugReportObjectTypeEXT,
    pub object: u64,
    pub pObjectName: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VkDebugMarkerObjectNameInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkDebugMarkerObjectNameInfoEXT>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( VkDebugMarkerObjectNameInfoEXT )
               ));
    assert_eq! (::std::mem::align_of::<VkDebugMarkerObjectNameInfoEXT>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkDebugMarkerObjectNameInfoEXT
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectNameInfoEXT ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectNameInfoEXT ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectNameInfoEXT ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectNameInfoEXT ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectNameInfoEXT ) ) .
                objectType as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectNameInfoEXT ) , "::" , stringify ! (
                objectType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectNameInfoEXT ) ) .
                object as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectNameInfoEXT ) , "::" , stringify ! ( object
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectNameInfoEXT ) ) .
                pObjectName as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectNameInfoEXT ) , "::" , stringify ! (
                pObjectName ) ));
}
impl Clone for VkDebugMarkerObjectNameInfoEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDebugMarkerObjectTagInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectType: VkDebugReportObjectTypeEXT,
    pub object: u64,
    pub tagName: u64,
    pub tagSize: usize,
    pub pTag: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VkDebugMarkerObjectTagInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkDebugMarkerObjectTagInfoEXT>() ,
               56usize , concat ! (
               "Size of: " , stringify ! ( VkDebugMarkerObjectTagInfoEXT ) ));
    assert_eq! (::std::mem::align_of::<VkDebugMarkerObjectTagInfoEXT>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkDebugMarkerObjectTagInfoEXT
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectTagInfoEXT ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectTagInfoEXT ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectTagInfoEXT ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectTagInfoEXT ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectTagInfoEXT ) ) .
                objectType as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectTagInfoEXT ) , "::" , stringify ! (
                objectType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectTagInfoEXT ) ) .
                object as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectTagInfoEXT ) , "::" , stringify ! ( object
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectTagInfoEXT ) ) .
                tagName as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectTagInfoEXT ) , "::" , stringify ! ( tagName
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectTagInfoEXT ) ) .
                tagSize as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectTagInfoEXT ) , "::" , stringify ! ( tagSize
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerObjectTagInfoEXT ) ) . pTag
                as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerObjectTagInfoEXT ) , "::" , stringify ! ( pTag )
                ));
}
impl Clone for VkDebugMarkerObjectTagInfoEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDebugMarkerMarkerInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pMarkerName: *const ::std::os::raw::c_char,
    pub color: [f32; 4usize],
}
#[test]
fn bindgen_test_layout_VkDebugMarkerMarkerInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkDebugMarkerMarkerInfoEXT>() , 40usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDebugMarkerMarkerInfoEXT ) ));
    assert_eq! (::std::mem::align_of::<VkDebugMarkerMarkerInfoEXT>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDebugMarkerMarkerInfoEXT )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerMarkerInfoEXT ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerMarkerInfoEXT ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerMarkerInfoEXT ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerMarkerInfoEXT ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerMarkerInfoEXT ) ) .
                pMarkerName as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerMarkerInfoEXT ) , "::" , stringify ! (
                pMarkerName ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDebugMarkerMarkerInfoEXT ) ) . color as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDebugMarkerMarkerInfoEXT ) , "::" , stringify ! ( color )
                ));
}
impl Clone for VkDebugMarkerMarkerInfoEXT {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkDebugMarkerSetObjectTagEXT =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pTagInfo:
                                                   *const VkDebugMarkerObjectTagInfoEXT)
                              -> VkResult>;
pub type PFN_vkDebugMarkerSetObjectNameEXT =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pNameInfo:
                                                   *const VkDebugMarkerObjectNameInfoEXT)
                              -> VkResult>;
pub type PFN_vkCmdDebugMarkerBeginEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pMarkerInfo:
                                                   *const VkDebugMarkerMarkerInfoEXT)>;
pub type PFN_vkCmdDebugMarkerEndEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer:
                                                   VkCommandBuffer)>;
pub type PFN_vkCmdDebugMarkerInsertEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pMarkerInfo:
                                                   *const VkDebugMarkerMarkerInfoEXT)>;
extern "C" {
    pub fn vkDebugMarkerSetObjectTagEXT(device: VkDevice,
                                        pTagInfo:
                                            *const VkDebugMarkerObjectTagInfoEXT)
     -> VkResult;
}
extern "C" {
    pub fn vkDebugMarkerSetObjectNameEXT(device: VkDevice,
                                         pNameInfo:
                                             *const VkDebugMarkerObjectNameInfoEXT)
     -> VkResult;
}
extern "C" {
    pub fn vkCmdDebugMarkerBeginEXT(commandBuffer: VkCommandBuffer,
                                    pMarkerInfo:
                                        *const VkDebugMarkerMarkerInfoEXT);
}
extern "C" {
    pub fn vkCmdDebugMarkerEndEXT(commandBuffer: VkCommandBuffer);
}
extern "C" {
    pub fn vkCmdDebugMarkerInsertEXT(commandBuffer: VkCommandBuffer,
                                     pMarkerInfo:
                                         *const VkDebugMarkerMarkerInfoEXT);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDedicatedAllocationImageCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationImageCreateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkDedicatedAllocationImageCreateInfoNV>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkDedicatedAllocationImageCreateInfoNV ) ));
    assert_eq! (::std::mem::align_of::<VkDedicatedAllocationImageCreateInfoNV>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDedicatedAllocationImageCreateInfoNV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDedicatedAllocationImageCreateInfoNV )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationImageCreateInfoNV ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDedicatedAllocationImageCreateInfoNV )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationImageCreateInfoNV ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDedicatedAllocationImageCreateInfoNV )
                ) . dedicatedAllocation as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationImageCreateInfoNV ) , "::" , stringify !
                ( dedicatedAllocation ) ));
}
impl Clone for VkDedicatedAllocationImageCreateInfoNV {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDedicatedAllocationBufferCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub dedicatedAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationBufferCreateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkDedicatedAllocationBufferCreateInfoNV>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkDedicatedAllocationBufferCreateInfoNV ) ));
    assert_eq! (::std::mem::align_of::<VkDedicatedAllocationBufferCreateInfoNV>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDedicatedAllocationBufferCreateInfoNV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDedicatedAllocationBufferCreateInfoNV )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationBufferCreateInfoNV ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDedicatedAllocationBufferCreateInfoNV )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationBufferCreateInfoNV ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDedicatedAllocationBufferCreateInfoNV )
                ) . dedicatedAllocation as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationBufferCreateInfoNV ) , "::" , stringify !
                ( dedicatedAllocation ) ));
}
impl Clone for VkDedicatedAllocationBufferCreateInfoNV {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDedicatedAllocationMemoryAllocateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkDedicatedAllocationMemoryAllocateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkDedicatedAllocationMemoryAllocateInfoNV>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               VkDedicatedAllocationMemoryAllocateInfoNV ) ));
    assert_eq! (::std::mem::align_of::<VkDedicatedAllocationMemoryAllocateInfoNV>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDedicatedAllocationMemoryAllocateInfoNV ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkDedicatedAllocationMemoryAllocateInfoNV ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationMemoryAllocateInfoNV ) , "::" , stringify
                ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkDedicatedAllocationMemoryAllocateInfoNV ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationMemoryAllocateInfoNV ) , "::" , stringify
                ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkDedicatedAllocationMemoryAllocateInfoNV ) )
                . image as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationMemoryAllocateInfoNV ) , "::" , stringify
                ! ( image ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkDedicatedAllocationMemoryAllocateInfoNV ) )
                . buffer as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDedicatedAllocationMemoryAllocateInfoNV ) , "::" , stringify
                ! ( buffer ) ));
}
impl Clone for VkDedicatedAllocationMemoryAllocateInfoNV {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCmdDrawIndirectCountAMD =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               buffer: VkBuffer,
                                               offset: VkDeviceSize,
                                               countBuffer: VkBuffer,
                                               countBufferOffset:
                                                   VkDeviceSize,
                                               maxDrawCount: u32,
                                               stride: u32)>;
pub type PFN_vkCmdDrawIndexedIndirectCountAMD =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               buffer: VkBuffer,
                                               offset: VkDeviceSize,
                                               countBuffer: VkBuffer,
                                               countBufferOffset:
                                                   VkDeviceSize,
                                               maxDrawCount: u32,
                                               stride: u32)>;
extern "C" {
    pub fn vkCmdDrawIndirectCountAMD(commandBuffer: VkCommandBuffer,
                                     buffer: VkBuffer, offset: VkDeviceSize,
                                     countBuffer: VkBuffer,
                                     countBufferOffset: VkDeviceSize,
                                     maxDrawCount: u32, stride: u32);
}
extern "C" {
    pub fn vkCmdDrawIndexedIndirectCountAMD(commandBuffer: VkCommandBuffer,
                                            buffer: VkBuffer,
                                            offset: VkDeviceSize,
                                            countBuffer: VkBuffer,
                                            countBufferOffset: VkDeviceSize,
                                            maxDrawCount: u32, stride: u32);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkTextureLODGatherFormatPropertiesAMD {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub supportsTextureGatherLODBiasAMD: VkBool32,
}
#[test]
fn bindgen_test_layout_VkTextureLODGatherFormatPropertiesAMD() {
    assert_eq!(::std::mem::size_of::<VkTextureLODGatherFormatPropertiesAMD>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkTextureLODGatherFormatPropertiesAMD ) ));
    assert_eq! (::std::mem::align_of::<VkTextureLODGatherFormatPropertiesAMD>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkTextureLODGatherFormatPropertiesAMD ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkTextureLODGatherFormatPropertiesAMD ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkTextureLODGatherFormatPropertiesAMD ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkTextureLODGatherFormatPropertiesAMD ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkTextureLODGatherFormatPropertiesAMD ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkTextureLODGatherFormatPropertiesAMD ) )
                . supportsTextureGatherLODBiasAMD as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkTextureLODGatherFormatPropertiesAMD ) , "::" , stringify ! (
                supportsTextureGatherLODBiasAMD ) ));
}
impl Clone for VkTextureLODGatherFormatPropertiesAMD {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkRenderPassMultiviewCreateInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub subpassCount: u32,
    pub pViewMasks: *const u32,
    pub dependencyCount: u32,
    pub pViewOffsets: *const i32,
    pub correlationMaskCount: u32,
    pub pCorrelationMasks: *const u32,
}
#[test]
fn bindgen_test_layout_VkRenderPassMultiviewCreateInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkRenderPassMultiviewCreateInfoKHX>() ,
               64usize , concat ! (
               "Size of: " , stringify ! ( VkRenderPassMultiviewCreateInfoKHX
               ) ));
    assert_eq! (::std::mem::align_of::<VkRenderPassMultiviewCreateInfoKHX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassMultiviewCreateInfoKHX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassMultiviewCreateInfoKHX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassMultiviewCreateInfoKHX ) ) .
                subpassCount as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) , "::" , stringify ! (
                subpassCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassMultiviewCreateInfoKHX ) ) .
                pViewMasks as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) , "::" , stringify ! (
                pViewMasks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassMultiviewCreateInfoKHX ) ) .
                dependencyCount as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) , "::" , stringify ! (
                dependencyCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassMultiviewCreateInfoKHX ) ) .
                pViewOffsets as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) , "::" , stringify ! (
                pViewOffsets ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassMultiviewCreateInfoKHX ) ) .
                correlationMaskCount as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) , "::" , stringify ! (
                correlationMaskCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRenderPassMultiviewCreateInfoKHX ) ) .
                pCorrelationMasks as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkRenderPassMultiviewCreateInfoKHX ) , "::" , stringify ! (
                pCorrelationMasks ) ));
}
impl Clone for VkRenderPassMultiviewCreateInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceMultiviewFeaturesKHX {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub multiview: VkBool32,
    pub multiviewGeometryShader: VkBool32,
    pub multiviewTessellationShader: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewFeaturesKHX() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceMultiviewFeaturesKHX>() ,
               32usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceMultiviewFeaturesKHX ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceMultiviewFeaturesKHX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceMultiviewFeaturesKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewFeaturesKHX ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewFeaturesKHX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewFeaturesKHX ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewFeaturesKHX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewFeaturesKHX ) )
                . multiview as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewFeaturesKHX ) , "::" , stringify ! (
                multiview ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewFeaturesKHX ) )
                . multiviewGeometryShader as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewFeaturesKHX ) , "::" , stringify ! (
                multiviewGeometryShader ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewFeaturesKHX ) )
                . multiviewTessellationShader as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewFeaturesKHX ) , "::" , stringify ! (
                multiviewTessellationShader ) ));
}
impl Clone for VkPhysicalDeviceMultiviewFeaturesKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceMultiviewPropertiesKHX {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxMultiviewViewCount: u32,
    pub maxMultiviewInstanceIndex: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewPropertiesKHX() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceMultiviewPropertiesKHX>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceMultiviewPropertiesKHX ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceMultiviewPropertiesKHX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceMultiviewPropertiesKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewPropertiesKHX )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewPropertiesKHX ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewPropertiesKHX )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewPropertiesKHX ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewPropertiesKHX )
                ) . maxMultiviewViewCount as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewPropertiesKHX ) , "::" , stringify !
                ( maxMultiviewViewCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceMultiviewPropertiesKHX )
                ) . maxMultiviewInstanceIndex as * const _ as usize } ,
                20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewPropertiesKHX ) , "::" , stringify !
                ( maxMultiviewInstanceIndex ) ));
}
impl Clone for VkPhysicalDeviceMultiviewPropertiesKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkExternalMemoryHandleTypeFlagBitsNV {
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_BIT_NV = 1,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_OPAQUE_WIN32_KMT_BIT_NV = 2,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_BIT_NV = 4,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_D3D11_IMAGE_KMT_BIT_NV = 8,
    VK_EXTERNAL_MEMORY_HANDLE_TYPE_FLAG_BITS_MAX_ENUM_NV = 2147483647,
}
pub type VkExternalMemoryHandleTypeFlagsNV = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkExternalMemoryFeatureFlagBitsNV {
    VK_EXTERNAL_MEMORY_FEATURE_DEDICATED_ONLY_BIT_NV = 1,
    VK_EXTERNAL_MEMORY_FEATURE_EXPORTABLE_BIT_NV = 2,
    VK_EXTERNAL_MEMORY_FEATURE_IMPORTABLE_BIT_NV = 4,
    VK_EXTERNAL_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_NV = 2147483647,
}
pub type VkExternalMemoryFeatureFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalImageFormatPropertiesNV {
    pub imageFormatProperties: VkImageFormatProperties,
    pub externalMemoryFeatures: VkExternalMemoryFeatureFlagsNV,
    pub exportFromImportedHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
    pub compatibleHandleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExternalImageFormatPropertiesNV() {
    assert_eq!(::std::mem::size_of::<VkExternalImageFormatPropertiesNV>() ,
               48usize , concat ! (
               "Size of: " , stringify ! ( VkExternalImageFormatPropertiesNV )
               ));
    assert_eq! (::std::mem::align_of::<VkExternalImageFormatPropertiesNV>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkExternalImageFormatPropertiesNV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalImageFormatPropertiesNV ) ) .
                imageFormatProperties as * const _ as usize } , 0usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalImageFormatPropertiesNV ) , "::" , stringify ! (
                imageFormatProperties ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalImageFormatPropertiesNV ) ) .
                externalMemoryFeatures as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalImageFormatPropertiesNV ) , "::" , stringify ! (
                externalMemoryFeatures ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalImageFormatPropertiesNV ) ) .
                exportFromImportedHandleTypes as * const _ as usize } ,
                36usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalImageFormatPropertiesNV ) , "::" , stringify ! (
                exportFromImportedHandleTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalImageFormatPropertiesNV ) ) .
                compatibleHandleTypes as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalImageFormatPropertiesNV ) , "::" , stringify ! (
                compatibleHandleTypes ) ));
}
impl Clone for VkExternalImageFormatPropertiesNV {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetPhysicalDeviceExternalImageFormatPropertiesNV =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               format: VkFormat,
                                               type_: VkImageType,
                                               tiling: VkImageTiling,
                                               usage: VkImageUsageFlags,
                                               flags: VkImageCreateFlags,
                                               externalHandleType:
                                                   VkExternalMemoryHandleTypeFlagsNV,
                                               pExternalImageFormatProperties:
                                                   *mut VkExternalImageFormatPropertiesNV)
                              -> VkResult>;
extern "C" {
    pub fn vkGetPhysicalDeviceExternalImageFormatPropertiesNV(physicalDevice:
                                                                  VkPhysicalDevice,
                                                              format:
                                                                  VkFormat,
                                                              type_:
                                                                  VkImageType,
                                                              tiling:
                                                                  VkImageTiling,
                                                              usage:
                                                                  VkImageUsageFlags,
                                                              flags:
                                                                  VkImageCreateFlags,
                                                              externalHandleType:
                                                                  VkExternalMemoryHandleTypeFlagsNV,
                                                              pExternalImageFormatProperties:
                                                                  *mut VkExternalImageFormatPropertiesNV)
     -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExternalMemoryImageCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExternalMemoryImageCreateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkExternalMemoryImageCreateInfoNV>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkExternalMemoryImageCreateInfoNV )
               ));
    assert_eq! (::std::mem::align_of::<VkExternalMemoryImageCreateInfoNV>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkExternalMemoryImageCreateInfoNV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryImageCreateInfoNV ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryImageCreateInfoNV ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryImageCreateInfoNV ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryImageCreateInfoNV ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExternalMemoryImageCreateInfoNV ) ) .
                handleTypes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExternalMemoryImageCreateInfoNV ) , "::" , stringify ! (
                handleTypes ) ));
}
impl Clone for VkExternalMemoryImageCreateInfoNV {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkExportMemoryAllocateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub handleTypes: VkExternalMemoryHandleTypeFlagsNV,
}
#[test]
fn bindgen_test_layout_VkExportMemoryAllocateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkExportMemoryAllocateInfoNV>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( VkExportMemoryAllocateInfoNV ) ));
    assert_eq! (::std::mem::align_of::<VkExportMemoryAllocateInfoNV>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkExportMemoryAllocateInfoNV )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportMemoryAllocateInfoNV ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportMemoryAllocateInfoNV ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportMemoryAllocateInfoNV ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportMemoryAllocateInfoNV ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkExportMemoryAllocateInfoNV ) ) .
                handleTypes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkExportMemoryAllocateInfoNV ) , "::" , stringify ! (
                handleTypes ) ));
}
impl Clone for VkExportMemoryAllocateInfoNV {
    fn clone(&self) -> Self { *self }
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkPeerMemoryFeatureFlagBitsKHX {
    VK_PEER_MEMORY_FEATURE_COPY_SRC_BIT_KHX = 1,
    VK_PEER_MEMORY_FEATURE_COPY_DST_BIT_KHX = 2,
    VK_PEER_MEMORY_FEATURE_GENERIC_SRC_BIT_KHX = 4,
    VK_PEER_MEMORY_FEATURE_GENERIC_DST_BIT_KHX = 8,
    VK_PEER_MEMORY_FEATURE_FLAG_BITS_MAX_ENUM_KHX = 2147483647,
}
pub type VkPeerMemoryFeatureFlagsKHX = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkMemoryAllocateFlagBitsKHX {
    VK_MEMORY_ALLOCATE_DEVICE_MASK_BIT_KHX = 1,
    VK_MEMORY_ALLOCATE_FLAG_BITS_MAX_ENUM_KHX = 2147483647,
}
pub type VkMemoryAllocateFlagsKHX = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDeviceGroupPresentModeFlagBitsKHX {
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_BIT_KHX = 1,
    VK_DEVICE_GROUP_PRESENT_MODE_REMOTE_BIT_KHX = 2,
    VK_DEVICE_GROUP_PRESENT_MODE_SUM_BIT_KHX = 4,
    VK_DEVICE_GROUP_PRESENT_MODE_LOCAL_MULTI_DEVICE_BIT_KHX = 8,
    VK_DEVICE_GROUP_PRESENT_MODE_FLAG_BITS_MAX_ENUM_KHX = 2147483647,
}
pub type VkDeviceGroupPresentModeFlagsKHX = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkMemoryAllocateFlagsInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkMemoryAllocateFlagsKHX,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkMemoryAllocateFlagsInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkMemoryAllocateFlagsInfoKHX>() , 24usize
               , concat ! (
               "Size of: " , stringify ! ( VkMemoryAllocateFlagsInfoKHX ) ));
    assert_eq! (::std::mem::align_of::<VkMemoryAllocateFlagsInfoKHX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkMemoryAllocateFlagsInfoKHX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryAllocateFlagsInfoKHX ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryAllocateFlagsInfoKHX ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryAllocateFlagsInfoKHX ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryAllocateFlagsInfoKHX ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryAllocateFlagsInfoKHX ) ) . flags
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryAllocateFlagsInfoKHX ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkMemoryAllocateFlagsInfoKHX ) ) .
                deviceMask as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkMemoryAllocateFlagsInfoKHX ) , "::" , stringify ! (
                deviceMask ) ));
}
impl Clone for VkMemoryAllocateFlagsInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBindBufferMemoryInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub buffer: VkBuffer,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkBindBufferMemoryInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkBindBufferMemoryInfoKHX>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( VkBindBufferMemoryInfoKHX ) ));
    assert_eq! (::std::mem::align_of::<VkBindBufferMemoryInfoKHX>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkBindBufferMemoryInfoKHX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindBufferMemoryInfoKHX ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindBufferMemoryInfoKHX ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindBufferMemoryInfoKHX ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindBufferMemoryInfoKHX ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindBufferMemoryInfoKHX ) ) . buffer as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindBufferMemoryInfoKHX ) , "::" , stringify ! ( buffer )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindBufferMemoryInfoKHX ) ) . memory as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindBufferMemoryInfoKHX ) , "::" , stringify ! ( memory )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindBufferMemoryInfoKHX ) ) .
                memoryOffset as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindBufferMemoryInfoKHX ) , "::" , stringify ! (
                memoryOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindBufferMemoryInfoKHX ) ) .
                deviceIndexCount as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkBindBufferMemoryInfoKHX ) , "::" , stringify ! (
                deviceIndexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindBufferMemoryInfoKHX ) ) .
                pDeviceIndices as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindBufferMemoryInfoKHX ) , "::" , stringify ! (
                pDeviceIndices ) ));
}
impl Clone for VkBindBufferMemoryInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBindImageMemoryInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub image: VkImage,
    pub memory: VkDeviceMemory,
    pub memoryOffset: VkDeviceSize,
    pub deviceIndexCount: u32,
    pub pDeviceIndices: *const u32,
    pub SFRRectCount: u32,
    pub pSFRRects: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkBindImageMemoryInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkBindImageMemoryInfoKHX>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( VkBindImageMemoryInfoKHX ) ));
    assert_eq! (::std::mem::align_of::<VkBindImageMemoryInfoKHX>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkBindImageMemoryInfoKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) . image as *
                const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! ( image ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) . memory as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! ( memory ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) .
                memoryOffset as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! ( memoryOffset
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) .
                deviceIndexCount as * const _ as usize } , 40usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! (
                deviceIndexCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) .
                pDeviceIndices as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! (
                pDeviceIndices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) .
                SFRRectCount as * const _ as usize } , 56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! ( SFRRectCount
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemoryInfoKHX ) ) . pSFRRects
                as * const _ as usize } , 64usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemoryInfoKHX ) , "::" , stringify ! ( pSFRRects )
                ));
}
impl Clone for VkBindImageMemoryInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGroupRenderPassBeginInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceMask: u32,
    pub deviceRenderAreaCount: u32,
    pub pDeviceRenderAreas: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupRenderPassBeginInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGroupRenderPassBeginInfoKHX>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkDeviceGroupRenderPassBeginInfoKHX
               ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceGroupRenderPassBeginInfoKHX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDeviceGroupRenderPassBeginInfoKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupRenderPassBeginInfoKHX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupRenderPassBeginInfoKHX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupRenderPassBeginInfoKHX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupRenderPassBeginInfoKHX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupRenderPassBeginInfoKHX ) ) .
                deviceMask as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupRenderPassBeginInfoKHX ) , "::" , stringify ! (
                deviceMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupRenderPassBeginInfoKHX ) ) .
                deviceRenderAreaCount as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupRenderPassBeginInfoKHX ) , "::" , stringify ! (
                deviceRenderAreaCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupRenderPassBeginInfoKHX ) ) .
                pDeviceRenderAreas as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupRenderPassBeginInfoKHX ) , "::" , stringify ! (
                pDeviceRenderAreas ) ));
}
impl Clone for VkDeviceGroupRenderPassBeginInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGroupCommandBufferBeginInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupCommandBufferBeginInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGroupCommandBufferBeginInfoKHX>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkDeviceGroupCommandBufferBeginInfoKHX ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceGroupCommandBufferBeginInfoKHX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDeviceGroupCommandBufferBeginInfoKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupCommandBufferBeginInfoKHX )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupCommandBufferBeginInfoKHX ) , "::" , stringify !
                ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupCommandBufferBeginInfoKHX )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupCommandBufferBeginInfoKHX ) , "::" , stringify !
                ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupCommandBufferBeginInfoKHX )
                ) . deviceMask as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupCommandBufferBeginInfoKHX ) , "::" , stringify !
                ( deviceMask ) ));
}
impl Clone for VkDeviceGroupCommandBufferBeginInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGroupSubmitInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub waitSemaphoreCount: u32,
    pub pWaitSemaphoreDeviceIndices: *const u32,
    pub commandBufferCount: u32,
    pub pCommandBufferDeviceMasks: *const u32,
    pub signalSemaphoreCount: u32,
    pub pSignalSemaphoreDeviceIndices: *const u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupSubmitInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGroupSubmitInfoKHX>() , 64usize ,
               concat ! (
               "Size of: " , stringify ! ( VkDeviceGroupSubmitInfoKHX ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceGroupSubmitInfoKHX>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDeviceGroupSubmitInfoKHX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSubmitInfoKHX ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSubmitInfoKHX ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSubmitInfoKHX ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSubmitInfoKHX ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSubmitInfoKHX ) ) .
                waitSemaphoreCount as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSubmitInfoKHX ) , "::" , stringify ! (
                waitSemaphoreCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSubmitInfoKHX ) ) .
                pWaitSemaphoreDeviceIndices as * const _ as usize } , 24usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSubmitInfoKHX ) , "::" , stringify ! (
                pWaitSemaphoreDeviceIndices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSubmitInfoKHX ) ) .
                commandBufferCount as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSubmitInfoKHX ) , "::" , stringify ! (
                commandBufferCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSubmitInfoKHX ) ) .
                pCommandBufferDeviceMasks as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSubmitInfoKHX ) , "::" , stringify ! (
                pCommandBufferDeviceMasks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSubmitInfoKHX ) ) .
                signalSemaphoreCount as * const _ as usize } , 48usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSubmitInfoKHX ) , "::" , stringify ! (
                signalSemaphoreCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSubmitInfoKHX ) ) .
                pSignalSemaphoreDeviceIndices as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSubmitInfoKHX ) , "::" , stringify ! (
                pSignalSemaphoreDeviceIndices ) ));
}
impl Clone for VkDeviceGroupSubmitInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGroupBindSparseInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub resourceDeviceIndex: u32,
    pub memoryDeviceIndex: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupBindSparseInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGroupBindSparseInfoKHX>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkDeviceGroupBindSparseInfoKHX )
               ));
    assert_eq! (::std::mem::align_of::<VkDeviceGroupBindSparseInfoKHX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkDeviceGroupBindSparseInfoKHX
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupBindSparseInfoKHX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupBindSparseInfoKHX ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupBindSparseInfoKHX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupBindSparseInfoKHX ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupBindSparseInfoKHX ) ) .
                resourceDeviceIndex as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupBindSparseInfoKHX ) , "::" , stringify ! (
                resourceDeviceIndex ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupBindSparseInfoKHX ) ) .
                memoryDeviceIndex as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupBindSparseInfoKHX ) , "::" , stringify ! (
                memoryDeviceIndex ) ));
}
impl Clone for VkDeviceGroupBindSparseInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGroupPresentCapabilitiesKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub presentMask: [u32; 32usize],
    pub modes: VkDeviceGroupPresentModeFlagsKHX,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupPresentCapabilitiesKHX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGroupPresentCapabilitiesKHX>() ,
               152usize , concat ! (
               "Size of: " , stringify ! ( VkDeviceGroupPresentCapabilitiesKHX
               ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceGroupPresentCapabilitiesKHX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDeviceGroupPresentCapabilitiesKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentCapabilitiesKHX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentCapabilitiesKHX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentCapabilitiesKHX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentCapabilitiesKHX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentCapabilitiesKHX ) ) .
                presentMask as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentCapabilitiesKHX ) , "::" , stringify ! (
                presentMask ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentCapabilitiesKHX ) ) .
                modes as * const _ as usize } , 144usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentCapabilitiesKHX ) , "::" , stringify ! (
                modes ) ));
}
impl Clone for VkDeviceGroupPresentCapabilitiesKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkImageSwapchainCreateInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
}
#[test]
fn bindgen_test_layout_VkImageSwapchainCreateInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkImageSwapchainCreateInfoKHX>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkImageSwapchainCreateInfoKHX ) ));
    assert_eq! (::std::mem::align_of::<VkImageSwapchainCreateInfoKHX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkImageSwapchainCreateInfoKHX
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSwapchainCreateInfoKHX ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSwapchainCreateInfoKHX ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSwapchainCreateInfoKHX ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSwapchainCreateInfoKHX ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkImageSwapchainCreateInfoKHX ) ) .
                swapchain as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkImageSwapchainCreateInfoKHX ) , "::" , stringify ! (
                swapchain ) ));
}
impl Clone for VkImageSwapchainCreateInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkBindImageMemorySwapchainInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
    pub imageIndex: u32,
}
#[test]
fn bindgen_test_layout_VkBindImageMemorySwapchainInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkBindImageMemorySwapchainInfoKHX>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkBindImageMemorySwapchainInfoKHX )
               ));
    assert_eq! (::std::mem::align_of::<VkBindImageMemorySwapchainInfoKHX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkBindImageMemorySwapchainInfoKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemorySwapchainInfoKHX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemorySwapchainInfoKHX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemorySwapchainInfoKHX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemorySwapchainInfoKHX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemorySwapchainInfoKHX ) ) .
                swapchain as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemorySwapchainInfoKHX ) , "::" , stringify ! (
                swapchain ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkBindImageMemorySwapchainInfoKHX ) ) .
                imageIndex as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkBindImageMemorySwapchainInfoKHX ) , "::" , stringify ! (
                imageIndex ) ));
}
impl Clone for VkBindImageMemorySwapchainInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkAcquireNextImageInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchain: VkSwapchainKHR,
    pub timeout: u64,
    pub semaphore: VkSemaphore,
    pub fence: VkFence,
    pub deviceMask: u32,
}
#[test]
fn bindgen_test_layout_VkAcquireNextImageInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkAcquireNextImageInfoKHX>() , 56usize ,
               concat ! (
               "Size of: " , stringify ! ( VkAcquireNextImageInfoKHX ) ));
    assert_eq! (::std::mem::align_of::<VkAcquireNextImageInfoKHX>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkAcquireNextImageInfoKHX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAcquireNextImageInfoKHX ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkAcquireNextImageInfoKHX ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAcquireNextImageInfoKHX ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkAcquireNextImageInfoKHX ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAcquireNextImageInfoKHX ) ) . swapchain
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkAcquireNextImageInfoKHX ) , "::" , stringify ! ( swapchain )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAcquireNextImageInfoKHX ) ) . timeout
                as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkAcquireNextImageInfoKHX ) , "::" , stringify ! ( timeout )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAcquireNextImageInfoKHX ) ) . semaphore
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkAcquireNextImageInfoKHX ) , "::" , stringify ! ( semaphore )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAcquireNextImageInfoKHX ) ) . fence as
                * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkAcquireNextImageInfoKHX ) , "::" , stringify ! ( fence ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkAcquireNextImageInfoKHX ) ) .
                deviceMask as * const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkAcquireNextImageInfoKHX ) , "::" , stringify ! ( deviceMask
                ) ));
}
impl Clone for VkAcquireNextImageInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGroupPresentInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pDeviceMasks: *const u32,
    pub mode: VkDeviceGroupPresentModeFlagBitsKHX,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupPresentInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGroupPresentInfoKHX>() , 40usize
               , concat ! (
               "Size of: " , stringify ! ( VkDeviceGroupPresentInfoKHX ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceGroupPresentInfoKHX>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkDeviceGroupPresentInfoKHX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentInfoKHX ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentInfoKHX ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentInfoKHX ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentInfoKHX ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentInfoKHX ) ) .
                swapchainCount as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentInfoKHX ) , "::" , stringify ! (
                swapchainCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentInfoKHX ) ) .
                pDeviceMasks as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentInfoKHX ) , "::" , stringify ! (
                pDeviceMasks ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupPresentInfoKHX ) ) . mode as
                * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupPresentInfoKHX ) , "::" , stringify ! ( mode )
                ));
}
impl Clone for VkDeviceGroupPresentInfoKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGroupSwapchainCreateInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub modes: VkDeviceGroupPresentModeFlagsKHX,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupSwapchainCreateInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGroupSwapchainCreateInfoKHX>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkDeviceGroupSwapchainCreateInfoKHX
               ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceGroupSwapchainCreateInfoKHX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDeviceGroupSwapchainCreateInfoKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSwapchainCreateInfoKHX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSwapchainCreateInfoKHX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSwapchainCreateInfoKHX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSwapchainCreateInfoKHX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupSwapchainCreateInfoKHX ) ) .
                modes as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupSwapchainCreateInfoKHX ) , "::" , stringify ! (
                modes ) ));
}
impl Clone for VkDeviceGroupSwapchainCreateInfoKHX {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetDeviceGroupPeerMemoryFeaturesKHX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               heapIndex: u32,
                                               localDeviceIndex: u32,
                                               remoteDeviceIndex: u32,
                                               pPeerMemoryFeatures:
                                                   *mut VkPeerMemoryFeatureFlagsKHX)>;
pub type PFN_vkBindBufferMemory2KHX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               bindInfoCount: u32,
                                               pBindInfos:
                                                   *const VkBindBufferMemoryInfoKHX)
                              -> VkResult>;
pub type PFN_vkBindImageMemory2KHX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               bindInfoCount: u32,
                                               pBindInfos:
                                                   *const VkBindImageMemoryInfoKHX)
                              -> VkResult>;
pub type PFN_vkCmdSetDeviceMaskKHX =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               deviceMask: u32)>;
pub type PFN_vkGetDeviceGroupPresentCapabilitiesKHX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pDeviceGroupPresentCapabilities:
                                                   *mut VkDeviceGroupPresentCapabilitiesKHX)
                              -> VkResult>;
pub type PFN_vkGetDeviceGroupSurfacePresentModesKHX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               surface: VkSurfaceKHR,
                                               pModes:
                                                   *mut VkDeviceGroupPresentModeFlagsKHX)
                              -> VkResult>;
pub type PFN_vkAcquireNextImage2KHX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pAcquireInfo:
                                                   *const VkAcquireNextImageInfoKHX,
                                               pImageIndex: *mut u32)
                              -> VkResult>;
pub type PFN_vkCmdDispatchBaseKHX =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               baseGroupX: u32,
                                               baseGroupY: u32,
                                               baseGroupZ: u32,
                                               groupCountX: u32,
                                               groupCountY: u32,
                                               groupCountZ: u32)>;
pub type PFN_vkGetPhysicalDevicePresentRectanglesKHX =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               surface: VkSurfaceKHR,
                                               pRectCount: *mut u32,
                                               pRects: *mut VkRect2D)
                              -> VkResult>;
extern "C" {
    pub fn vkGetDeviceGroupPeerMemoryFeaturesKHX(device: VkDevice,
                                                 heapIndex: u32,
                                                 localDeviceIndex: u32,
                                                 remoteDeviceIndex: u32,
                                                 pPeerMemoryFeatures:
                                                     *mut VkPeerMemoryFeatureFlagsKHX);
}
extern "C" {
    pub fn vkBindBufferMemory2KHX(device: VkDevice, bindInfoCount: u32,
                                  pBindInfos:
                                      *const VkBindBufferMemoryInfoKHX)
     -> VkResult;
}
extern "C" {
    pub fn vkBindImageMemory2KHX(device: VkDevice, bindInfoCount: u32,
                                 pBindInfos: *const VkBindImageMemoryInfoKHX)
     -> VkResult;
}
extern "C" {
    pub fn vkCmdSetDeviceMaskKHX(commandBuffer: VkCommandBuffer,
                                 deviceMask: u32);
}
extern "C" {
    pub fn vkGetDeviceGroupPresentCapabilitiesKHX(device: VkDevice,
                                                  pDeviceGroupPresentCapabilities:
                                                      *mut VkDeviceGroupPresentCapabilitiesKHX)
     -> VkResult;
}
extern "C" {
    pub fn vkGetDeviceGroupSurfacePresentModesKHX(device: VkDevice,
                                                  surface: VkSurfaceKHR,
                                                  pModes:
                                                      *mut VkDeviceGroupPresentModeFlagsKHX)
     -> VkResult;
}
extern "C" {
    pub fn vkAcquireNextImage2KHX(device: VkDevice,
                                  pAcquireInfo:
                                      *const VkAcquireNextImageInfoKHX,
                                  pImageIndex: *mut u32) -> VkResult;
}
extern "C" {
    pub fn vkCmdDispatchBaseKHX(commandBuffer: VkCommandBuffer,
                                baseGroupX: u32, baseGroupY: u32,
                                baseGroupZ: u32, groupCountX: u32,
                                groupCountY: u32, groupCountZ: u32);
}
extern "C" {
    pub fn vkGetPhysicalDevicePresentRectanglesKHX(physicalDevice:
                                                       VkPhysicalDevice,
                                                   surface: VkSurfaceKHR,
                                                   pRectCount: *mut u32,
                                                   pRects: *mut VkRect2D)
     -> VkResult;
}
pub const VkValidationCheckEXT_VK_VALIDATION_CHECK_BEGIN_RANGE_EXT:
          VkValidationCheckEXT =
    VkValidationCheckEXT::VK_VALIDATION_CHECK_ALL_EXT;
pub const VkValidationCheckEXT_VK_VALIDATION_CHECK_END_RANGE_EXT:
          VkValidationCheckEXT =
    VkValidationCheckEXT::VK_VALIDATION_CHECK_SHADERS_EXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkValidationCheckEXT {
    VK_VALIDATION_CHECK_ALL_EXT = 0,
    VK_VALIDATION_CHECK_SHADERS_EXT = 1,
    VK_VALIDATION_CHECK_RANGE_SIZE_EXT = 2,
    VK_VALIDATION_CHECK_MAX_ENUM_EXT = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkValidationFlagsEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub disabledValidationCheckCount: u32,
    pub pDisabledValidationChecks: *mut VkValidationCheckEXT,
}
#[test]
fn bindgen_test_layout_VkValidationFlagsEXT() {
    assert_eq!(::std::mem::size_of::<VkValidationFlagsEXT>() , 32usize ,
               concat ! ( "Size of: " , stringify ! ( VkValidationFlagsEXT )
               ));
    assert_eq! (::std::mem::align_of::<VkValidationFlagsEXT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkValidationFlagsEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkValidationFlagsEXT ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkValidationFlagsEXT )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkValidationFlagsEXT ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkValidationFlagsEXT )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkValidationFlagsEXT ) ) .
                disabledValidationCheckCount as * const _ as usize } , 16usize
                , concat ! (
                "Alignment of field: " , stringify ! ( VkValidationFlagsEXT )
                , "::" , stringify ! ( disabledValidationCheckCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkValidationFlagsEXT ) ) .
                pDisabledValidationChecks as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkValidationFlagsEXT )
                , "::" , stringify ! ( pDisabledValidationChecks ) ));
}
impl Clone for VkValidationFlagsEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceGroupPropertiesKHX {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub physicalDeviceCount: u32,
    pub physicalDevices: [VkPhysicalDevice; 32usize],
    pub subsetAllocation: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceGroupPropertiesKHX() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceGroupPropertiesKHX>() ,
               288usize , concat ! (
               "Size of: " , stringify ! ( VkPhysicalDeviceGroupPropertiesKHX
               ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceGroupPropertiesKHX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceGroupPropertiesKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceGroupPropertiesKHX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceGroupPropertiesKHX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceGroupPropertiesKHX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceGroupPropertiesKHX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceGroupPropertiesKHX ) ) .
                physicalDeviceCount as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceGroupPropertiesKHX ) , "::" , stringify ! (
                physicalDeviceCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceGroupPropertiesKHX ) ) .
                physicalDevices as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceGroupPropertiesKHX ) , "::" , stringify ! (
                physicalDevices ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPhysicalDeviceGroupPropertiesKHX ) ) .
                subsetAllocation as * const _ as usize } , 280usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceGroupPropertiesKHX ) , "::" , stringify ! (
                subsetAllocation ) ));
}
impl Clone for VkPhysicalDeviceGroupPropertiesKHX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGroupDeviceCreateInfoKHX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub physicalDeviceCount: u32,
    pub pPhysicalDevices: *const VkPhysicalDevice,
}
#[test]
fn bindgen_test_layout_VkDeviceGroupDeviceCreateInfoKHX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGroupDeviceCreateInfoKHX>() ,
               32usize , concat ! (
               "Size of: " , stringify ! ( VkDeviceGroupDeviceCreateInfoKHX )
               ));
    assert_eq! (::std::mem::align_of::<VkDeviceGroupDeviceCreateInfoKHX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDeviceGroupDeviceCreateInfoKHX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupDeviceCreateInfoKHX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupDeviceCreateInfoKHX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupDeviceCreateInfoKHX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupDeviceCreateInfoKHX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupDeviceCreateInfoKHX ) ) .
                physicalDeviceCount as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupDeviceCreateInfoKHX ) , "::" , stringify ! (
                physicalDeviceCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGroupDeviceCreateInfoKHX ) ) .
                pPhysicalDevices as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkDeviceGroupDeviceCreateInfoKHX ) , "::" , stringify ! (
                pPhysicalDevices ) ));
}
impl Clone for VkDeviceGroupDeviceCreateInfoKHX {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkEnumeratePhysicalDeviceGroupsKHX =
    ::std::option::Option<unsafe extern "C" fn(instance: VkInstance,
                                               pPhysicalDeviceGroupCount:
                                                   *mut u32,
                                               pPhysicalDeviceGroupProperties:
                                                   *mut VkPhysicalDeviceGroupPropertiesKHX)
                              -> VkResult>;
extern "C" {
    pub fn vkEnumeratePhysicalDeviceGroupsKHX(instance: VkInstance,
                                              pPhysicalDeviceGroupCount:
                                                  *mut u32,
                                              pPhysicalDeviceGroupProperties:
                                                  *mut VkPhysicalDeviceGroupPropertiesKHX)
     -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkObjectTableNVX_T {
    _unused: [u8; 0],
}
pub type VkObjectTableNVX = *mut VkObjectTableNVX_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VkIndirectCommandsLayoutNVX_T {
    _unused: [u8; 0],
}
pub type VkIndirectCommandsLayoutNVX = *mut VkIndirectCommandsLayoutNVX_T;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_BEGIN_RANGE_NVX:
          VkIndirectCommandsTokenTypeNVX =
    VkIndirectCommandsTokenTypeNVX::VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX;
pub const VkIndirectCommandsTokenTypeNVX_VK_INDIRECT_COMMANDS_TOKEN_TYPE_END_RANGE_NVX:
          VkIndirectCommandsTokenTypeNVX =
    VkIndirectCommandsTokenTypeNVX::VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkIndirectCommandsTokenTypeNVX {
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PIPELINE_NVX = 0,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DESCRIPTOR_SET_NVX = 1,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_INDEX_BUFFER_NVX = 2,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_VERTEX_BUFFER_NVX = 3,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_PUSH_CONSTANT_NVX = 4,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_INDEXED_NVX = 5,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DRAW_NVX = 6,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_DISPATCH_NVX = 7,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_RANGE_SIZE_NVX = 8,
    VK_INDIRECT_COMMANDS_TOKEN_TYPE_MAX_ENUM_NVX = 2147483647,
}
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_BEGIN_RANGE_NVX:
          VkObjectEntryTypeNVX =
    VkObjectEntryTypeNVX::VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX;
pub const VkObjectEntryTypeNVX_VK_OBJECT_ENTRY_TYPE_END_RANGE_NVX:
          VkObjectEntryTypeNVX =
    VkObjectEntryTypeNVX::VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkObjectEntryTypeNVX {
    VK_OBJECT_ENTRY_TYPE_DESCRIPTOR_SET_NVX = 0,
    VK_OBJECT_ENTRY_TYPE_PIPELINE_NVX = 1,
    VK_OBJECT_ENTRY_TYPE_INDEX_BUFFER_NVX = 2,
    VK_OBJECT_ENTRY_TYPE_VERTEX_BUFFER_NVX = 3,
    VK_OBJECT_ENTRY_TYPE_PUSH_CONSTANT_NVX = 4,
    VK_OBJECT_ENTRY_TYPE_RANGE_SIZE_NVX = 5,
    VK_OBJECT_ENTRY_TYPE_MAX_ENUM_NVX = 2147483647,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkIndirectCommandsLayoutUsageFlagBitsNVX {
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_UNORDERED_SEQUENCES_BIT_NVX = 1,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_SPARSE_SEQUENCES_BIT_NVX = 2,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_EMPTY_EXECUTIONS_BIT_NVX = 4,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_INDEXED_SEQUENCES_BIT_NVX = 8,
    VK_INDIRECT_COMMANDS_LAYOUT_USAGE_FLAG_BITS_MAX_ENUM_NVX = 2147483647,
}
pub type VkIndirectCommandsLayoutUsageFlagsNVX = VkFlags;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkObjectEntryUsageFlagBitsNVX {
    VK_OBJECT_ENTRY_USAGE_GRAPHICS_BIT_NVX = 1,
    VK_OBJECT_ENTRY_USAGE_COMPUTE_BIT_NVX = 2,
    VK_OBJECT_ENTRY_USAGE_FLAG_BITS_MAX_ENUM_NVX = 2147483647,
}
pub type VkObjectEntryUsageFlagsNVX = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGeneratedCommandsFeaturesNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub computeBindingPointSupport: VkBool32,
}
#[test]
fn bindgen_test_layout_VkDeviceGeneratedCommandsFeaturesNVX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGeneratedCommandsFeaturesNVX>() ,
               24usize , concat ! (
               "Size of: " , stringify ! (
               VkDeviceGeneratedCommandsFeaturesNVX ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceGeneratedCommandsFeaturesNVX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDeviceGeneratedCommandsFeaturesNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsFeaturesNVX ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsFeaturesNVX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsFeaturesNVX ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsFeaturesNVX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsFeaturesNVX ) )
                . computeBindingPointSupport as * const _ as usize } , 16usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsFeaturesNVX ) , "::" , stringify ! (
                computeBindingPointSupport ) ));
}
impl Clone for VkDeviceGeneratedCommandsFeaturesNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceGeneratedCommandsLimitsNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub maxIndirectCommandsLayoutTokenCount: u32,
    pub maxObjectEntryCounts: u32,
    pub minSequenceCountBufferOffsetAlignment: u32,
    pub minSequenceIndexBufferOffsetAlignment: u32,
    pub minCommandsTokenBufferOffsetAlignment: u32,
}
#[test]
fn bindgen_test_layout_VkDeviceGeneratedCommandsLimitsNVX() {
    assert_eq!(::std::mem::size_of::<VkDeviceGeneratedCommandsLimitsNVX>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( VkDeviceGeneratedCommandsLimitsNVX
               ) ));
    assert_eq! (::std::mem::align_of::<VkDeviceGeneratedCommandsLimitsNVX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkDeviceGeneratedCommandsLimitsNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsLimitsNVX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsLimitsNVX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsLimitsNVX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsLimitsNVX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsLimitsNVX ) ) .
                maxIndirectCommandsLayoutTokenCount as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsLimitsNVX ) , "::" , stringify ! (
                maxIndirectCommandsLayoutTokenCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsLimitsNVX ) ) .
                maxObjectEntryCounts as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsLimitsNVX ) , "::" , stringify ! (
                maxObjectEntryCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsLimitsNVX ) ) .
                minSequenceCountBufferOffsetAlignment as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsLimitsNVX ) , "::" , stringify ! (
                minSequenceCountBufferOffsetAlignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsLimitsNVX ) ) .
                minSequenceIndexBufferOffsetAlignment as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsLimitsNVX ) , "::" , stringify ! (
                minSequenceIndexBufferOffsetAlignment ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceGeneratedCommandsLimitsNVX ) ) .
                minCommandsTokenBufferOffsetAlignment as * const _ as usize }
                , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkDeviceGeneratedCommandsLimitsNVX ) , "::" , stringify ! (
                minCommandsTokenBufferOffsetAlignment ) ));
}
impl Clone for VkDeviceGeneratedCommandsLimitsNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkIndirectCommandsTokenNVX {
    pub tokenType: VkIndirectCommandsTokenTypeNVX,
    pub buffer: VkBuffer,
    pub offset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsTokenNVX() {
    assert_eq!(::std::mem::size_of::<VkIndirectCommandsTokenNVX>() , 24usize ,
               concat ! (
               "Size of: " , stringify ! ( VkIndirectCommandsTokenNVX ) ));
    assert_eq! (::std::mem::align_of::<VkIndirectCommandsTokenNVX>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkIndirectCommandsTokenNVX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsTokenNVX ) ) .
                tokenType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsTokenNVX ) , "::" , stringify ! ( tokenType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsTokenNVX ) ) . buffer
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsTokenNVX ) , "::" , stringify ! ( buffer )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsTokenNVX ) ) . offset
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsTokenNVX ) , "::" , stringify ! ( offset )
                ));
}
impl Clone for VkIndirectCommandsTokenNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkIndirectCommandsLayoutTokenNVX {
    pub tokenType: VkIndirectCommandsTokenTypeNVX,
    pub bindingUnit: u32,
    pub dynamicCount: u32,
    pub divisor: u32,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsLayoutTokenNVX() {
    assert_eq!(::std::mem::size_of::<VkIndirectCommandsLayoutTokenNVX>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( VkIndirectCommandsLayoutTokenNVX )
               ));
    assert_eq! (::std::mem::align_of::<VkIndirectCommandsLayoutTokenNVX>() ,
                4usize , concat ! (
                "Alignment of " , stringify ! (
                VkIndirectCommandsLayoutTokenNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutTokenNVX ) ) .
                tokenType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutTokenNVX ) , "::" , stringify ! (
                tokenType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutTokenNVX ) ) .
                bindingUnit as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutTokenNVX ) , "::" , stringify ! (
                bindingUnit ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutTokenNVX ) ) .
                dynamicCount as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutTokenNVX ) , "::" , stringify ! (
                dynamicCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutTokenNVX ) ) .
                divisor as * const _ as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutTokenNVX ) , "::" , stringify ! (
                divisor ) ));
}
impl Clone for VkIndirectCommandsLayoutTokenNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkIndirectCommandsLayoutCreateInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub pipelineBindPoint: VkPipelineBindPoint,
    pub flags: VkIndirectCommandsLayoutUsageFlagsNVX,
    pub tokenCount: u32,
    pub pTokens: *const VkIndirectCommandsLayoutTokenNVX,
}
#[test]
fn bindgen_test_layout_VkIndirectCommandsLayoutCreateInfoNVX() {
    assert_eq!(::std::mem::size_of::<VkIndirectCommandsLayoutCreateInfoNVX>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               VkIndirectCommandsLayoutCreateInfoNVX ) ));
    assert_eq! (::std::mem::align_of::<VkIndirectCommandsLayoutCreateInfoNVX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkIndirectCommandsLayoutCreateInfoNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutCreateInfoNVX ) )
                . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutCreateInfoNVX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutCreateInfoNVX ) )
                . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutCreateInfoNVX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutCreateInfoNVX ) )
                . pipelineBindPoint as * const _ as usize } , 16usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutCreateInfoNVX ) , "::" , stringify ! (
                pipelineBindPoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutCreateInfoNVX ) )
                . flags as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutCreateInfoNVX ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutCreateInfoNVX ) )
                . tokenCount as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutCreateInfoNVX ) , "::" , stringify ! (
                tokenCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkIndirectCommandsLayoutCreateInfoNVX ) )
                . pTokens as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkIndirectCommandsLayoutCreateInfoNVX ) , "::" , stringify ! (
                pTokens ) ));
}
impl Clone for VkIndirectCommandsLayoutCreateInfoNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkCmdProcessCommandsInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectTable: VkObjectTableNVX,
    pub indirectCommandsLayout: VkIndirectCommandsLayoutNVX,
    pub indirectCommandsTokenCount: u32,
    pub pIndirectCommandsTokens: *const VkIndirectCommandsTokenNVX,
    pub maxSequencesCount: u32,
    pub targetCommandBuffer: VkCommandBuffer,
    pub sequencesCountBuffer: VkBuffer,
    pub sequencesCountOffset: VkDeviceSize,
    pub sequencesIndexBuffer: VkBuffer,
    pub sequencesIndexOffset: VkDeviceSize,
}
#[test]
fn bindgen_test_layout_VkCmdProcessCommandsInfoNVX() {
    assert_eq!(::std::mem::size_of::<VkCmdProcessCommandsInfoNVX>() , 96usize
               , concat ! (
               "Size of: " , stringify ! ( VkCmdProcessCommandsInfoNVX ) ));
    assert_eq! (::std::mem::align_of::<VkCmdProcessCommandsInfoNVX>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkCmdProcessCommandsInfoNVX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) . sType
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) . pNext
                as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                objectTable as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                objectTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                indirectCommandsLayout as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                indirectCommandsLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                indirectCommandsTokenCount as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                indirectCommandsTokenCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                pIndirectCommandsTokens as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                pIndirectCommandsTokens ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                maxSequencesCount as * const _ as usize } , 48usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                maxSequencesCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                targetCommandBuffer as * const _ as usize } , 56usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                targetCommandBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                sequencesCountBuffer as * const _ as usize } , 64usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                sequencesCountBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                sequencesCountOffset as * const _ as usize } , 72usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                sequencesCountOffset ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                sequencesIndexBuffer as * const _ as usize } , 80usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                sequencesIndexBuffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdProcessCommandsInfoNVX ) ) .
                sequencesIndexOffset as * const _ as usize } , 88usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdProcessCommandsInfoNVX ) , "::" , stringify ! (
                sequencesIndexOffset ) ));
}
impl Clone for VkCmdProcessCommandsInfoNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkCmdReserveSpaceForCommandsInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectTable: VkObjectTableNVX,
    pub indirectCommandsLayout: VkIndirectCommandsLayoutNVX,
    pub maxSequencesCount: u32,
}
#[test]
fn bindgen_test_layout_VkCmdReserveSpaceForCommandsInfoNVX() {
    assert_eq!(::std::mem::size_of::<VkCmdReserveSpaceForCommandsInfoNVX>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( VkCmdReserveSpaceForCommandsInfoNVX
               ) ));
    assert_eq! (::std::mem::align_of::<VkCmdReserveSpaceForCommandsInfoNVX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkCmdReserveSpaceForCommandsInfoNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdReserveSpaceForCommandsInfoNVX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdReserveSpaceForCommandsInfoNVX ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdReserveSpaceForCommandsInfoNVX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdReserveSpaceForCommandsInfoNVX ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdReserveSpaceForCommandsInfoNVX ) ) .
                objectTable as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdReserveSpaceForCommandsInfoNVX ) , "::" , stringify ! (
                objectTable ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdReserveSpaceForCommandsInfoNVX ) ) .
                indirectCommandsLayout as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkCmdReserveSpaceForCommandsInfoNVX ) , "::" , stringify ! (
                indirectCommandsLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkCmdReserveSpaceForCommandsInfoNVX ) ) .
                maxSequencesCount as * const _ as usize } , 32usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkCmdReserveSpaceForCommandsInfoNVX ) , "::" , stringify ! (
                maxSequencesCount ) ));
}
impl Clone for VkCmdReserveSpaceForCommandsInfoNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkObjectTableCreateInfoNVX {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub objectCount: u32,
    pub pObjectEntryTypes: *const VkObjectEntryTypeNVX,
    pub pObjectEntryCounts: *const u32,
    pub pObjectEntryUsageFlags: *const VkObjectEntryUsageFlagsNVX,
    pub maxUniformBuffersPerDescriptor: u32,
    pub maxStorageBuffersPerDescriptor: u32,
    pub maxStorageImagesPerDescriptor: u32,
    pub maxSampledImagesPerDescriptor: u32,
    pub maxPipelineLayouts: u32,
}
#[test]
fn bindgen_test_layout_VkObjectTableCreateInfoNVX() {
    assert_eq!(::std::mem::size_of::<VkObjectTableCreateInfoNVX>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( VkObjectTableCreateInfoNVX ) ));
    assert_eq! (::std::mem::align_of::<VkObjectTableCreateInfoNVX>() , 8usize
                , concat ! (
                "Alignment of " , stringify ! ( VkObjectTableCreateInfoNVX )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! ( sType )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! ( pNext )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                objectCount as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                objectCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                pObjectEntryTypes as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                pObjectEntryTypes ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                pObjectEntryCounts as * const _ as usize } , 32usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                pObjectEntryCounts ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                pObjectEntryUsageFlags as * const _ as usize } , 40usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                pObjectEntryUsageFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                maxUniformBuffersPerDescriptor as * const _ as usize } ,
                48usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                maxUniformBuffersPerDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                maxStorageBuffersPerDescriptor as * const _ as usize } ,
                52usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                maxStorageBuffersPerDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                maxStorageImagesPerDescriptor as * const _ as usize } ,
                56usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                maxStorageImagesPerDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                maxSampledImagesPerDescriptor as * const _ as usize } ,
                60usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                maxSampledImagesPerDescriptor ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableCreateInfoNVX ) ) .
                maxPipelineLayouts as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableCreateInfoNVX ) , "::" , stringify ! (
                maxPipelineLayouts ) ));
}
impl Clone for VkObjectTableCreateInfoNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkObjectTableEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
}
#[test]
fn bindgen_test_layout_VkObjectTableEntryNVX() {
    assert_eq!(::std::mem::size_of::<VkObjectTableEntryNVX>() , 8usize ,
               concat ! ( "Size of: " , stringify ! ( VkObjectTableEntryNVX )
               ));
    assert_eq! (::std::mem::align_of::<VkObjectTableEntryNVX>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkObjectTableEntryNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableEntryNVX ) ) . type_ as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkObjectTableEntryNVX )
                , "::" , stringify ! ( type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableEntryNVX ) ) . flags as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkObjectTableEntryNVX )
                , "::" , stringify ! ( flags ) ));
}
impl Clone for VkObjectTableEntryNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkObjectTablePipelineEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub pipeline: VkPipeline,
}
#[test]
fn bindgen_test_layout_VkObjectTablePipelineEntryNVX() {
    assert_eq!(::std::mem::size_of::<VkObjectTablePipelineEntryNVX>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( VkObjectTablePipelineEntryNVX ) ));
    assert_eq! (::std::mem::align_of::<VkObjectTablePipelineEntryNVX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkObjectTablePipelineEntryNVX
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTablePipelineEntryNVX ) ) . type_
                as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTablePipelineEntryNVX ) , "::" , stringify ! ( type_ )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTablePipelineEntryNVX ) ) . flags
                as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTablePipelineEntryNVX ) , "::" , stringify ! ( flags )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTablePipelineEntryNVX ) ) .
                pipeline as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTablePipelineEntryNVX ) , "::" , stringify ! (
                pipeline ) ));
}
impl Clone for VkObjectTablePipelineEntryNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkObjectTableDescriptorSetEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub pipelineLayout: VkPipelineLayout,
    pub descriptorSet: VkDescriptorSet,
}
#[test]
fn bindgen_test_layout_VkObjectTableDescriptorSetEntryNVX() {
    assert_eq!(::std::mem::size_of::<VkObjectTableDescriptorSetEntryNVX>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkObjectTableDescriptorSetEntryNVX
               ) ));
    assert_eq! (::std::mem::align_of::<VkObjectTableDescriptorSetEntryNVX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkObjectTableDescriptorSetEntryNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableDescriptorSetEntryNVX ) ) .
                type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableDescriptorSetEntryNVX ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableDescriptorSetEntryNVX ) ) .
                flags as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableDescriptorSetEntryNVX ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableDescriptorSetEntryNVX ) ) .
                pipelineLayout as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableDescriptorSetEntryNVX ) , "::" , stringify ! (
                pipelineLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableDescriptorSetEntryNVX ) ) .
                descriptorSet as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableDescriptorSetEntryNVX ) , "::" , stringify ! (
                descriptorSet ) ));
}
impl Clone for VkObjectTableDescriptorSetEntryNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkObjectTableVertexBufferEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub buffer: VkBuffer,
}
#[test]
fn bindgen_test_layout_VkObjectTableVertexBufferEntryNVX() {
    assert_eq!(::std::mem::size_of::<VkObjectTableVertexBufferEntryNVX>() ,
               16usize , concat ! (
               "Size of: " , stringify ! ( VkObjectTableVertexBufferEntryNVX )
               ));
    assert_eq! (::std::mem::align_of::<VkObjectTableVertexBufferEntryNVX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkObjectTableVertexBufferEntryNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableVertexBufferEntryNVX ) ) .
                type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableVertexBufferEntryNVX ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableVertexBufferEntryNVX ) ) .
                flags as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableVertexBufferEntryNVX ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableVertexBufferEntryNVX ) ) .
                buffer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableVertexBufferEntryNVX ) , "::" , stringify ! (
                buffer ) ));
}
impl Clone for VkObjectTableVertexBufferEntryNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkObjectTableIndexBufferEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub buffer: VkBuffer,
    pub indexType: VkIndexType,
}
#[test]
fn bindgen_test_layout_VkObjectTableIndexBufferEntryNVX() {
    assert_eq!(::std::mem::size_of::<VkObjectTableIndexBufferEntryNVX>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkObjectTableIndexBufferEntryNVX )
               ));
    assert_eq! (::std::mem::align_of::<VkObjectTableIndexBufferEntryNVX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkObjectTableIndexBufferEntryNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableIndexBufferEntryNVX ) ) .
                type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableIndexBufferEntryNVX ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableIndexBufferEntryNVX ) ) .
                flags as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableIndexBufferEntryNVX ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableIndexBufferEntryNVX ) ) .
                buffer as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableIndexBufferEntryNVX ) , "::" , stringify ! (
                buffer ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTableIndexBufferEntryNVX ) ) .
                indexType as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTableIndexBufferEntryNVX ) , "::" , stringify ! (
                indexType ) ));
}
impl Clone for VkObjectTableIndexBufferEntryNVX {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkObjectTablePushConstantEntryNVX {
    pub type_: VkObjectEntryTypeNVX,
    pub flags: VkObjectEntryUsageFlagsNVX,
    pub pipelineLayout: VkPipelineLayout,
    pub stageFlags: VkShaderStageFlags,
}
#[test]
fn bindgen_test_layout_VkObjectTablePushConstantEntryNVX() {
    assert_eq!(::std::mem::size_of::<VkObjectTablePushConstantEntryNVX>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkObjectTablePushConstantEntryNVX )
               ));
    assert_eq! (::std::mem::align_of::<VkObjectTablePushConstantEntryNVX>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkObjectTablePushConstantEntryNVX ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTablePushConstantEntryNVX ) ) .
                type_ as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTablePushConstantEntryNVX ) , "::" , stringify ! (
                type_ ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTablePushConstantEntryNVX ) ) .
                flags as * const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTablePushConstantEntryNVX ) , "::" , stringify ! (
                flags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTablePushConstantEntryNVX ) ) .
                pipelineLayout as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTablePushConstantEntryNVX ) , "::" , stringify ! (
                pipelineLayout ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkObjectTablePushConstantEntryNVX ) ) .
                stageFlags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkObjectTablePushConstantEntryNVX ) , "::" , stringify ! (
                stageFlags ) ));
}
impl Clone for VkObjectTablePushConstantEntryNVX {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCmdProcessCommandsNVX =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pProcessCommandsInfo:
                                                   *const VkCmdProcessCommandsInfoNVX)>;
pub type PFN_vkCmdReserveSpaceForCommandsNVX =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               pReserveSpaceInfo:
                                                   *const VkCmdReserveSpaceForCommandsInfoNVX)>;
pub type PFN_vkCreateIndirectCommandsLayoutNVX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkIndirectCommandsLayoutCreateInfoNVX,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pIndirectCommandsLayout:
                                                   *mut VkIndirectCommandsLayoutNVX)
                              -> VkResult>;
pub type PFN_vkDestroyIndirectCommandsLayoutNVX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               indirectCommandsLayout:
                                                   VkIndirectCommandsLayoutNVX,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkCreateObjectTableNVX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pCreateInfo:
                                                   *const VkObjectTableCreateInfoNVX,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pObjectTable:
                                                   *mut VkObjectTableNVX)
                              -> VkResult>;
pub type PFN_vkDestroyObjectTableNVX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               objectTable: VkObjectTableNVX,
                                               pAllocator:
                                                   *const VkAllocationCallbacks)>;
pub type PFN_vkRegisterObjectsNVX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               objectTable: VkObjectTableNVX,
                                               objectCount: u32,
                                               ppObjectTableEntries:
                                                   *const *const VkObjectTableEntryNVX,
                                               pObjectIndices: *const u32)
                              -> VkResult>;
pub type PFN_vkUnregisterObjectsNVX =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               objectTable: VkObjectTableNVX,
                                               objectCount: u32,
                                               pObjectEntryTypes:
                                                   *const VkObjectEntryTypeNVX,
                                               pObjectIndices: *const u32)
                              -> VkResult>;
pub type PFN_vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               pFeatures:
                                                   *mut VkDeviceGeneratedCommandsFeaturesNVX,
                                               pLimits:
                                                   *mut VkDeviceGeneratedCommandsLimitsNVX)>;
extern "C" {
    pub fn vkCmdProcessCommandsNVX(commandBuffer: VkCommandBuffer,
                                   pProcessCommandsInfo:
                                       *const VkCmdProcessCommandsInfoNVX);
}
extern "C" {
    pub fn vkCmdReserveSpaceForCommandsNVX(commandBuffer: VkCommandBuffer,
                                           pReserveSpaceInfo:
                                               *const VkCmdReserveSpaceForCommandsInfoNVX);
}
extern "C" {
    pub fn vkCreateIndirectCommandsLayoutNVX(device: VkDevice,
                                             pCreateInfo:
                                                 *const VkIndirectCommandsLayoutCreateInfoNVX,
                                             pAllocator:
                                                 *const VkAllocationCallbacks,
                                             pIndirectCommandsLayout:
                                                 *mut VkIndirectCommandsLayoutNVX)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyIndirectCommandsLayoutNVX(device: VkDevice,
                                              indirectCommandsLayout:
                                                  VkIndirectCommandsLayoutNVX,
                                              pAllocator:
                                                  *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkCreateObjectTableNVX(device: VkDevice,
                                  pCreateInfo:
                                      *const VkObjectTableCreateInfoNVX,
                                  pAllocator: *const VkAllocationCallbacks,
                                  pObjectTable: *mut VkObjectTableNVX)
     -> VkResult;
}
extern "C" {
    pub fn vkDestroyObjectTableNVX(device: VkDevice,
                                   objectTable: VkObjectTableNVX,
                                   pAllocator: *const VkAllocationCallbacks);
}
extern "C" {
    pub fn vkRegisterObjectsNVX(device: VkDevice,
                                objectTable: VkObjectTableNVX,
                                objectCount: u32,
                                ppObjectTableEntries:
                                    *const *const VkObjectTableEntryNVX,
                                pObjectIndices: *const u32) -> VkResult;
}
extern "C" {
    pub fn vkUnregisterObjectsNVX(device: VkDevice,
                                  objectTable: VkObjectTableNVX,
                                  objectCount: u32,
                                  pObjectEntryTypes:
                                      *const VkObjectEntryTypeNVX,
                                  pObjectIndices: *const u32) -> VkResult;
}
extern "C" {
    pub fn vkGetPhysicalDeviceGeneratedCommandsPropertiesNVX(physicalDevice:
                                                                 VkPhysicalDevice,
                                                             pFeatures:
                                                                 *mut VkDeviceGeneratedCommandsFeaturesNVX,
                                                             pLimits:
                                                                 *mut VkDeviceGeneratedCommandsLimitsNVX);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkViewportWScalingNV {
    pub xcoeff: f32,
    pub ycoeff: f32,
}
#[test]
fn bindgen_test_layout_VkViewportWScalingNV() {
    assert_eq!(::std::mem::size_of::<VkViewportWScalingNV>() , 8usize , concat
               ! ( "Size of: " , stringify ! ( VkViewportWScalingNV ) ));
    assert_eq! (::std::mem::align_of::<VkViewportWScalingNV>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkViewportWScalingNV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewportWScalingNV ) ) . xcoeff as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewportWScalingNV )
                , "::" , stringify ! ( xcoeff ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewportWScalingNV ) ) . ycoeff as *
                const _ as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewportWScalingNV )
                , "::" , stringify ! ( ycoeff ) ));
}
impl Clone for VkViewportWScalingNV {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineViewportWScalingStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub viewportWScalingEnable: VkBool32,
    pub viewportCount: u32,
    pub pViewportWScalings: *const VkViewportWScalingNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportWScalingStateCreateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkPipelineViewportWScalingStateCreateInfoNV>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineViewportWScalingStateCreateInfoNV ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineViewportWScalingStateCreateInfoNV>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineViewportWScalingStateCreateInfoNV ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportWScalingStateCreateInfoNV )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportWScalingStateCreateInfoNV ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportWScalingStateCreateInfoNV )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportWScalingStateCreateInfoNV ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportWScalingStateCreateInfoNV )
                ) . viewportWScalingEnable as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportWScalingStateCreateInfoNV ) , "::" ,
                stringify ! ( viewportWScalingEnable ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportWScalingStateCreateInfoNV )
                ) . viewportCount as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportWScalingStateCreateInfoNV ) , "::" ,
                stringify ! ( viewportCount ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportWScalingStateCreateInfoNV )
                ) . pViewportWScalings as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportWScalingStateCreateInfoNV ) , "::" ,
                stringify ! ( pViewportWScalings ) ));
}
impl Clone for VkPipelineViewportWScalingStateCreateInfoNV {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCmdSetViewportWScalingNV =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               firstViewport: u32,
                                               viewportCount: u32,
                                               pViewportWScalings:
                                                   *const VkViewportWScalingNV)>;
extern "C" {
    pub fn vkCmdSetViewportWScalingNV(commandBuffer: VkCommandBuffer,
                                      firstViewport: u32, viewportCount: u32,
                                      pViewportWScalings:
                                          *const VkViewportWScalingNV);
}
pub type PFN_vkReleaseDisplayEXT =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               display: VkDisplayKHR)
                              -> VkResult>;
extern "C" {
    pub fn vkReleaseDisplayEXT(physicalDevice: VkPhysicalDevice,
                               display: VkDisplayKHR) -> VkResult;
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSurfaceCounterFlagBitsEXT {
    VK_SURFACE_COUNTER_VBLANK_EXT = 1,
    VK_SURFACE_COUNTER_FLAG_BITS_MAX_ENUM_EXT = 2147483647,
}
pub type VkSurfaceCounterFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSurfaceCapabilities2EXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub minImageCount: u32,
    pub maxImageCount: u32,
    pub currentExtent: VkExtent2D,
    pub minImageExtent: VkExtent2D,
    pub maxImageExtent: VkExtent2D,
    pub maxImageArrayLayers: u32,
    pub supportedTransforms: VkSurfaceTransformFlagsKHR,
    pub currentTransform: VkSurfaceTransformFlagBitsKHR,
    pub supportedCompositeAlpha: VkCompositeAlphaFlagsKHR,
    pub supportedUsageFlags: VkImageUsageFlags,
    pub supportedSurfaceCounters: VkSurfaceCounterFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkSurfaceCapabilities2EXT() {
    assert_eq!(::std::mem::size_of::<VkSurfaceCapabilities2EXT>() , 72usize ,
               concat ! (
               "Size of: " , stringify ! ( VkSurfaceCapabilities2EXT ) ));
    assert_eq! (::std::mem::align_of::<VkSurfaceCapabilities2EXT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkSurfaceCapabilities2EXT )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) . sType as
                * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) . pNext as
                * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                minImageCount as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                minImageCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                maxImageCount as * const _ as usize } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                maxImageCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                currentExtent as * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                currentExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                minImageExtent as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                minImageExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                maxImageExtent as * const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                maxImageExtent ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                maxImageArrayLayers as * const _ as usize } , 48usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                maxImageArrayLayers ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                supportedTransforms as * const _ as usize } , 52usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                supportedTransforms ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                currentTransform as * const _ as usize } , 56usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                currentTransform ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                supportedCompositeAlpha as * const _ as usize } , 60usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                supportedCompositeAlpha ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                supportedUsageFlags as * const _ as usize } , 64usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                supportedUsageFlags ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSurfaceCapabilities2EXT ) ) .
                supportedSurfaceCounters as * const _ as usize } , 68usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkSurfaceCapabilities2EXT ) , "::" , stringify ! (
                supportedSurfaceCounters ) ));
}
impl Clone for VkSurfaceCapabilities2EXT {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetPhysicalDeviceSurfaceCapabilities2EXT =
    ::std::option::Option<unsafe extern "C" fn(physicalDevice:
                                                   VkPhysicalDevice,
                                               surface: VkSurfaceKHR,
                                               pSurfaceCapabilities:
                                                   *mut VkSurfaceCapabilities2EXT)
                              -> VkResult>;
extern "C" {
    pub fn vkGetPhysicalDeviceSurfaceCapabilities2EXT(physicalDevice:
                                                          VkPhysicalDevice,
                                                      surface: VkSurfaceKHR,
                                                      pSurfaceCapabilities:
                                                          *mut VkSurfaceCapabilities2EXT)
     -> VkResult;
}
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_BEGIN_RANGE_EXT:
          VkDisplayPowerStateEXT =
    VkDisplayPowerStateEXT::VK_DISPLAY_POWER_STATE_OFF_EXT;
pub const VkDisplayPowerStateEXT_VK_DISPLAY_POWER_STATE_END_RANGE_EXT:
          VkDisplayPowerStateEXT =
    VkDisplayPowerStateEXT::VK_DISPLAY_POWER_STATE_ON_EXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDisplayPowerStateEXT {
    VK_DISPLAY_POWER_STATE_OFF_EXT = 0,
    VK_DISPLAY_POWER_STATE_SUSPEND_EXT = 1,
    VK_DISPLAY_POWER_STATE_ON_EXT = 2,
    VK_DISPLAY_POWER_STATE_RANGE_SIZE_EXT = 3,
    VK_DISPLAY_POWER_STATE_MAX_ENUM_EXT = 2147483647,
}
pub const VkDeviceEventTypeEXT_VK_DEVICE_EVENT_TYPE_BEGIN_RANGE_EXT:
          VkDeviceEventTypeEXT =
    VkDeviceEventTypeEXT::VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
pub const VkDeviceEventTypeEXT_VK_DEVICE_EVENT_TYPE_END_RANGE_EXT:
          VkDeviceEventTypeEXT =
    VkDeviceEventTypeEXT::VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDeviceEventTypeEXT {
    VK_DEVICE_EVENT_TYPE_DISPLAY_HOTPLUG_EXT = 0,
    VK_DEVICE_EVENT_TYPE_RANGE_SIZE_EXT = 1,
    VK_DEVICE_EVENT_TYPE_MAX_ENUM_EXT = 2147483647,
}
pub const VkDisplayEventTypeEXT_VK_DISPLAY_EVENT_TYPE_BEGIN_RANGE_EXT:
          VkDisplayEventTypeEXT =
    VkDisplayEventTypeEXT::VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
pub const VkDisplayEventTypeEXT_VK_DISPLAY_EVENT_TYPE_END_RANGE_EXT:
          VkDisplayEventTypeEXT =
    VkDisplayEventTypeEXT::VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDisplayEventTypeEXT {
    VK_DISPLAY_EVENT_TYPE_FIRST_PIXEL_OUT_EXT = 0,
    VK_DISPLAY_EVENT_TYPE_RANGE_SIZE_EXT = 1,
    VK_DISPLAY_EVENT_TYPE_MAX_ENUM_EXT = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayPowerInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub powerState: VkDisplayPowerStateEXT,
}
#[test]
fn bindgen_test_layout_VkDisplayPowerInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkDisplayPowerInfoEXT>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( VkDisplayPowerInfoEXT )
               ));
    assert_eq! (::std::mem::align_of::<VkDisplayPowerInfoEXT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDisplayPowerInfoEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPowerInfoEXT ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPowerInfoEXT )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPowerInfoEXT ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPowerInfoEXT )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayPowerInfoEXT ) ) . powerState as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayPowerInfoEXT )
                , "::" , stringify ! ( powerState ) ));
}
impl Clone for VkDisplayPowerInfoEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDeviceEventInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub deviceEvent: VkDeviceEventTypeEXT,
}
#[test]
fn bindgen_test_layout_VkDeviceEventInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkDeviceEventInfoEXT>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( VkDeviceEventInfoEXT )
               ));
    assert_eq! (::std::mem::align_of::<VkDeviceEventInfoEXT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDeviceEventInfoEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceEventInfoEXT ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceEventInfoEXT )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceEventInfoEXT ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceEventInfoEXT )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDeviceEventInfoEXT ) ) . deviceEvent as
                * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDeviceEventInfoEXT )
                , "::" , stringify ! ( deviceEvent ) ));
}
impl Clone for VkDeviceEventInfoEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkDisplayEventInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub displayEvent: VkDisplayEventTypeEXT,
}
#[test]
fn bindgen_test_layout_VkDisplayEventInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkDisplayEventInfoEXT>() , 24usize ,
               concat ! ( "Size of: " , stringify ! ( VkDisplayEventInfoEXT )
               ));
    assert_eq! (::std::mem::align_of::<VkDisplayEventInfoEXT>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkDisplayEventInfoEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayEventInfoEXT ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayEventInfoEXT )
                , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayEventInfoEXT ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayEventInfoEXT )
                , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkDisplayEventInfoEXT ) ) . displayEvent
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkDisplayEventInfoEXT )
                , "::" , stringify ! ( displayEvent ) ));
}
impl Clone for VkDisplayEventInfoEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSwapchainCounterCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub surfaceCounters: VkSurfaceCounterFlagsEXT,
}
#[test]
fn bindgen_test_layout_VkSwapchainCounterCreateInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkSwapchainCounterCreateInfoEXT>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkSwapchainCounterCreateInfoEXT )
               ));
    assert_eq! (::std::mem::align_of::<VkSwapchainCounterCreateInfoEXT>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! (
                VkSwapchainCounterCreateInfoEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCounterCreateInfoEXT ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCounterCreateInfoEXT ) , "::" , stringify ! ( sType
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCounterCreateInfoEXT ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCounterCreateInfoEXT ) , "::" , stringify ! ( pNext
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSwapchainCounterCreateInfoEXT ) ) .
                surfaceCounters as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSwapchainCounterCreateInfoEXT ) , "::" , stringify ! (
                surfaceCounters ) ));
}
impl Clone for VkSwapchainCounterCreateInfoEXT {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkDisplayPowerControlEXT =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               display: VkDisplayKHR,
                                               pDisplayPowerInfo:
                                                   *const VkDisplayPowerInfoEXT)
                              -> VkResult>;
pub type PFN_vkRegisterDeviceEventEXT =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               pDeviceEventInfo:
                                                   *const VkDeviceEventInfoEXT,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pFence: *mut VkFence)
                              -> VkResult>;
pub type PFN_vkRegisterDisplayEventEXT =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               display: VkDisplayKHR,
                                               pDisplayEventInfo:
                                                   *const VkDisplayEventInfoEXT,
                                               pAllocator:
                                                   *const VkAllocationCallbacks,
                                               pFence: *mut VkFence)
                              -> VkResult>;
pub type PFN_vkGetSwapchainCounterEXT =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               counter:
                                                   VkSurfaceCounterFlagBitsEXT,
                                               pCounterValue: *mut u64)
                              -> VkResult>;
extern "C" {
    pub fn vkDisplayPowerControlEXT(device: VkDevice, display: VkDisplayKHR,
                                    pDisplayPowerInfo:
                                        *const VkDisplayPowerInfoEXT)
     -> VkResult;
}
extern "C" {
    pub fn vkRegisterDeviceEventEXT(device: VkDevice,
                                    pDeviceEventInfo:
                                        *const VkDeviceEventInfoEXT,
                                    pAllocator: *const VkAllocationCallbacks,
                                    pFence: *mut VkFence) -> VkResult;
}
extern "C" {
    pub fn vkRegisterDisplayEventEXT(device: VkDevice, display: VkDisplayKHR,
                                     pDisplayEventInfo:
                                         *const VkDisplayEventInfoEXT,
                                     pAllocator: *const VkAllocationCallbacks,
                                     pFence: *mut VkFence) -> VkResult;
}
extern "C" {
    pub fn vkGetSwapchainCounterEXT(device: VkDevice,
                                    swapchain: VkSwapchainKHR,
                                    counter: VkSurfaceCounterFlagBitsEXT,
                                    pCounterValue: *mut u64) -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkRefreshCycleDurationGOOGLE {
    pub refreshDuration: u64,
}
#[test]
fn bindgen_test_layout_VkRefreshCycleDurationGOOGLE() {
    assert_eq!(::std::mem::size_of::<VkRefreshCycleDurationGOOGLE>() , 8usize
               , concat ! (
               "Size of: " , stringify ! ( VkRefreshCycleDurationGOOGLE ) ));
    assert_eq! (::std::mem::align_of::<VkRefreshCycleDurationGOOGLE>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkRefreshCycleDurationGOOGLE )
                ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkRefreshCycleDurationGOOGLE ) ) .
                refreshDuration as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkRefreshCycleDurationGOOGLE ) , "::" , stringify ! (
                refreshDuration ) ));
}
impl Clone for VkRefreshCycleDurationGOOGLE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPastPresentationTimingGOOGLE {
    pub presentID: u32,
    pub desiredPresentTime: u64,
    pub actualPresentTime: u64,
    pub earliestPresentTime: u64,
    pub presentMargin: u64,
}
#[test]
fn bindgen_test_layout_VkPastPresentationTimingGOOGLE() {
    assert_eq!(::std::mem::size_of::<VkPastPresentationTimingGOOGLE>() ,
               40usize , concat ! (
               "Size of: " , stringify ! ( VkPastPresentationTimingGOOGLE )
               ));
    assert_eq! (::std::mem::align_of::<VkPastPresentationTimingGOOGLE>() ,
                8usize , concat ! (
                "Alignment of " , stringify ! ( VkPastPresentationTimingGOOGLE
                ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPastPresentationTimingGOOGLE ) ) .
                presentID as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPastPresentationTimingGOOGLE ) , "::" , stringify ! (
                presentID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPastPresentationTimingGOOGLE ) ) .
                desiredPresentTime as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPastPresentationTimingGOOGLE ) , "::" , stringify ! (
                desiredPresentTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPastPresentationTimingGOOGLE ) ) .
                actualPresentTime as * const _ as usize } , 16usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPastPresentationTimingGOOGLE ) , "::" , stringify ! (
                actualPresentTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPastPresentationTimingGOOGLE ) ) .
                earliestPresentTime as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! (
                VkPastPresentationTimingGOOGLE ) , "::" , stringify ! (
                earliestPresentTime ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPastPresentationTimingGOOGLE ) ) .
                presentMargin as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPastPresentationTimingGOOGLE ) , "::" , stringify ! (
                presentMargin ) ));
}
impl Clone for VkPastPresentationTimingGOOGLE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPresentTimeGOOGLE {
    pub presentID: u32,
    pub desiredPresentTime: u64,
}
#[test]
fn bindgen_test_layout_VkPresentTimeGOOGLE() {
    assert_eq!(::std::mem::size_of::<VkPresentTimeGOOGLE>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( VkPresentTimeGOOGLE ) ));
    assert_eq! (::std::mem::align_of::<VkPresentTimeGOOGLE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkPresentTimeGOOGLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentTimeGOOGLE ) ) . presentID as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkPresentTimeGOOGLE ) ,
                "::" , stringify ! ( presentID ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentTimeGOOGLE ) ) .
                desiredPresentTime as * const _ as usize } , 8usize , concat !
                (
                "Alignment of field: " , stringify ! ( VkPresentTimeGOOGLE ) ,
                "::" , stringify ! ( desiredPresentTime ) ));
}
impl Clone for VkPresentTimeGOOGLE {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPresentTimesInfoGOOGLE {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub swapchainCount: u32,
    pub pTimes: *const VkPresentTimeGOOGLE,
}
#[test]
fn bindgen_test_layout_VkPresentTimesInfoGOOGLE() {
    assert_eq!(::std::mem::size_of::<VkPresentTimesInfoGOOGLE>() , 32usize ,
               concat ! (
               "Size of: " , stringify ! ( VkPresentTimesInfoGOOGLE ) ));
    assert_eq! (::std::mem::align_of::<VkPresentTimesInfoGOOGLE>() , 8usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkPresentTimesInfoGOOGLE ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentTimesInfoGOOGLE ) ) . sType as *
                const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPresentTimesInfoGOOGLE ) , "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentTimesInfoGOOGLE ) ) . pNext as *
                const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPresentTimesInfoGOOGLE ) , "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentTimesInfoGOOGLE ) ) .
                swapchainCount as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPresentTimesInfoGOOGLE ) , "::" , stringify ! (
                swapchainCount ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkPresentTimesInfoGOOGLE ) ) . pTimes as
                * const _ as usize } , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPresentTimesInfoGOOGLE ) , "::" , stringify ! ( pTimes ) ));
}
impl Clone for VkPresentTimesInfoGOOGLE {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkGetRefreshCycleDurationGOOGLE =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               pDisplayTimingProperties:
                                                   *mut VkRefreshCycleDurationGOOGLE)
                              -> VkResult>;
pub type PFN_vkGetPastPresentationTimingGOOGLE =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchain: VkSwapchainKHR,
                                               pPresentationTimingCount:
                                                   *mut u32,
                                               pPresentationTimings:
                                                   *mut VkPastPresentationTimingGOOGLE)
                              -> VkResult>;
extern "C" {
    pub fn vkGetRefreshCycleDurationGOOGLE(device: VkDevice,
                                           swapchain: VkSwapchainKHR,
                                           pDisplayTimingProperties:
                                               *mut VkRefreshCycleDurationGOOGLE)
     -> VkResult;
}
extern "C" {
    pub fn vkGetPastPresentationTimingGOOGLE(device: VkDevice,
                                             swapchain: VkSwapchainKHR,
                                             pPresentationTimingCount:
                                                 *mut u32,
                                             pPresentationTimings:
                                                 *mut VkPastPresentationTimingGOOGLE)
     -> VkResult;
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub perViewPositionAllComponents: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ) .
                perViewPositionAllComponents as * const _ as usize } , 16usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX ) ,
                "::" , stringify ! ( perViewPositionAllComponents ) ));
}
impl Clone for VkPhysicalDeviceMultiviewPerViewAttributesPropertiesNVX {
    fn clone(&self) -> Self { *self }
}
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_BEGIN_RANGE_NV:
          VkViewportCoordinateSwizzleNV =
    VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV;
pub const VkViewportCoordinateSwizzleNV_VK_VIEWPORT_COORDINATE_SWIZZLE_END_RANGE_NV:
          VkViewportCoordinateSwizzleNV =
    VkViewportCoordinateSwizzleNV::VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkViewportCoordinateSwizzleNV {
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_X_NV = 0,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_X_NV = 1,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Y_NV = 2,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Y_NV = 3,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_Z_NV = 4,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_Z_NV = 5,
    VK_VIEWPORT_COORDINATE_SWIZZLE_POSITIVE_W_NV = 6,
    VK_VIEWPORT_COORDINATE_SWIZZLE_NEGATIVE_W_NV = 7,
    VK_VIEWPORT_COORDINATE_SWIZZLE_RANGE_SIZE_NV = 8,
    VK_VIEWPORT_COORDINATE_SWIZZLE_MAX_ENUM_NV = 2147483647,
}
pub type VkPipelineViewportSwizzleStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkViewportSwizzleNV {
    pub x: VkViewportCoordinateSwizzleNV,
    pub y: VkViewportCoordinateSwizzleNV,
    pub z: VkViewportCoordinateSwizzleNV,
    pub w: VkViewportCoordinateSwizzleNV,
}
#[test]
fn bindgen_test_layout_VkViewportSwizzleNV() {
    assert_eq!(::std::mem::size_of::<VkViewportSwizzleNV>() , 16usize , concat
               ! ( "Size of: " , stringify ! ( VkViewportSwizzleNV ) ));
    assert_eq! (::std::mem::align_of::<VkViewportSwizzleNV>() , 4usize ,
                concat ! (
                "Alignment of " , stringify ! ( VkViewportSwizzleNV ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewportSwizzleNV ) ) . x as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewportSwizzleNV ) ,
                "::" , stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewportSwizzleNV ) ) . y as * const _
                as usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewportSwizzleNV ) ,
                "::" , stringify ! ( y ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewportSwizzleNV ) ) . z as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewportSwizzleNV ) ,
                "::" , stringify ! ( z ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkViewportSwizzleNV ) ) . w as * const _
                as usize } , 12usize , concat ! (
                "Alignment of field: " , stringify ! ( VkViewportSwizzleNV ) ,
                "::" , stringify ! ( w ) ));
}
impl Clone for VkViewportSwizzleNV {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineViewportSwizzleStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineViewportSwizzleStateCreateFlagsNV,
    pub viewportCount: u32,
    pub pViewportSwizzles: *const VkViewportSwizzleNV,
}
#[test]
fn bindgen_test_layout_VkPipelineViewportSwizzleStateCreateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkPipelineViewportSwizzleStateCreateInfoNV>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineViewportSwizzleStateCreateInfoNV ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineViewportSwizzleStateCreateInfoNV>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineViewportSwizzleStateCreateInfoNV ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportSwizzleStateCreateInfoNV )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportSwizzleStateCreateInfoNV ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportSwizzleStateCreateInfoNV )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportSwizzleStateCreateInfoNV ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportSwizzleStateCreateInfoNV )
                ) . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportSwizzleStateCreateInfoNV ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportSwizzleStateCreateInfoNV )
                ) . viewportCount as * const _ as usize } , 20usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportSwizzleStateCreateInfoNV ) , "::" ,
                stringify ! ( viewportCount ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineViewportSwizzleStateCreateInfoNV )
                ) . pViewportSwizzles as * const _ as usize } , 24usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineViewportSwizzleStateCreateInfoNV ) , "::" ,
                stringify ! ( pViewportSwizzles ) ));
}
impl Clone for VkPipelineViewportSwizzleStateCreateInfoNV {
    fn clone(&self) -> Self { *self }
}
pub const VkDiscardRectangleModeEXT_VK_DISCARD_RECTANGLE_MODE_BEGIN_RANGE_EXT:
          VkDiscardRectangleModeEXT =
    VkDiscardRectangleModeEXT::VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT;
pub const VkDiscardRectangleModeEXT_VK_DISCARD_RECTANGLE_MODE_END_RANGE_EXT:
          VkDiscardRectangleModeEXT =
    VkDiscardRectangleModeEXT::VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkDiscardRectangleModeEXT {
    VK_DISCARD_RECTANGLE_MODE_INCLUSIVE_EXT = 0,
    VK_DISCARD_RECTANGLE_MODE_EXCLUSIVE_EXT = 1,
    VK_DISCARD_RECTANGLE_MODE_RANGE_SIZE_EXT = 2,
    VK_DISCARD_RECTANGLE_MODE_MAX_ENUM_EXT = 2147483647,
}
pub type VkPipelineDiscardRectangleStateCreateFlagsEXT = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub maxDiscardRectangles: u32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceDiscardRectanglePropertiesEXT() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceDiscardRectanglePropertiesEXT ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceDiscardRectanglePropertiesEXT>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceDiscardRectanglePropertiesEXT ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceDiscardRectanglePropertiesEXT
                ) ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceDiscardRectanglePropertiesEXT ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceDiscardRectanglePropertiesEXT
                ) ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceDiscardRectanglePropertiesEXT ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPhysicalDeviceDiscardRectanglePropertiesEXT
                ) ) . maxDiscardRectangles as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceDiscardRectanglePropertiesEXT ) , "::" ,
                stringify ! ( maxDiscardRectangles ) ));
}
impl Clone for VkPhysicalDeviceDiscardRectanglePropertiesEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineDiscardRectangleStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineDiscardRectangleStateCreateFlagsEXT,
    pub discardRectangleMode: VkDiscardRectangleModeEXT,
    pub discardRectangleCount: u32,
    pub pDiscardRectangles: *const VkRect2D,
}
#[test]
fn bindgen_test_layout_VkPipelineDiscardRectangleStateCreateInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkPipelineDiscardRectangleStateCreateInfoEXT>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineDiscardRectangleStateCreateInfoEXT ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineDiscardRectangleStateCreateInfoEXT>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineDiscardRectangleStateCreateInfoEXT ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineDiscardRectangleStateCreateInfoEXT
                ) ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDiscardRectangleStateCreateInfoEXT ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineDiscardRectangleStateCreateInfoEXT
                ) ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDiscardRectangleStateCreateInfoEXT ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineDiscardRectangleStateCreateInfoEXT
                ) ) . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDiscardRectangleStateCreateInfoEXT ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineDiscardRectangleStateCreateInfoEXT
                ) ) . discardRectangleMode as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDiscardRectangleStateCreateInfoEXT ) , "::" ,
                stringify ! ( discardRectangleMode ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineDiscardRectangleStateCreateInfoEXT
                ) ) . discardRectangleCount as * const _ as usize } , 24usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDiscardRectangleStateCreateInfoEXT ) , "::" ,
                stringify ! ( discardRectangleCount ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineDiscardRectangleStateCreateInfoEXT
                ) ) . pDiscardRectangles as * const _ as usize } , 32usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineDiscardRectangleStateCreateInfoEXT ) , "::" ,
                stringify ! ( pDiscardRectangles ) ));
}
impl Clone for VkPipelineDiscardRectangleStateCreateInfoEXT {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkCmdSetDiscardRectangleEXT =
    ::std::option::Option<unsafe extern "C" fn(commandBuffer: VkCommandBuffer,
                                               firstDiscardRectangle: u32,
                                               discardRectangleCount: u32,
                                               pDiscardRectangles:
                                                   *const VkRect2D)>;
extern "C" {
    pub fn vkCmdSetDiscardRectangleEXT(commandBuffer: VkCommandBuffer,
                                       firstDiscardRectangle: u32,
                                       discardRectangleCount: u32,
                                       pDiscardRectangles: *const VkRect2D);
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkXYColorEXT {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_VkXYColorEXT() {
    assert_eq!(::std::mem::size_of::<VkXYColorEXT>() , 8usize , concat ! (
               "Size of: " , stringify ! ( VkXYColorEXT ) ));
    assert_eq! (::std::mem::align_of::<VkXYColorEXT>() , 4usize , concat ! (
                "Alignment of " , stringify ! ( VkXYColorEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkXYColorEXT ) ) . x as * const _ as
                usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkXYColorEXT ) , "::" ,
                stringify ! ( x ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkXYColorEXT ) ) . y as * const _ as
                usize } , 4usize , concat ! (
                "Alignment of field: " , stringify ! ( VkXYColorEXT ) , "::" ,
                stringify ! ( y ) ));
}
impl Clone for VkXYColorEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkHdrMetadataEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub displayPrimaryRed: VkXYColorEXT,
    pub displayPrimaryGreen: VkXYColorEXT,
    pub displayPrimaryBlue: VkXYColorEXT,
    pub whitePoint: VkXYColorEXT,
    pub maxLuminance: f32,
    pub minLuminance: f32,
    pub maxContentLightLevel: f32,
    pub maxFrameAverageLightLevel: f32,
}
#[test]
fn bindgen_test_layout_VkHdrMetadataEXT() {
    assert_eq!(::std::mem::size_of::<VkHdrMetadataEXT>() , 64usize , concat !
               ( "Size of: " , stringify ! ( VkHdrMetadataEXT ) ));
    assert_eq! (::std::mem::align_of::<VkHdrMetadataEXT>() , 8usize , concat !
                ( "Alignment of " , stringify ! ( VkHdrMetadataEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) . sType as * const _
                as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) . pNext as * const _
                as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) . displayPrimaryRed
                as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( displayPrimaryRed ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) .
                displayPrimaryGreen as * const _ as usize } , 24usize , concat
                ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( displayPrimaryGreen ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) . displayPrimaryBlue
                as * const _ as usize } , 32usize , concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( displayPrimaryBlue ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) . whitePoint as *
                const _ as usize } , 40usize , concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( whitePoint ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) . maxLuminance as *
                const _ as usize } , 48usize , concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( maxLuminance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) . minLuminance as *
                const _ as usize } , 52usize , concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( minLuminance ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) .
                maxContentLightLevel as * const _ as usize } , 56usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( maxContentLightLevel ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkHdrMetadataEXT ) ) .
                maxFrameAverageLightLevel as * const _ as usize } , 60usize ,
                concat ! (
                "Alignment of field: " , stringify ! ( VkHdrMetadataEXT ) ,
                "::" , stringify ! ( maxFrameAverageLightLevel ) ));
}
impl Clone for VkHdrMetadataEXT {
    fn clone(&self) -> Self { *self }
}
pub type PFN_vkSetHdrMetadataEXT =
    ::std::option::Option<unsafe extern "C" fn(device: VkDevice,
                                               swapchainCount: u32,
                                               pSwapchains:
                                                   *const VkSwapchainKHR,
                                               pMetadata:
                                                   *const VkHdrMetadataEXT)>;
extern "C" {
    pub fn vkSetHdrMetadataEXT(device: VkDevice, swapchainCount: u32,
                               pSwapchains: *const VkSwapchainKHR,
                               pMetadata: *const VkHdrMetadataEXT);
}
pub const VkSamplerReductionModeEXT_VK_SAMPLER_REDUCTION_MODE_BEGIN_RANGE_EXT:
          VkSamplerReductionModeEXT =
    VkSamplerReductionModeEXT::VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT;
pub const VkSamplerReductionModeEXT_VK_SAMPLER_REDUCTION_MODE_END_RANGE_EXT:
          VkSamplerReductionModeEXT =
    VkSamplerReductionModeEXT::VK_SAMPLER_REDUCTION_MODE_MAX_EXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkSamplerReductionModeEXT {
    VK_SAMPLER_REDUCTION_MODE_WEIGHTED_AVERAGE_EXT = 0,
    VK_SAMPLER_REDUCTION_MODE_MIN_EXT = 1,
    VK_SAMPLER_REDUCTION_MODE_MAX_EXT = 2,
    VK_SAMPLER_REDUCTION_MODE_RANGE_SIZE_EXT = 3,
    VK_SAMPLER_REDUCTION_MODE_MAX_ENUM_EXT = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkSamplerReductionModeCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub reductionMode: VkSamplerReductionModeEXT,
}
#[test]
fn bindgen_test_layout_VkSamplerReductionModeCreateInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkSamplerReductionModeCreateInfoEXT>() ,
               24usize , concat ! (
               "Size of: " , stringify ! ( VkSamplerReductionModeCreateInfoEXT
               ) ));
    assert_eq! (::std::mem::align_of::<VkSamplerReductionModeCreateInfoEXT>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkSamplerReductionModeCreateInfoEXT ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerReductionModeCreateInfoEXT ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSamplerReductionModeCreateInfoEXT ) , "::" , stringify ! (
                sType ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerReductionModeCreateInfoEXT ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSamplerReductionModeCreateInfoEXT ) , "::" , stringify ! (
                pNext ) ));
    assert_eq! (unsafe {
                & ( * ( 0 as * const VkSamplerReductionModeCreateInfoEXT ) ) .
                reductionMode as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkSamplerReductionModeCreateInfoEXT ) , "::" , stringify ! (
                reductionMode ) ));
}
impl Clone for VkSamplerReductionModeCreateInfoEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub filterMinmaxSingleComponentFormats: VkBool32,
    pub filterMinmaxImageComponentMapping: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
                ) ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
                ) ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
                ) ) . filterMinmaxSingleComponentFormats as * const _ as usize
                } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ) , "::" ,
                stringify ! ( filterMinmaxSingleComponentFormats ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT
                ) ) . filterMinmaxImageComponentMapping as * const _ as usize
                } , 20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT ) , "::" ,
                stringify ! ( filterMinmaxImageComponentMapping ) ));
}
impl Clone for VkPhysicalDeviceSamplerFilterMinmaxPropertiesEXT {
    fn clone(&self) -> Self { *self }
}
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_BEGIN_RANGE_EXT:
          VkBlendOverlapEXT =
    VkBlendOverlapEXT::VK_BLEND_OVERLAP_UNCORRELATED_EXT;
pub const VkBlendOverlapEXT_VK_BLEND_OVERLAP_END_RANGE_EXT: VkBlendOverlapEXT
          =
    VkBlendOverlapEXT::VK_BLEND_OVERLAP_CONJOINT_EXT;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkBlendOverlapEXT {
    VK_BLEND_OVERLAP_UNCORRELATED_EXT = 0,
    VK_BLEND_OVERLAP_DISJOINT_EXT = 1,
    VK_BLEND_OVERLAP_CONJOINT_EXT = 2,
    VK_BLEND_OVERLAP_RANGE_SIZE_EXT = 3,
    VK_BLEND_OVERLAP_MAX_ENUM_EXT = 2147483647,
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub advancedBlendCoherentOperations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>()
               , 24usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
                ) ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
                ) ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT
                ) ) . advancedBlendCoherentOperations as * const _ as usize }
                , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT ) , "::" ,
                stringify ! ( advancedBlendCoherentOperations ) ));
}
impl Clone for VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    pub sType: VkStructureType,
    pub pNext: *mut ::std::os::raw::c_void,
    pub advancedBlendMaxColorAttachments: u32,
    pub advancedBlendIndependentBlend: VkBool32,
    pub advancedBlendNonPremultipliedSrcColor: VkBool32,
    pub advancedBlendNonPremultipliedDstColor: VkBool32,
    pub advancedBlendCorrelatedOverlap: VkBool32,
    pub advancedBlendAllOperations: VkBool32,
}
#[test]
fn bindgen_test_layout_VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT() {
    assert_eq!(::std::mem::size_of::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ));
    assert_eq! (::std::mem::align_of::<VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ) .
                sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ) .
                pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ) .
                advancedBlendMaxColorAttachments as * const _ as usize } ,
                16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) , "::" ,
                stringify ! ( advancedBlendMaxColorAttachments ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ) .
                advancedBlendIndependentBlend as * const _ as usize } ,
                20usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) , "::" ,
                stringify ! ( advancedBlendIndependentBlend ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ) .
                advancedBlendNonPremultipliedSrcColor as * const _ as usize }
                , 24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) , "::" ,
                stringify ! ( advancedBlendNonPremultipliedSrcColor ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ) .
                advancedBlendNonPremultipliedDstColor as * const _ as usize }
                , 28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) , "::" ,
                stringify ! ( advancedBlendNonPremultipliedDstColor ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ) .
                advancedBlendCorrelatedOverlap as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) , "::" ,
                stringify ! ( advancedBlendCorrelatedOverlap ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) ) .
                advancedBlendAllOperations as * const _ as usize } , 36usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT ) , "::" ,
                stringify ! ( advancedBlendAllOperations ) ));
}
impl Clone for VkPhysicalDeviceBlendOperationAdvancedPropertiesEXT {
    fn clone(&self) -> Self { *self }
}
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub srcPremultiplied: VkBool32,
    pub dstPremultiplied: VkBool32,
    pub blendOverlap: VkBlendOverlapEXT,
}
#[test]
fn bindgen_test_layout_VkPipelineColorBlendAdvancedStateCreateInfoEXT() {
    assert_eq!(::std::mem::size_of::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineColorBlendAdvancedStateCreateInfoEXT ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineColorBlendAdvancedStateCreateInfoEXT>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineColorBlendAdvancedStateCreateInfoEXT ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPipelineColorBlendAdvancedStateCreateInfoEXT )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAdvancedStateCreateInfoEXT ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPipelineColorBlendAdvancedStateCreateInfoEXT )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAdvancedStateCreateInfoEXT ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPipelineColorBlendAdvancedStateCreateInfoEXT )
                ) . srcPremultiplied as * const _ as usize } , 16usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAdvancedStateCreateInfoEXT ) , "::" ,
                stringify ! ( srcPremultiplied ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPipelineColorBlendAdvancedStateCreateInfoEXT )
                ) . dstPremultiplied as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAdvancedStateCreateInfoEXT ) , "::" ,
                stringify ! ( dstPremultiplied ) ));
    assert_eq! (unsafe {
                & (
                * (
                0 as * const VkPipelineColorBlendAdvancedStateCreateInfoEXT )
                ) . blendOverlap as * const _ as usize } , 24usize , concat !
                (
                "Alignment of field: " , stringify ! (
                VkPipelineColorBlendAdvancedStateCreateInfoEXT ) , "::" ,
                stringify ! ( blendOverlap ) ));
}
impl Clone for VkPipelineColorBlendAdvancedStateCreateInfoEXT {
    fn clone(&self) -> Self { *self }
}
pub type VkPipelineCoverageToColorStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineCoverageToColorStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCoverageToColorStateCreateFlagsNV,
    pub coverageToColorEnable: VkBool32,
    pub coverageToColorLocation: u32,
}
#[test]
fn bindgen_test_layout_VkPipelineCoverageToColorStateCreateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkPipelineCoverageToColorStateCreateInfoNV>()
               , 32usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineCoverageToColorStateCreateInfoNV ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineCoverageToColorStateCreateInfoNV>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineCoverageToColorStateCreateInfoNV ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageToColorStateCreateInfoNV )
                ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageToColorStateCreateInfoNV ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageToColorStateCreateInfoNV )
                ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageToColorStateCreateInfoNV ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageToColorStateCreateInfoNV )
                ) . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageToColorStateCreateInfoNV ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageToColorStateCreateInfoNV )
                ) . coverageToColorEnable as * const _ as usize } , 20usize ,
                concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageToColorStateCreateInfoNV ) , "::" ,
                stringify ! ( coverageToColorEnable ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageToColorStateCreateInfoNV )
                ) . coverageToColorLocation as * const _ as usize } , 24usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageToColorStateCreateInfoNV ) , "::" ,
                stringify ! ( coverageToColorLocation ) ));
}
impl Clone for VkPipelineCoverageToColorStateCreateInfoNV {
    fn clone(&self) -> Self { *self }
}
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_BEGIN_RANGE_NV:
          VkCoverageModulationModeNV =
    VkCoverageModulationModeNV::VK_COVERAGE_MODULATION_MODE_NONE_NV;
pub const VkCoverageModulationModeNV_VK_COVERAGE_MODULATION_MODE_END_RANGE_NV:
          VkCoverageModulationModeNV =
    VkCoverageModulationModeNV::VK_COVERAGE_MODULATION_MODE_RGBA_NV;
#[repr(u32)]
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
pub enum VkCoverageModulationModeNV {
    VK_COVERAGE_MODULATION_MODE_NONE_NV = 0,
    VK_COVERAGE_MODULATION_MODE_RGB_NV = 1,
    VK_COVERAGE_MODULATION_MODE_ALPHA_NV = 2,
    VK_COVERAGE_MODULATION_MODE_RGBA_NV = 3,
    VK_COVERAGE_MODULATION_MODE_RANGE_SIZE_NV = 4,
    VK_COVERAGE_MODULATION_MODE_MAX_ENUM_NV = 2147483647,
}
pub type VkPipelineCoverageModulationStateCreateFlagsNV = VkFlags;
#[repr(C)]
#[derive(Debug, Copy)]
pub struct VkPipelineCoverageModulationStateCreateInfoNV {
    pub sType: VkStructureType,
    pub pNext: *const ::std::os::raw::c_void,
    pub flags: VkPipelineCoverageModulationStateCreateFlagsNV,
    pub coverageModulationMode: VkCoverageModulationModeNV,
    pub coverageModulationTableEnable: VkBool32,
    pub coverageModulationTableCount: u32,
    pub pCoverageModulationTable: *const f32,
}
#[test]
fn bindgen_test_layout_VkPipelineCoverageModulationStateCreateInfoNV() {
    assert_eq!(::std::mem::size_of::<VkPipelineCoverageModulationStateCreateInfoNV>()
               , 40usize , concat ! (
               "Size of: " , stringify ! (
               VkPipelineCoverageModulationStateCreateInfoNV ) ));
    assert_eq! (::std::mem::align_of::<VkPipelineCoverageModulationStateCreateInfoNV>()
                , 8usize , concat ! (
                "Alignment of " , stringify ! (
                VkPipelineCoverageModulationStateCreateInfoNV ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageModulationStateCreateInfoNV
                ) ) . sType as * const _ as usize } , 0usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageModulationStateCreateInfoNV ) , "::" ,
                stringify ! ( sType ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageModulationStateCreateInfoNV
                ) ) . pNext as * const _ as usize } , 8usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageModulationStateCreateInfoNV ) , "::" ,
                stringify ! ( pNext ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageModulationStateCreateInfoNV
                ) ) . flags as * const _ as usize } , 16usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageModulationStateCreateInfoNV ) , "::" ,
                stringify ! ( flags ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageModulationStateCreateInfoNV
                ) ) . coverageModulationMode as * const _ as usize } , 20usize
                , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageModulationStateCreateInfoNV ) , "::" ,
                stringify ! ( coverageModulationMode ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageModulationStateCreateInfoNV
                ) ) . coverageModulationTableEnable as * const _ as usize } ,
                24usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageModulationStateCreateInfoNV ) , "::" ,
                stringify ! ( coverageModulationTableEnable ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageModulationStateCreateInfoNV
                ) ) . coverageModulationTableCount as * const _ as usize } ,
                28usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageModulationStateCreateInfoNV ) , "::" ,
                stringify ! ( coverageModulationTableCount ) ));
    assert_eq! (unsafe {
                & (
                * ( 0 as * const VkPipelineCoverageModulationStateCreateInfoNV
                ) ) . pCoverageModulationTable as * const _ as usize } ,
                32usize , concat ! (
                "Alignment of field: " , stringify ! (
                VkPipelineCoverageModulationStateCreateInfoNV ) , "::" ,
                stringify ! ( pCoverageModulationTable ) ));
}
impl Clone for VkPipelineCoverageModulationStateCreateInfoNV {
    fn clone(&self) -> Self { *self }
}
